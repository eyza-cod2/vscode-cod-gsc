{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://cod-gsc/./src/Gsc.ts","webpack://cod-gsc/./src/GscCompletionItemProvider.ts","webpack://cod-gsc/./src/GscDefinitionProvider.ts","webpack://cod-gsc/./src/GscDiagnosticsCollection.ts","webpack://cod-gsc/./src/GscFile.ts","webpack://cod-gsc/./src/GscFileParser.ts","webpack://cod-gsc/./src/GscHoverProvider.ts","webpack://cod-gsc/./src/GscSemanticTokensProvider.ts","webpack://cod-gsc/external commonjs \"vscode\"","webpack://cod-gsc/webpack/bootstrap","webpack://cod-gsc/./src/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GscCompletionItemProvider } from './GscCompletionItemProvider'; \r\nimport { GscSemanticTokensProvider } from './GscSemanticTokensProvider';\r\nimport { GscDiagnosticsCollection } from './GscDiagnosticsCollection';\r\nimport { GscDefinitionProvider } from './GscDefinitionProvider';\r\nimport { GscHoverProvider } from './GscHoverProvider';\r\n\r\n\r\nexport class Gsc {\r\n\r\n    static async activate(context: vscode.ExtensionContext) {\r\n\r\n        // Register events\r\n        GscFile.activate(context);\r\n        GscDiagnosticsCollection.activate(context);\r\n        GscSemanticTokensProvider.activate(context);\r\n        GscCompletionItemProvider.activate(context);\r\n        GscDefinitionProvider.activate(context);\r\n        GscHoverProvider.activate(context);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscData, GscGroup, GscVariableDefinition, GscVariableDefinitionType } from './GscFileParser';\r\n\r\nexport class GscCompletionItemProvider implements vscode.CompletionItemProvider {\r\n    \r\n    static async activate(context: vscode.ExtensionContext) {        \r\n        context.subscriptions.push(vscode.languages.registerCompletionItemProvider('gsc', new GscCompletionItemProvider(), '\\\\', '.', '[', ']'));\r\n    }\r\n    \r\n    async provideCompletionItems( document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken\r\n    ): Promise<vscode.CompletionItem[] | vscode.CompletionList | undefined> \r\n    {\r\n        // Get parsed file\r\n        const gscData = await GscFile.parseAndCacheFile(document.uri);\r\n\r\n        const items = await GscCompletionItemProvider.getCompletionItems(gscData, position);\r\n\r\n        return items;\r\n    }\r\n    \r\n\r\n    /**\r\n     * This function get suggestions for auto-complete. It supports:\r\n     *  - variable names (eg. level.field1, game[\"abc\"])\r\n     *  - path (eg. maps\\mp\\gametypes)\r\n     * @returns \r\n     */\r\n    public static async getCompletionItems(\r\n        gscData: GscData,\r\n        position: vscode.Position,\r\n        onlyVariables: boolean = false\r\n    ): Promise<vscode.CompletionItem[]> \r\n    {\r\n        const completionItems: vscode.CompletionItem[] = [];\r\n\r\n        //console.log(\"CompletionItemProvider --------------------------------------------------------\");\r\n\r\n        const startTime = performance.now();\r\n\r\n\r\n        // Get group before cursor\r\n        var groupAtCursor = gscData.root.findGroupOnLeftAtPosition(position);\r\n        if (groupAtCursor === undefined || groupAtCursor.parent === undefined) {\r\n            return completionItems;\r\n        }    \r\n        //console.log(\"Group at cursor: \" + groupAtCursor.toString());\r\n\r\n\r\n        // Get current function data\r\n        const functionGroup = gscData.functions.find(f => {\r\n            const range = f.scopeRange;\r\n            if (((position.line === range.start.line && position.character > range.start.character) || position.line > range.start.line) && \r\n                ((position.line === range.end.line && position.character < range.end.character) || position.line < range.end.line)) \r\n            {\r\n                return true;\r\n            }\r\n        });\r\n       \r\n        // Debug all local variables of function\r\n        //functionGroup?.localVariableDefinitions.forEach(c => console.log(c.variableReference.getTokensAsString() + \" \" + GscVariableDefinitionType[c.type]));\r\n\r\n\r\n        if (functionGroup !== undefined) {\r\n\r\n            // Create items for variables like level.aaa, game[\"bbb\"] and local1.aaa[0][1]\r\n            if (groupAtCursor.type !== GroupType.Path) {\r\n                this.createVariableItems(completionItems, position, groupAtCursor, gscData, functionGroup.localVariableDefinitions, onlyVariables);\r\n            }\r\n\r\n\r\n            // Keywords like true, false, undefined, if, else, waittillframeend, ...\r\n            if (onlyVariables === false) {\r\n                await this.createPathItems(completionItems, position, groupAtCursor);\r\n            }\r\n        }\r\n\r\n        const duration = performance.now() - startTime;\r\n        console.log(\"CompletionProvider done, exec time: \" + duration + \"ms\");\r\n\r\n        return completionItems;\r\n    }\r\n\r\n\r\n\r\n\r\n    private static createVariableItems(completionItems: vscode.CompletionItem[], position: vscode.Position, \r\n        groupAtCursor: GscGroup, gscData : GscData, localVariableDefinitions: GscVariableDefinition[], onlyVariables: boolean) \r\n    {\r\n        // Select local variables \r\n        const variableItems: {name: string, detail: string | undefined, types: Set<GscVariableDefinitionType>, kind: vscode.CompletionItemKind}[] = [];\r\n\r\n        // Get variable string before cursor\r\n        // For example:\r\n        //  level.aaa\r\n        //  array1[\"abc\"][0]\r\n        var variableBeforeCursor = groupAtCursor.getVariableStringBeforePosition(position);\r\n        //console.log(\"Var before: '\" + variableBeforeCursor + \"'\");\r\n\r\n        // Decide where we are\r\n        const inVariableName = variableBeforeCursor === \"\" || groupAtCursor?.typeEqualsToOneOf(GroupType.VariableName, GroupType.Identifier);\r\n        const inStructureVariable = (groupAtCursor?.type === GroupType.StructureField || (groupAtCursor?.getFirstToken().name === \".\"));\r\n        const inArrayBrackets = (\r\n            (groupAtCursor?.type === GroupType.Array && position.character < groupAtCursor.getRange().end.character) || // xxx[...]\r\n            (variableBeforeCursor.at(-1) === \"[\") // xxx[\r\n        );\r\n\r\n        // If user typed 'level.aaa.bbb', we want to get 'level.aaa.' (last non word char index)\r\n        const nonWordChars = variableBeforeCursor.match(/\\W/g);\r\n        const lastNonWordIndexInCursorVar = nonWordChars ? variableBeforeCursor.lastIndexOf(nonWordChars[nonWordChars.length - 1]) : -1;\r\n\r\n        //console.log(\"   inVariableName: \" + inVariableName);\r\n        //console.log(\"   inStructureVariable: \" + inStructureVariable);\r\n        //console.log(\"   inArrayVariable: \" + inArrayBrackets);\r\n\r\n\r\n\r\n        // Definition of global variables\r\n        if (!inStructureVariable && (inVariableName || inArrayBrackets)) {\r\n            variableItems.push({name: \"level\", detail: \"\", types: new Set<GscVariableDefinitionType>([GscVariableDefinitionType.Structure]), kind: vscode.CompletionItemKind.Variable});\r\n            variableItems.push({name: \"game\", detail: \"\", types: new Set<GscVariableDefinitionType>([GscVariableDefinitionType.Array]), kind: vscode.CompletionItemKind.Variable});\r\n            variableItems.push({name: \"self\", detail: \"\", types: new Set<GscVariableDefinitionType>([GscVariableDefinitionType.Unknown]), kind: vscode.CompletionItemKind.Variable});\r\n        }\r\n\r\n        // Local variables\r\n        localVariableDefinitions.forEach(g => {\r\n            getCompletionItemFromVariableDefinition(g);\r\n        });\r\n\r\n        // Level variables\r\n        if (variableBeforeCursor.startsWith(\"level\")) {\r\n            const gscFiles = GscFile.getCachedFiles();\r\n            gscFiles.forEach(g => {\r\n                g.levelVariablesDefinitions.forEach(g => {\r\n                    getCompletionItemFromVariableDefinition(g);\r\n                });\r\n            });\r\n        }\r\n\r\n        // Game variables\r\n        if (variableBeforeCursor.startsWith(\"game\")) {\r\n            const gscFiles = GscFile.getCachedFiles();\r\n            gscFiles.forEach(g => {\r\n                g.gameVariablesDefinitions.forEach(g => {\r\n                    getCompletionItemFromVariableDefinition(g);\r\n                });\r\n            });\r\n        }\r\n\r\n\r\n        function getCompletionItemFromVariableDefinition(g: GscVariableDefinition) {\r\n\r\n            // Turn group of variable reference into variable parts\r\n            //    struct1.field1      => [\"struct1\", \".field\"]\r\n            //    array1[0].field1    => [\"array1\", \"[0]\", \".field1\"]\r\n            //    array1[1][0]        => [\"array1\", \"[1]\", \"[0]\"]\r\n            const variableParts = g.variableReference.getVariableParts();\r\n\r\n\r\n            var varName = \"\";\r\n            var type: GscVariableDefinitionType = GscVariableDefinitionType.Unknown;\r\n            var kind = vscode.CompletionItemKind.Variable;\r\n            var labelName = \"\";\r\n            var detail = \"\";\r\n\r\n            for (var i = 0; i < variableParts.length; i++) {\r\n                const part = variableParts[i];\r\n                const isLast = i === (variableParts.length - 1);\r\n                \r\n                varName += part.text;\r\n                type = isLast ? g.type : part.implicitType;\r\n                kind = part.kind;\r\n\r\n\r\n                // Var name is now longer by one part, or its last value -> time to exit\r\n                // For example:\r\n                //  Text before cursor  VarName\r\n                //  struct1             struct1.aaa\r\n                //  struct1.            struct1.aaa\r\n                //  struct1.aaa         struct1.aaa[0]\r\n                if (!variableBeforeCursor.startsWith(varName) || isLast) {\r\n\r\n                    // If this longer variable name text still starts with the pre-typed text\r\n                    if (varName.startsWith(variableBeforeCursor)) {\r\n                        labelName = varName.substring(lastNonWordIndexInCursorVar + 1);\r\n\r\n                        if (inArrayBrackets) {\r\n                            if (!labelName.startsWith(\"[\") && labelName.endsWith(\"]\")) {\r\n                                labelName = labelName.substring(0, labelName.length - 1); // remove array end ]\r\n                            }\r\n                            kind = vscode.CompletionItemKind.Value;\r\n                        }\r\n                    }\r\n\r\n                    // This var does not match with text before cursor\r\n                    // If its in structure field, don't show this variable\r\n                    else if (inStructureVariable) {\r\n                        varName = \"\";\r\n                    }\r\n\r\n                    // This var does not match with text before cursor\r\n                    // If its in array, show only the root variable names\r\n                    else if (inArrayBrackets) {\r\n                        labelName = variableParts[0].text;\r\n                        type = (variableParts.length === 1) ? g.type : variableParts[0].implicitType;      \r\n                        kind = variableParts[0].kind;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Debug\r\n            const fullVarName = g.variableReference.getTokensAsString();\r\n            //console.log(fullVarName.padEnd(18) + \"   ->   \" + varName.padEnd(15) + \"   ->   \" + labelName.padEnd(10) + \"   ->   \" + GscVariableDefinitionType[type]/* + \"   ->   \" + detail*/ + \"   ->   \" + GscVariableDefinitionType[g.type]);\r\n\r\n            // Ignore empty\r\n            if (labelName === \"\") {\r\n                return;\r\n            }\r\n\r\n            // Add new the variable into completion items or update existing\r\n            const existingItem = variableItems.find(p => p.name === labelName);\r\n            if (existingItem !== undefined) {\r\n                existingItem.types.add(type);\r\n                existingItem.kind = kind;\r\n            } else {\r\n                variableItems.push({name: labelName, detail: detail, types: new Set<GscVariableDefinitionType>([type]), kind: kind});\r\n            }\r\n        }\r\n\r\n        // Insert local variables into completion items\r\n        variableItems.forEach(i => {\r\n            completionItems.push(new vscode.CompletionItem({\r\n                label: i.name,\r\n                detail: i.detail,\r\n                description: GscCompletionItemProvider.getItemDescriptionFromTypes([...i.types])\r\n            }, i.kind));\r\n        });\r\n\r\n\r\n        // Add predefined keywords\r\n        if (onlyVariables === false && (inVariableName || inArrayBrackets)) {\r\n            completionItems.push(new vscode.CompletionItem({label: \"true\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Constant));\r\n            completionItems.push(new vscode.CompletionItem({label: \"false\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Constant));\r\n            completionItems.push(new vscode.CompletionItem({label: \"undefined\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Constant));\r\n    \r\n            if (inVariableName) {\r\n                completionItems.push(new vscode.CompletionItem({label: \"if\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"else\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"for\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"while\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"switch\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"return\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                \r\n                completionItems.push(new vscode.CompletionItem({label: \"case\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"default\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                \r\n                completionItems.push(new vscode.CompletionItem({label: \"break\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"continue\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                \r\n                completionItems.push(new vscode.CompletionItem({label: \"thread\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"wait\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"waittill\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"waittillmatch\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));      \r\n                completionItems.push(new vscode.CompletionItem({label: \"waittillframeend\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"notify\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"endon\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"breakpoint\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    \r\n\r\n\r\n    /**\r\n     * Get path before cursor and search for this path in workspace folders.\r\n     */\r\n    private static async createPathItems(completionItems: vscode.CompletionItem[], position: vscode.Position, groupAtCursor: GscGroup) {\r\n        \r\n        const pathBeforeCursor = groupAtCursor.getPathStringBeforePosition(position);\r\n      \r\n        var fileSubPath = \"\";\r\n        \r\n        // Remove last word after \\\r\n        //  maps\\mp\\file -> maps\\mp\r\n        var lastPathIndex = pathBeforeCursor.lastIndexOf(\"\\\\\");\r\n        if (lastPathIndex !== -1) {\r\n            fileSubPath = pathBeforeCursor.substring(0, lastPathIndex);\r\n\r\n            // Normalize backslashes or forward slashes for consistency\r\n            fileSubPath = fileSubPath.replace(/\\\\/g, '/');\r\n        }\r\n\r\n        if (fileSubPath === \"\") {\r\n            //vscode.window.showInformationMessage(\"not a valid file path\");\r\n            return;\r\n        }\r\n\r\n        // Find any files in workspace that contains this path.\r\n        // Since this function does not return folders, search also for files in subfolder\r\n        const files = await vscode.workspace.findFiles(`**/${fileSubPath}/{*.gsc,*/*.gsc}`);\r\n\r\n        // Debug files\r\n        //files.forEach(f => console.log(f.path));\r\n\r\n        // Loop files\r\n        const keywords: {label: string, detail: string, kind: vscode.CompletionItemKind}[] = [];\r\n        for (const file of files) {\r\n\r\n            // Convert c:/folder1/workspaceFolder/maps/mp/file.gsc  ->  root/workspaceFolder/maps/mp/file.gsc\r\n            var relativePath = vscode.workspace.asRelativePath(file.path, false);\r\n\r\n            // Remove the folder prefix that user pre-typed\r\n            //  root/workspaceFolder/maps/mp/file.gsc       -> file.gsc\r\n            //  root/workspaceFolder/maps/mp/dir/file.gsc   -> dir/file.gsc\r\n            const subpathIndex = relativePath.indexOf(fileSubPath);  \r\n            if (subpathIndex !== -1) {\r\n                var subpathKeyword = relativePath.substring(subpathIndex + fileSubPath.length + 1);\r\n\r\n                const slashIndex = subpathKeyword.indexOf(\"/\");\r\n\r\n                // Folder\r\n                if (slashIndex !== -1) {\r\n                    const folderName = subpathKeyword.substring(0, slashIndex);\r\n                    const exists = keywords.some(k => k.label === folderName);\r\n                    if (!exists) {\r\n                        keywords.push({label: folderName, detail: \"\", kind: vscode.CompletionItemKind.Folder});\r\n                    }\r\n                }\r\n                // File\r\n                else {\r\n                    // Get file extension\r\n                    var re = /(?:\\.([^.]+))?$/;\r\n                    const fileExtension = re.exec(subpathKeyword)?.[1] ?? \"\";\r\n                    if (fileExtension.toLowerCase() !== \"gsc\") {\r\n                        continue;\r\n                    }\r\n                    var fileName = subpathKeyword.substring(0, subpathKeyword.length - 4); // remove .gsc extension from file name\r\n\r\n                    keywords.push({label: fileName, detail: \".gsc\", kind: vscode.CompletionItemKind.File});\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add completion items\r\n        keywords.forEach(k => {\r\n            completionItems.push(new vscode.CompletionItem({ label: k.label, description: \"\", detail: k.detail}, k.kind));\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    public static getItemDescriptionFromTypes(types: GscVariableDefinitionType[]) {\r\n        const unknownValueTypes = [GscVariableDefinitionType.UnknownValue, GscVariableDefinitionType.UnknownValueFromFunction, GscVariableDefinitionType.UnknownValueFromVariable];\r\n        \r\n        var typesString = types\r\n            .filter(t => !unknownValueTypes.includes(t))\r\n            .map(type => {\r\n                if (type === GscVariableDefinitionType.Unknown) {\r\n                    return \"?\";\r\n                } else {\r\n                    function addSpaceBetweenLowerUpper(str: string): string {\r\n                        return str.replace(/([a-z])([A-Z])/g, '$1 $2');\r\n                    }\r\n                    return addSpaceBetweenLowerUpper(GscVariableDefinitionType[type]).toLowerCase();\r\n                }\r\n            })\r\n            .join(\", \");\r\n\r\n        if (typesString === \"?\") {\r\n            typesString = \"\";\r\n        }\r\n        if (typesString !== \"\") {\r\n            typesString = \"(\" + typesString + \")\";\r\n        }\r\n\r\n        return typesString;\r\n    }\r\n\r\n\r\n\r\n\r\n}","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscData, GscFileParser } from './GscFileParser';\r\n\r\nexport class GscDefinitionProvider implements vscode.DefinitionProvider {\r\n\r\n    static async activate(context: vscode.ExtensionContext) {       \r\n        context.subscriptions.push(vscode.languages.registerDefinitionProvider('gsc', new GscDefinitionProvider()));\r\n    }\r\n\r\n    async provideDefinition(\r\n        document: vscode.TextDocument, \r\n        position: vscode.Position, \r\n        token: vscode.CancellationToken\r\n    ): Promise<vscode.Location[] | null> \r\n    {\r\n        // Get parsed file\r\n        const gscData = await GscFile.getFile(document.uri);\r\n\r\n        const locations = await this.getFunctionDefinitionLocations(gscData, position, document.uri);\r\n\r\n        return locations;\r\n    }\r\n\r\n\r\n    /**\r\n     * This function finds definitions of function names in current file, included files and in external files\r\n     *  @example\r\n     *     function(1, 2);\r\n     *     function_included();\r\n     *     _tests\\definition_file::function_file();\r\n     * @returns \r\n     */\r\n    public async getFunctionDefinitionLocations(gscData: GscData, position: vscode.Position, documentUri: vscode.Uri): Promise<vscode.Location[]> {\r\n        const locations: vscode.Location[] = [];\r\n        \r\n        // Get group before cursor\r\n        var groupAtCursor = gscData.root.findGroupOnLeftAtPosition(position);\r\n        if (groupAtCursor === undefined || groupAtCursor.parent === undefined) {\r\n            return locations;\r\n        }\r\n\r\n        if (groupAtCursor.type === GroupType.FunctionName) {\r\n            const funcData = groupAtCursor.getFunctionNameAndPath();\r\n            if (funcData !== undefined) {\r\n                locations.push(...await GscFile.getFunctionNameDefinitions(funcData.name, funcData.path, documentUri));\r\n            }\r\n        }\r\n\r\n        //console.log(groupAtCursor.toString());\r\n\r\n        //console.log(locations.map(l => l.uri.path).join(\"\\n\"));\r\n\r\n        return locations;\r\n    }\r\n\r\n}","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscGroup, TokenType } from './GscFileParser';\r\n\r\nexport class GscDiagnosticsCollection {\r\n    private static diagnosticCollection: vscode.DiagnosticCollection;\r\n\r\n    static async activate(context: vscode.ExtensionContext) {\r\n        this.diagnosticCollection = vscode.languages.createDiagnosticCollection('gsc');\r\n        context.subscriptions.push(this.diagnosticCollection);\r\n\r\n        GscFile.onDidParseDocument(uri => this.updateDiagnostics(uri));\r\n        GscFile.onDidDeleteDocument(uri => this.deleteDiagnostics(uri));\r\n\r\n        // TODO on rename\r\n    }\r\n\r\n\r\n    /**\r\n     * This function is called when some gsc file is parsed. \r\n     * The parsed gsc file will be analyzed for commons errors like:\r\n     *  - missing ;\r\n     *  - unexpected tokens (bad syntax)\r\n     */\r\n    static async updateDiagnostics(uri: vscode.Uri) {\r\n        //console.log(\"[DiagnosticsProvider]\", \"Document changed, creating diagnostics...\");\r\n\r\n        const diagnostics: vscode.Diagnostic[] = [];\r\n\r\n        const gscData = await GscFile.getFile(uri);\r\n\r\n        walkGroupItems(gscData.root, gscData.root.items);\r\n\r\n        this.diagnosticCollection.set(uri, diagnostics);\r\n\r\n\r\n\r\n        function walkGroupItems(parentGroup: GscGroup, items: GscGroup[]) {\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < items.length; i++) {\r\n                const innerGroup = items[i];\r\n                const nextGroup = items.at(i + 1);\r\n\r\n                const diagnostic = action(parentGroup, innerGroup);\r\n                if (diagnostic === undefined) {\r\n                    walkGroupItems(innerGroup, innerGroup.items);\r\n                } else {\r\n                    diagnostics.push(diagnostic);\r\n                }\r\n\r\n\r\n                function action(parentGroup: GscGroup, group: GscGroup): vscode.Diagnostic | undefined\r\n                {\r\n                    if (group.type === GroupType.Unknown) {\r\n                        return new vscode.Diagnostic(group.getRange(), \"Unexpected token\", vscode.DiagnosticSeverity.Error);\r\n                    }\r\n                    else if (group.solved === false) {\r\n        \r\n                        if (group.type === GroupType.Statement && parentGroup.type !== GroupType.TerminatedStatement) {\r\n                            if (nextGroup === undefined || nextGroup.solved) {\r\n                                return new vscode.Diagnostic(group.getRange(), \"Missing ;\", vscode.DiagnosticSeverity.Error);\r\n                            } else {\r\n                                return undefined; // ignore this error if next group is also not solved\r\n                            }\r\n                        }\r\n                        else if (group.typeEqualsToOneOf(GroupType.Expression, GroupType.ForExpression) && group.items.length === 0) {\r\n                            return new vscode.Diagnostic(group.getRange(), \"Empty expression\", vscode.DiagnosticSeverity.Error);\r\n                        }\r\n                        else\r\n                        {\r\n                            const firstToken = group.getFirstToken();\r\n            \r\n                            var token = group.getSingleToken();\r\n                            if (token !== undefined) {\r\n                                return new vscode.Diagnostic(group.getRange(), \"Unexpected token \" + firstToken.name, vscode.DiagnosticSeverity.Error);\r\n                            } else {\r\n                                const range = group.getRange();\r\n                                return new vscode.Diagnostic(range, \"Unexpected tokens - \" + group.toString(), vscode.DiagnosticSeverity.Error);\r\n                            }\r\n                        }\r\n        \r\n                    } else {\r\n                        switch (group.type as GroupType) {\r\n         \r\n                            case GroupType.ExtraTerminator:\r\n                                return new vscode.Diagnostic(group.getRange(), \"Terminator ; is not needed\", vscode.DiagnosticSeverity.Information);\r\n        \r\n                            /*\r\n                            case GroupType.TerminatedStatement:\r\n                                if (group.items.length <= 1) {\r\n                                    new vscode.Diagnostic(group.getRange(), \"Unreachable code\", vscode.DiagnosticSeverity.Warning));\r\n                                    return true;\r\n                                }\r\n                                break;*/\r\n                        }\r\n                    }\r\n        \r\n        \r\n                    /*\r\n                    if (group.deadCode && parentGroup.deadCode === false) {\r\n                        new vscode.Diagnostic(group.getRange(), \"Unreachable code\", vscode.DiagnosticSeverity.Warning));\r\n                        return true;\r\n                    }*/\r\n        \r\n                    return undefined;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n\r\n        //console.log(\"[DiagnosticsProvider]\", \"Diagnostics done\");\r\n    }\r\n\r\n    static deleteDiagnostics(uri: vscode.Uri) {\r\n        this.diagnosticCollection.delete(uri);\r\n    }\r\n\r\n    static async createDiagnosticsForAll() {\r\n        console.log(\"[DiagnosticsProvider]\", \"Creating overall diagnostics...\");\r\n\r\n        this.diagnosticCollection.clear();\r\n\r\n        var files = GscFile.getCachedFiles();\r\n\r\n        for(const [uri, gsc] of files) {\r\n            this.updateDiagnostics(vscode.Uri.parse(uri));\r\n        }\r\n\r\n        console.log(\"[DiagnosticsProvider]\", \"Creating overall diagnostics done\");\r\n    }\r\n}\r\n\r\n/*\r\n\r\n        // Define a simple object to hold the boolean value\r\n        type SolverData = {\r\n            scopeEnded: boolean;\r\n        };\r\n\r\n        function solve_unsolved(\r\n            parentGroup: GscGroup,\r\n            lastFunctionScope: GscGroup | undefined = undefined, \r\n            lastIfScope: GscGroup | undefined = undefined, \r\n            lastForScope: GscGroup | undefined = undefined, \r\n            lastWhileScope: GscGroup | undefined = undefined, \r\n            lastSwitchScope: GscGroup | undefined = undefined,  \r\n            lastCaseScope: GscGroup | undefined = undefined, \r\n            lastScope: GscGroup | undefined = undefined, \r\n            scopeEnded: boolean = false\r\n        ): SolverData\r\n        {\r\n            const data: SolverData = {\r\n                scopeEnded: false\r\n            };\r\n            \r\n            switch (parentGroup.type as GroupType) {   \r\n                case GroupType.FunctionScope:\r\n                    lastFunctionScope = parentGroup;\r\n                    break;  \r\n                case GroupType.IfScope:\r\n                    lastIfScope = parentGroup;\r\n                    break;          \r\n                case GroupType.ForScope:\r\n                    lastForScope = parentGroup;\r\n                    break;          \r\n                case GroupType.WhileScope:\r\n                    lastWhileScope = parentGroup;\r\n                    break;         \r\n                case GroupType.SwitchScope:\r\n                    lastSwitchScope = parentGroup;\r\n                    break;         \r\n                case GroupType.CaseScope:\r\n                    lastCaseScope = parentGroup;\r\n                    break;      \r\n                case GroupType.Scope:\r\n                    lastScope = parentGroup;\r\n                    break;\r\n            }\r\n\r\n            const inAnyOfScope = \r\n                lastFunctionScope !== undefined || lastIfScope !== undefined || lastForScope !== undefined || \r\n                lastWhileScope !== undefined || lastSwitchScope !== undefined || lastCaseScope !== undefined || lastScope !== undefined;\r\n\r\n            if (scopeEnded) {\r\n                parentGroup.deadCode = true;\r\n                data.scopeEnded = true;\r\n            }\r\n\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < parentGroup.items.length; i++) {\r\n                const innerGroup = parentGroup.items[i];\r\n                const innerData = solve_unsolved(innerGroup, lastFunctionScope, lastIfScope, lastForScope, lastWhileScope, lastSwitchScope, lastCaseScope, lastScope, scopeEnded);        \r\n                scopeEnded = innerData.scopeEnded;\r\n            }\r\n\r\n            \r\n            switch (parentGroup.type as GroupType) {\r\n\r\n                case GroupType.Root:\r\n                    break;\r\n\r\n                case GroupType.DeveloperBlock:\r\n                    parentGroup.solved = true; \r\n                    break;\r\n\r\n                case GroupType.FunctionDefinition:\r\n                    if (lastFunctionScope === undefined) { // root\r\n                        parentGroup.solved = true; \r\n                    } \r\n                    break;\r\n\r\n                \r\n                case GroupType.FunctionScope:\r\n                case GroupType.IfScope:\r\n                case GroupType.ForScope:\r\n                //case GroupType.WhileScope:\r\n                case GroupType.CaseScope:\r\n                case GroupType.Scope:\r\n                    // Scope inside known scopes are valid\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n                        const childGroup2 = parentGroup.items.at(i + 1);\r\n                        if (childGroup1.type === GroupType.Scope) {\r\n                            childGroup1.solved = true;\r\n                        }\r\n                        if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.Semicolon)) {\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Token);\r\n                            const newGroup = groupItems(parentGroup, i, GroupType.TerminatedStatement, 0, 0, childGroup1);\r\n                            newGroup.solved = true;\r\n                        }\r\n                    } \r\n                    break;\r\n\r\n                case GroupType.SwitchScope:\r\n\r\n                    break;\r\n\r\n                case GroupType.TerminatedStatement:\r\n\r\n                    if (inAnyOfScope) {\r\n\r\n                        if (lastSwitchScope === undefined || lastCaseScope !== undefined) { // switch scope can contain only CaseLabel\r\n                            parentGroup.solved = true;\r\n                        }\r\n\r\n                        if (parentGroup.items.length === 2 && \r\n                            parentGroup.items[0].type === GroupType.Statement && parentGroup.items[0].items.length === 1 &&\r\n                            parentGroup.items[0].items[0].type === GroupType.ReservedKeyword)\r\n                        {\r\n                            const name = parentGroup.items[0].items[0].getSingleToken()?.name;\r\n                            if (name === undefined) { break; }\r\n                            switch (name) {\r\n                                case \"break\": // for, while, case\r\n                                    if (lastForScope !== undefined || lastWhileScope !== undefined || lastCaseScope !== undefined) {\r\n                                        data.scopeEnded = true;   // everything in this scope is dead code\r\n                                    } else {\r\n                                        parentGroup.solved = false;\r\n                                    }\r\n                                    break;\r\n        \r\n                                case \"continue\": // for, while\r\n                                    if (lastForScope !== undefined || lastWhileScope !== undefined) {\r\n                                        data.scopeEnded = true; // everything in this scope is dead code\r\n                                    } else {\r\n                                        parentGroup.solved = false;\r\n                                    }\r\n                                    break;\r\n        \r\n                                case \"return\": // function\r\n                                    if (lastFunctionScope !== undefined) {\r\n                                        data.scopeEnded = true; // everything in this scope is dead code\r\n                                    } else {\r\n                                        parentGroup.solved = false;\r\n                                    }\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.TerminatedPreprocessorStatement:\r\n                    break;\r\n\r\n                case GroupType.VariableReference:\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n        \r\n                        // Make inside of array solved\r\n                        // game[] or level.aaa[]\r\n                        if (childGroup1.type === GroupType.Array && childGroup1.solved) \r\n                        {\r\n                            const innerGroup = childGroup1.items.at(0);\r\n                            if (innerGroup !== undefined && typeEqualsToOneOf(innerGroup.type, ...valueTypesWithIdentifier)) {\r\n                                changeGroupToSolvedAndChangeType(childGroup1, innerGroup, GroupType.Value);\r\n                            }\r\n                        }\r\n                    } \r\n                    break;\r\n\r\n                case GroupType.Expression:\r\n                    if (parentGroup.items.length === 1 && parentGroup.items[0].type === GroupType.Identifier) {\r\n                        changeGroupToSolvedAndChangeType(parentGroup, parentGroup.items[0], GroupType.VariableReference);\r\n                    }\r\n                    else if (parentGroup.items.length === 1 && typeEqualsToOneOf(parentGroup.items[0].type, ...valueTypes)) {\r\n                        parentGroup.items[0].solved = true;\r\n                    } else {\r\n                        parentGroup.solved = false; // empty expressions like ->  1 + ()\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.FunctionParametersExpression:\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n\r\n                        // Parameter\r\n                        if ((i % 2) === 0) {\r\n                            \r\n                            // Function definition\r\n                            if (inAnyOfScope === false && childGroup1.type === GroupType.Identifier) {                          \r\n                                if (inAnyOfScope === false) {\r\n                                    childGroup1.type = GroupType.FunctionParameterName;\r\n                                    childGroup1.solved = true;\r\n                                }                        \r\n                            // Function call\r\n                            } else if (inAnyOfScope && typeEqualsToOneOf(childGroup1.type, ...valueTypesWithIdentifier)) {\r\n                                if (childGroup1.type === GroupType.Identifier) {\r\n                                    changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.VariableReference);\r\n                                } else {\r\n                                    childGroup1.solved = true;\r\n                                }\r\n                            }\r\n\r\n                        // Separator\r\n                        } else if (i + 1 < parentGroup.items.length) {\r\n                            if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator) && (i % 2) !== 0) {\r\n                                changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Token);\r\n                            }\r\n                        }\r\n        \r\n                    } \r\n                    break;\r\n\r\n                case GroupType.KeywordParametersExpression:\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n\r\n                        // Parameter\r\n                        if ((i % 2) === 0) {                           \r\n                            if (typeEqualsToOneOf(childGroup1.type, ...valueTypesWithIdentifier)) {\r\n                                if (childGroup1.type === GroupType.Identifier) {\r\n                                    changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.VariableReference);\r\n                                } else {\r\n                                    childGroup1.solved = true;\r\n                                }\r\n                            }\r\n                        // Separator\r\n                        } else if (i + 1 < parentGroup.items.length) {\r\n                            if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator) && (i % 2) !== 0) {\r\n                                changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Token);\r\n                            }\r\n                        }\r\n        \r\n                    } \r\n                    break;\r\n\r\n                case GroupType.ForExpression:\r\n                    // for (;;) is minimum\r\n                    if (parentGroup.items.length < 2) {\r\n                        parentGroup.solved = false;\r\n                        break;\r\n                    }\r\n                    var paramPos = 0;\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n\r\n                        // for (;;)\r\n                        // for (; i < 5;)\r\n                        // for (i = 1; i < 5; i++)\r\n                        // - first (i = 1;) will be already solved as TerminatedToken\r\n                        if (paramPos === 0 && typeEqualsToOneOf(childGroup1.type, GroupType.TerminatedStatement)) {\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.TerminatedStatement);\r\n                            paramPos++;\r\n                        }\r\n                        else if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.Semicolon)) {\r\n                            paramPos++;\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Token);\r\n\r\n                        } else if (paramPos === 1 && typeEqualsToOneOf(childGroup1.type, ...valueTypesWithIdentifier)) {\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Value);\r\n\r\n                        } else if (paramPos === 2 && typeEqualsToOneOf(childGroup1.type, GroupType.Statement)) {\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.TerminatedStatement);\r\n\r\n                        } else {\r\n                            paramPos++;\r\n                        }\r\n                    }\r\n                    if (paramPos >= 3) {\r\n                        parentGroup.solved = false;\r\n                        break;\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.ReservedKeyword:\r\n\r\n                    break;\r\n            }\r\n\r\n            return data;\r\n        }\r\n\r\n        */","import * as vscode from 'vscode';\r\nimport { GscFileParser, GscData } from './GscFileParser';\r\n\r\n\r\n/**\r\n * On startup scan every .gsc file, parse it, and save the result into memory.\r\n * Watch file changes and parse the files again when changed.\r\n * When file is opened in editor, use the editor content.\r\n */\r\nexport class GscFile {\r\n\r\n    private static parsedFiles: Map<string, GscData> = new Map();\r\n    private static _onDidParseDocument: vscode.EventEmitter<vscode.Uri> = new vscode.EventEmitter<vscode.Uri>();\r\n    private static _onDidDeleteDocument: vscode.EventEmitter<vscode.Uri> = new vscode.EventEmitter<vscode.Uri>();\r\n    private static parseAllFiles = false;\r\n\r\n    \r\n    static activate(context: vscode.ExtensionContext) {\r\n        this.parseAllFiles = true;\r\n\r\n        context.subscriptions.push(vscode.workspace.onDidCreateFiles(this.onCreateFiles));\r\n        context.subscriptions.push(vscode.workspace.onDidDeleteFiles(this.onDeleteFiles));\r\n        context.subscriptions.push(vscode.workspace.onDidRenameFiles(this.onRenameFiles));\r\n\r\n        // Command to print parsed gsc file data\r\n        context.subscriptions.push(vscode.commands.registerCommand('gsc.debugParsedGscFile', async () => {\r\n            if (vscode.window.activeTextEditor === undefined) {\r\n                return;\r\n            }\r\n            const gscData = await this.getFile(vscode.window.activeTextEditor.document.uri);\r\n            this.debugParsedFile(gscData);\r\n        }));\r\n\r\n        // Command to print parsed gsc file structure\r\n        context.subscriptions.push(vscode.commands.registerCommand('gsc.debugParsedGscFileStructure', async () => {\r\n            if (vscode.window.activeTextEditor === undefined) {\r\n                return;\r\n            }\r\n            const gscData = await this.getFile(vscode.window.activeTextEditor.document.uri);\r\n            console.log(GscFileParser.debugAsString(gscData.root.tokensAll, gscData.root, true));\r\n        }));\r\n    }\r\n\r\n    // Expose an event for external subscription\r\n    public static get onDidParseDocument(): vscode.Event<vscode.Uri> {\r\n        return this._onDidParseDocument.event;\r\n    }\r\n\r\n    public static get onDidDeleteDocument(): vscode.Event<vscode.Uri> {\r\n        return this._onDidDeleteDocument.event;\r\n    }\r\n\r\n    static onCreateFiles(e: vscode.FileCreateEvent) {\r\n        for(const file of e.files) {\r\n            this.parseAndCacheFile(file);       \r\n            console.log(this, \"Added \" + vscode.workspace.asRelativePath(file) + \" for parsing\");\r\n        }\r\n    }\r\n\r\n    static onDeleteFiles(e: vscode.FileDeleteEvent) {\r\n        for(const file of e.files) {\r\n            this.removeCachedFile(file);\r\n            console.log(this, \"Removed \" + vscode.workspace.asRelativePath(file) + \" from parsing\");\r\n        }\r\n    }\r\n\r\n    static onRenameFiles(e: vscode.FileRenameEvent) {\r\n        for(const {oldUri, newUri} of e.files) {\r\n            this.removeCachedFile(oldUri);\r\n            this.parseAndCacheFile(newUri);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load all .gsc files opened in editor or found in workspace file system, parse them and save them into memory\r\n     */\r\n    public static async parseAndCacheAllFiles() {\r\n        console.log(\"Parsing GSC files...\");\r\n        const start = performance.now();\r\n\r\n        // Find all GSC files in repository\r\n        var files = await vscode.workspace.findFiles('**/*.gsc');\r\n        for (const file of files) {\r\n            var gsc = await this.parseAndCacheFile(file);\r\n        }\r\n        let elapsed = performance.now() - start;\r\n\r\n        //this.debugParsedFiles(true);\r\n        //console.log(this, \"Files:\", this.parsedFiles.size, \"Total time:\", elapsed, \"Errors:\", errors);\r\n\r\n        console.log(\"All GSC files parsed, files: \" + this.parsedFiles.size + \", time: \" + elapsed + \"ms\");\r\n    }\r\n\r\n    /**\r\n     * Load specified .gsc from editor or from file system, parse it, and save them into memory\r\n     * @param fileUri Uri of file to parse\r\n     */\r\n    public static async parseAndCacheFile(fileUri: vscode.Uri): Promise<GscData>  {\r\n        var gsc = await this.parseFile(fileUri);\r\n        this.parsedFiles.set(fileUri.toString(), gsc); // Add or update\r\n        // Notify all subscribers that the document has been parsed\r\n        this._onDidParseDocument.fire(fileUri);\r\n\r\n        // Run initial scan of all files\r\n        if (this.parseAllFiles) {    \r\n            this.parseAllFiles = false;   \r\n            await GscFile.parseAndCacheAllFiles(); \r\n            return this.getFile(fileUri);\r\n        }\r\n\r\n        return gsc;\r\n    }\r\n\r\n    /**\r\n     * Load specified .gsc from editor or from file system, parse it, and save them into memory\r\n     * @param fileUri Uri of file to parse\r\n     */\r\n    public static removeCachedFile(fileUri: vscode.Uri) {\r\n        this.parsedFiles.delete(fileUri.toString());\r\n    }\r\n\r\n\r\n    public static async getFile(fileUri: vscode.Uri): Promise<GscData> {\r\n        var gsc = this.parsedFiles.get(fileUri.toString()) ?? await this.parseAndCacheFile(fileUri);\r\n        return gsc;\r\n    }\r\n\r\n    public static getCachedFiles(): Map<string, GscData> {\r\n        return this.parsedFiles;\r\n    }\r\n\r\n\r\n    /**\r\n     * Parse file according to Uri. If the file is opened is editor, the content is used. Otherwise the file's content is read from the file system.\r\n     * @param fileUri Uri of file to parse\r\n     * @returns Parsed data\r\n     */\r\n    private static async parseFile(fileUri: vscode.Uri): Promise<GscData> {\r\n        console.log(\"Parsing \" + vscode.workspace.asRelativePath(fileUri) + \"\");\r\n\r\n        const start = performance.now();\r\n\r\n        // Check if the file is opened in any editor\r\n        const openedTextDocument = vscode.workspace.textDocuments.find(doc => doc.uri === fileUri);\r\n        \r\n        var content: string;\r\n        if (openedTextDocument) {\r\n            content = openedTextDocument.getText();\r\n        } else {\r\n            const fileContent = await vscode.workspace.fs.readFile(fileUri);      \r\n            content =  Buffer.from(fileContent).toString('utf8'); // Convert the Uint8Array content to a string\r\n        }\r\n        const endLoading = performance.now();\r\n        try {\r\n            const gscData = GscFileParser.parse(content);\r\n            const endParsing = performance.now();\r\n            console.log(`  total time: ${(endParsing - start).toFixed(1)}, loading: ${(endLoading - start).toFixed(1)}, parsing: ${(endParsing - endLoading).toFixed(1)}`);\r\n            return gscData;\r\n        } catch (error) {\r\n            vscode.window.showErrorMessage(\"Error while parsing file \" + vscode.workspace.asRelativePath(fileUri) + \". \" + error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * \r\n     * @param documentUri \r\n     * @returns \r\n     */\r\n    public static async getFunctionNameDefinitions(funcName: string, path: string, documentUri: vscode.Uri): Promise<vscode.Location[]> {\r\n        const locations: vscode.Location[] = [];\r\n\r\n        // Its external function call\r\n        if (path !== \"\") \r\n        {\r\n            const filePath = path.replace(/\\\\/g, '/') + \".gsc\";\r\n\r\n            // Try to find the file in parsed files\r\n            const gscFiles = GscFile.getCachedFiles();\r\n            gscFiles.forEach((data, uri) => {\r\n                if (uri.endsWith(filePath)) {\r\n                    data.functions.forEach(f => {\r\n                        if (f.name === funcName) {\r\n                            locations.push(new vscode.Location(vscode.Uri.parse(uri), new vscode.Position(f.range.start.line, f.range.start.character)));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } \r\n\r\n        // Its local function or included function\r\n        else {\r\n\r\n            // Find function in this file\r\n            const gscData = await GscFile.getFile(documentUri);\r\n            gscData.functions.forEach(f => {\r\n                if (f.name === funcName) {\r\n                    locations.push(new vscode.Location(documentUri, new vscode.Position(f.range.start.line, f.range.start.character)));\r\n                }\r\n            });\r\n\r\n            // Find function also in included files\r\n            gscData.includes.forEach(path => {\r\n                const filePath = path.replace(/\\\\/g, '/') + \".gsc\";\r\n\r\n                // Try to find the file in parsed files\r\n                const gscFiles = GscFile.getCachedFiles();\r\n                gscFiles.forEach((data, uri) => {\r\n                    if (uri.endsWith(filePath)) {\r\n                        data.functions.forEach(f => {\r\n                            if (f.name === funcName) {\r\n                                locations.push(new vscode.Location(vscode.Uri.parse(uri), new vscode.Position(f.range.start.line, f.range.start.character)));\r\n                            }\r\n                        });\r\n                    }\r\n                });          \r\n            });\r\n        }\r\n        \r\n        return locations;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    public static debugParsedFile(gsc: GscData) {\r\n        \r\n        console.log(\"Functions:\");\r\n        gsc.functions.forEach(f => {\r\n            console.log(\"  \" + f.name + \"(\" + f.parameters.map(p => p.name).join(\", \") + \")\");\r\n        });\r\n        console.log(\"\");\r\n        console.log(\"Variable definitions:\");\r\n        gsc.levelVariablesDefinitions.forEach(v => {\r\n            console.log(\"  \" + v.variableReference.getTokensAsString().padEnd(30));\r\n        });\r\n        gsc.gameVariablesDefinitions.forEach(v => {\r\n            console.log(\"  \" + v.variableReference.getTokensAsString().padEnd(30));\r\n        });\r\n        gsc.functions.forEach(f => {\r\n            f.localVariableDefinitions.forEach(v => {\r\n                console.log(\"  \" + v.variableReference.getTokensAsString().padEnd(30), \"  -> \" + f.name + \"()\");\r\n            });\r\n        });\r\n    }\r\n}\r\n","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\n\r\n\r\nexport enum GroupType {\r\n    /** The root of the tree */\r\n    Root,\r\n    /** Unresolved group */\r\n    Unknown,\r\n\r\n    /** Content surrounded by /##/ */\r\n    DeveloperBlock,\r\n    /** Content surrounded by /##/ */\r\n    DeveloperBlockInner,\r\n    /** Content surrounded by {} */\r\n    Scope,\r\n    /** Content surrounded by () */\r\n    Expression,\r\n    /** Content surrounded by [] */\r\n    Array,\r\n\r\n    /** Single token like ; && || ++ -- ... */\r\n    Token,\r\n    /** Predefined words like if, else, return, ... */\r\n    ReservedKeyword,\r\n    /** Not resolved word, probably variable name or function name */\r\n    Identifier,\r\n    /** Tokens considered as constants - numbers, strings, ... */\r\n    Constant,\r\n    /** Path to an external file */\r\n    Path,\r\n    /** %xanim_file_name */\r\n    XAnim,\r\n    /** Expression with 3 parameters -> (0, 0, 0) */\r\n    Vector,\r\n    /** The result of an operation, like && */\r\n    Value,\r\n\r\n    /** Casting expression like (int) - used in CoD1 */\r\n    CastExpression,\r\n    DataTypeKeyword,\r\n\r\n    /** Variable reference like level.aaa or game[\"aaa\"] or level.aaa[\"bbb\"].ccc */\r\n    Reference,\r\n    /** Name of the variable like level or game or var1 */\r\n    VariableName,\r\n    /** Field of structure variable like level.aaa  */\r\n    StructureField,\r\n\r\n    /** Statement like a=1 or a+=1 or a++ */\r\n    Statement,\r\n    /** Statement like a=1 or a+=1 or a++ terminated with ; */\r\n    TerminatedStatement,\r\n    /** Statement like #include path\\name */\r\n    PreprocessorStatement,\r\n    /** Statement like #include path\\name terminated with ; */\r\n    TerminatedPreprocessorStatement,\r\n    /** Parameters expression of preprocessor #using_animtree */\r\n    PreprocessorAnimtreeParametersExpression,\r\n\r\n    /** Single ; */\r\n    Terminator,\r\n    /** Unneeded ; after terminated statement */\r\n    ExtraTerminator,\r\n\r\n    /** Function definition funcName(p1, p2) { ... } */\r\n    FunctionDefinition,\r\n    /** Function declaration like funcName(p1, p2) */\r\n    FunctionDeclaration,\r\n    /** Like funcName() or maps\\script::funcName() */\r\n    FunctionCall,\r\n    /** Like var1 funcName() or var1 maps\\script::funcName() */\r\n    FunctionCallWithObject,\r\n    /** Like thread funcName() or thread maps\\script::funcName() */\r\n    FunctionCallWithThread,\r\n    /** Like var1 thread funcName() or var1 thread maps\\script::funcName() */\r\n    FunctionCallWithObjectAndThread,\r\n    /** Like ::funcName */\r\n    FunctionPointer,\r\n    /** Like maps\\script::funcName */\r\n    FunctionPointerExternal,\r\n    /** [[var]] */\r\n    FunctionDereference,\r\n    /** Like funcName */\r\n    FunctionName,\r\n    /** Like (..., ...) */\r\n    FunctionParametersExpression,\r\n    /** Like var1 */\r\n    FunctionParameterName,\r\n    /** func() {...} */\r\n    FunctionScope,\r\n\r\n    /** Keyword \"if\" and function parameter expression ()  */\r\n    IfDeclaration,  \r\n    /** If scope */\r\n    IfScope,\r\n\r\n    /** waittill (..., ...) */\r\n    KeywordCall,\r\n    /** level waittill (..., ...) */\r\n    KeywordCallWithObject,\r\n    /** level waittill (..., ...) */\r\n    KeywordParametersExpression,\r\n\r\n    ForDeclaration,\r\n    ForExpression,\r\n    ForScope,\r\n    ForStatement,\r\n\r\n    WhileDeclaration,\r\n    WhileScope,\r\n\r\n    SwitchDeclaration,\r\n    SwitchScope,\r\n    CaseLabel,\r\n    CaseScope\r\n}\r\n\r\n/**\r\n * First step is to parse file content into array of @see TokenType which represents words, brackets, operators, comments, strings,...\r\n * These tokens are parsed by function @see tokenize()\r\n * \r\n * Then these tokens are processed into data structure tree according to the language syntax rules via function @see group()\r\n * \r\n * The tree is then analyzed and @see GscData is returned - it contains data about functions, global variables (level, game), local variables, ...\r\n */\r\nexport class GscFileParser {\r\n\r\n    public static readonly scopeTypes: GroupType[] = [\r\n        GroupType.FunctionScope, GroupType.IfScope, GroupType.ForScope, GroupType.WhileScope, \r\n        GroupType.SwitchScope, GroupType.CaseScope, GroupType.Scope, GroupType.DeveloperBlock, GroupType.DeveloperBlockInner\r\n    ];\r\n\r\n    public static readonly functionCallTypes = [\r\n        GroupType.FunctionCall, GroupType.FunctionCallWithThread, GroupType.FunctionCallWithObjectAndThread, GroupType.FunctionCallWithObject\r\n    ];\r\n\r\n    public static readonly valueTypes = [\r\n        GroupType.Constant, GroupType.Reference, GroupType.Value,\r\n        GroupType.Expression, GroupType.Vector,\r\n        ...GscFileParser.functionCallTypes,\r\n        GroupType.FunctionPointer, GroupType.FunctionPointerExternal\r\n    ];\r\n\r\n    public static readonly valueTypesWithIdentifier = [...GscFileParser.valueTypes, GroupType.Identifier];\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Parse GSC file\r\n     * @param content File content of GSC file to be parsed\r\n     * @returns Parsed data\r\n     */\r\n    public static parse(content: string): GscData \r\n    {\r\n        var tokens = this.tokenize(content);\r\n        var rootGroup = this.group(tokens);\r\n        var data = this.analyze(rootGroup, content);\r\n        return data;\r\n    }\r\n\r\n\r\n    /**\r\n     * Parse file content into array of tokens\r\n     * @param content The file content\r\n     * @returns Array of tokens\r\n     */\r\n    public static tokenize(content: string): GscToken[]\r\n    {\r\n        var tokens: GscToken[] = [];\r\n             \r\n        var level: Level = Level.Default;\r\n        var levelChangeStart = -1;\r\n        var line = 0; // line number (starting from 0)\r\n        var char = 0; // char number (starting from 0)\r\n        var skip = 0;\r\n        var sLastComment: string | undefined = undefined;\r\n        var lastToken: GscToken | undefined = undefined;\r\n             \r\n        const len = content.length;\r\n\r\n        for (let i = 0; i <= len; i++) {\r\n            const c = i < len ? content[i] : '';\r\n            const c_prev = i > 0 ? content[i-1] : '';\r\n            const c_next = i < len - 1 ? content[i+1] : '';\r\n\r\n            /* First we need to tokenize the big blocks:\r\n                /* multi-line comments * /\r\n                // single-line comment\r\n                \"strings\" \r\n                keywords\r\n                0.001           // numbers\r\n                ' '             // other characters\r\n            */\r\n\r\n            // Count new lines and char\r\n            // Windows: \"\\r\\n\"    Linux:  \"\\n\"\r\n            if (i > 0) {\r\n                if (content[i-1] === '\\n') {\r\n                    line++;\r\n                    char = 0;\r\n                } else {\r\n                    char++;\r\n                }\r\n            }\r\n\r\n            // This char must be skipped, because is already processed\r\n            if (skip > 0) {\r\n                skip--;\r\n                continue;\r\n            }\r\n\r\n            function addToken(type: TokenType, startOffset: number, endOffset: number) {\r\n                var text = content.substring(startOffset, endOffset);\r\n                const token: GscToken = {\r\n                    index: tokens.length,\r\n                    name: text, \r\n                    offset: startOffset,\r\n                    range: new vscode.Range(line, char - (i - startOffset), line, char - (i - endOffset)),\r\n                    commentBefore: sLastComment,\r\n                    type: type\r\n                };\r\n                tokens.push(token);\r\n                lastToken = token;\r\n\r\n                sLastComment = undefined;\r\n            }\r\n\r\n            /***************************************************************************************************************************************************************\r\n            * Save content of things like function name, preprocessor name, ...\r\n            ****************************************************************************************************************************************************************/\r\n            switch (level as Level) {\r\n\r\n                case Level.SingleLineComment:\r\n                    if (c === '\\n' || c === '') {\r\n                        sLastComment = content.substring(levelChangeStart + 2, ((c_prev === '\\r') ? i - 1 : i));\r\n                        level = Level.Default;\r\n                    }\r\n                    continue; // go to next char\r\n                    \r\n                case Level.MultiLineComment:\r\n                    if ((c === '*' && c_next === '/') || c === '') {\r\n                        skip += 1;\r\n                        sLastComment = content.substring(levelChangeStart + 2, i);\r\n                        level = Level.Default;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                // Its in preprocessor name and this char is no longer a valid preprocessor name, save the name and move level\r\n                case Level.PreprocessorName:\r\n                    if (!/^[a-zA-Z_0-9]$/.test(c)) {\r\n                        addToken(TokenType.Preprocessor, levelChangeStart, i);\r\n                        level = Level.Default;\r\n                        break;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                // Its in string constant and this char is end of the string, save the string content and move level\r\n                case Level.String:\r\n                case Level.LocalizedString:\r\n                case Level.CvarString:  // only COD:BO1\r\n                    if (c === '\\\\' && c_next === '\\\\') { // skip escaped \\\r\n                        skip += 1;\r\n                    } else if (c === '\\\\' && c_next === '\"') { // skip escaped \"\r\n                        skip += 1;\r\n                    } else if (c === '\"' || c === '') {\r\n                        const map = new Map<Level, TokenType>([\r\n                            [Level.String, TokenType.String],\r\n                            [Level.LocalizedString, TokenType.LocalizedString],\r\n                            [Level.CvarString, TokenType.CvarString],\r\n                        ]);\r\n                        const tokeType = map.get(level);\r\n                        addToken(tokeType!, levelChangeStart, i + 1);\r\n                        level = Level.Default;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                // Number did not start with dot, but dot may appear once additionally\r\n                case Level.Number:\r\n                    if (c === '.') {\r\n                        level = Level.Float;\r\n                    }\r\n                    else if (!/^[0-9]$/.test(c)) {\r\n                        addToken(TokenType.Number, levelChangeStart, i);\r\n                        level = Level.Default;\r\n                        break;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                // Float number - the dot is already processed once, now only digits should appear\r\n                case Level.Float:\r\n                    if (!/^[0-9]$/.test(c)) {\r\n                        addToken(TokenType.Number, levelChangeStart, i);\r\n                        level = Level.Default;\r\n                        break;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                case Level.Keyword:\r\n                    if (!/^[a-zA-Z_0-9]$/.test(c)) {\r\n                        addToken(TokenType.Keyword, levelChangeStart, i);\r\n                        level = Level.Default;\r\n                        break;\r\n                    }\r\n                    continue; // go to next char\r\n            }\r\n\r\n            // It was last char, exit\r\n            if (c === '') {\r\n                break;\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n            /***************************************************************************************************************************************************************\r\n            * Always skip comments, developer blocks and whitespace\r\n            ****************************************************************************************************************************************************************/\r\n            switch (c) {\r\n                case '/':\r\n\r\n                    switch(c_next) {\r\n                        case '/':\r\n                            level = Level.SingleLineComment;\r\n                            levelChangeStart = i;\r\n                            skip += 1;\r\n                            continue; // go to next char\r\n\r\n                        case '*':\r\n                            level = Level.MultiLineComment;\r\n                            levelChangeStart = i;\r\n                            skip += 1;\r\n                            continue; // go to next char\r\n\r\n                        case '#':\r\n                            addToken(TokenType.DeveloperStart, i, i + 2);\r\n                            skip += 1;\r\n                            continue; // go to next char\r\n\r\n                        case '=': \r\n                            addToken(TokenType.Assignment2, i, i + 2);  // /=\r\n                            skip += 1; \r\n                            continue; \r\n\r\n                        default: \r\n                            addToken(TokenType.Operator, i, i + 1);     // /\r\n                            continue; \r\n                    }\r\n                    break;\r\n\r\n                case '#':\r\n                    if (c_next === '/') {\r\n                        addToken(TokenType.DeveloperEnd, i, i + 2);\r\n                        skip += 1;\r\n                        continue; // go to next char\r\n                    }\r\n                    else if (/^[a-zA-Z_]$/.test(c_next)) {\r\n                        level = Level.PreprocessorName;\r\n                        levelChangeStart = i;\r\n                        continue; \r\n                    }\r\n                    else if (c_next === '\"') {\r\n                        level = Level.CvarString;\r\n                        levelChangeStart = i + 1;\r\n                        skip += 1;\r\n                        continue; \r\n                    }\r\n                    else {\r\n                        addToken(TokenType.Hashtag, i, i + 1);     // #\r\n                        continue; \r\n                    }\r\n                    break;\r\n\r\n                case '\"':\r\n                    level = Level.String;\r\n                    levelChangeStart = i;\r\n                    continue; // go to next char\r\n\r\n                case ',':\r\n                    addToken(TokenType.ParameterSeparator, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case '{':\r\n                    addToken(TokenType.ScopeStart, i, i + 1);\r\n                    continue; // go to next char\r\n                case '}':\r\n                    addToken(TokenType.ScopeEnd, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case '(':\r\n                    addToken(TokenType.ExpressionStart, i, i + 1);\r\n                    continue; // go to next char\r\n                case ')':\r\n                    addToken(TokenType.ExpressionEnd, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case '[':\r\n                    if (c_next === ']') {\r\n                        addToken(TokenType.Array, i, i + 2);\r\n                        skip += 1;\r\n                    } else {\r\n                        addToken(TokenType.ArrayStart, i, i + 1);\r\n                    }\r\n                    continue; // go to next char\r\n                case ']':\r\n                    addToken(TokenType.ArrayEnd, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case '.':\r\n                    // Floats starting with dot  .1337\r\n                    if (/^[0-9]$/.test(c_next)) {\r\n                        level = Level.Float;\r\n                        levelChangeStart = i;\r\n                    // Structure variables like level.aaa\r\n                    } else {\r\n                        addToken(TokenType.Structure, i, i + 1);\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                case '\\\\':\r\n                    addToken(TokenType.PathSeparator, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case ':':\r\n                    if (c_next === ':') {\r\n                        skip += 1;\r\n                        addToken(TokenType.FunctionPointer, i, i + 2);\r\n                    } else {\r\n                        addToken(TokenType.Case, i, i + 1);\r\n                    }\r\n                    continue; // go to next char\r\n\r\n\r\n\r\n\r\n\r\n                case '+': \r\n                case '-': \r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Assignment2, i, i + 2); skip = 1; continue; // +=\r\n                        default: \r\n                            if (c === c_next) {\r\n                                addToken(TokenType.Assignment3, i, i + 2); skip = 1;             // ++ --\r\n                            } else {\r\n                                addToken(TokenType.Operator, i, i + 1);                         // + -\r\n                            }\r\n                            continue; // go to next char\r\n                        }\r\n                        \r\n                case '*':\r\n                case '%':\r\n                case '^':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Assignment2, i, i + 2); skip = 1; continue; // *= /= %= ^=\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // * / % ^ \r\n                    }\r\n\r\n                case '~':\r\n                    addToken(TokenType.OperatorLeft, i, i + 1); continue;                       // ~\r\n\r\n                case '&':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Assignment2, i, i + 2); skip = 1; continue; // &=\r\n                        case '&': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // &&\r\n                        case '\"':                                                               // &\"\r\n                            level = Level.LocalizedString;\r\n                            levelChangeStart = i + 1;\r\n                            skip += 1;\r\n                            continue;\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // &\r\n                    }\r\n\r\n                case '|':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Assignment2, i, i + 2); skip = 1; continue; // |=\r\n                        case '|': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // ||\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // |\r\n                    }\r\n\r\n                case '<':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // <=\r\n                        case '<': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // <<\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // <\r\n                    }\r\n\r\n                case '>':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // >=\r\n                        case '>': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // >>\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // >\r\n                    }\r\n\r\n                case '!':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // !=\r\n                        default: addToken(TokenType.OperatorLeft, i, i + 1); continue;          // !\r\n                    }\r\n\r\n                case '=':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // ==\r\n                        default: addToken(TokenType.Assignment, i, i + 1); continue;             // =\r\n                    }\r\n                    \r\n                case ';':\r\n                    addToken(TokenType.Semicolon, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                // Ignore white spaces\r\n                case ' ':\r\n                case '\\t':\r\n                case '\\f':\r\n                case '\\n':\r\n                case '\\r':\r\n                case '\\v':\r\n                    continue; // go to next char\r\n\r\n                default:\r\n\r\n                    // keyword name\r\n                    if (/^[a-zA-Z_]$/.test(c)) { \r\n                        level = Level.Keyword;\r\n                        levelChangeStart = i;\r\n                    }\r\n                    // Number  123  or  0.1  or  1337.1337  (these may contain decimal place later on)\r\n                    else if (/^[0-9]$/.test(c)) { \r\n                        level = Level.Number;\r\n                        levelChangeStart = i;\r\n\r\n                    } else {\r\n                        addToken(TokenType.Unknown, i, i + 1);\r\n                    }\r\n\r\n                    break;\r\n            }\r\n\r\n        }\r\n\r\n        return tokens;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Group tokens according to language syntax rules into tree items and return the root item\r\n     * @param tokens Array of parsed tokens of file\r\n     * @returns The root tree of data structure tree\r\n     */\r\n    public static group(tokens: GscToken[]): GscGroup {\r\n\r\n        /*function walkGroup(currentGroup: GscGroup, action: (currentGroup: GscGroup) => void, callForEmptyGroups: boolean = false) {\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < currentGroup.items.length; i++) {\r\n                var innerGroup = currentGroup.items[i];\r\n                walkGroup(innerGroup, action, callForEmptyGroups);\r\n            }\r\n            if (callForEmptyGroups || currentGroup.items.length > 0) {\r\n                action(currentGroup);\r\n            }\r\n        }*/\r\n\r\n        function walkGroup(currentGroup: GscGroup, action: (currentGroup: GscGroup) => void, callForEmptyGroups: boolean = false) {\r\n            const stack: { group: GscGroup; processed: boolean }[] = [{ group: currentGroup, processed: false }];\r\n    \r\n            while (stack.length > 0) {\r\n                const { group, processed } = stack.pop()!;\r\n    \r\n                if (processed) {\r\n                    // Process the current group after its children\r\n                    if (callForEmptyGroups || group.items.length > 0) {\r\n                        action(group);\r\n                    }\r\n                } else {\r\n                    // Push the current group back onto the stack to be processed after its children\r\n                    stack.push({ group, processed: true });\r\n    \r\n                    // Add child items to the stack\r\n                    for (let i = group.items.length - 1; i >= 0; i--) {\r\n                        stack.push({ group: group.items[i], processed: false });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n\r\n        function groupItems(parentGroup: GscGroup, startIndex: number, wrapType: GroupType, trimGroupStartBy: number, trimGroupEndBy: number, groups: GscGroup[]): GscGroup {\r\n            if (groups.length === 0) {\r\n                throw new Error(\"No groups\");\r\n            }\r\n\r\n            // Don't wrap Value into another Value\r\n            if (startIndex === 0 && parentGroup.items.length === groups.length &&\r\n                wrapType === GroupType.Value && \r\n                parentGroup.type === GroupType.Value) {\r\n                return parentGroup;\r\n            }\r\n\r\n            const newGroup = new GscGroup({\r\n                parent: parentGroup,\r\n                type: wrapType,\r\n                tokenIndexStart: groups[0].tokenIndexStart,\r\n                tokenIndexEnd: groups[groups.length - 1].tokenIndexEnd\r\n            }, tokens);\r\n\r\n            groups.forEach(g => {\r\n                g.parent = newGroup;\r\n            });\r\n\r\n            const trimIndexStart = (trimGroupStartBy > 0) ? trimGroupStartBy : 0;\r\n            const trimIndexEnd = (trimGroupEndBy > 0) ? (groups.length - trimGroupEndBy - 1) : (groups.length - 1);\r\n\r\n            // Stack overflow error for large arrays\r\n            //newGroup.items.push(...groups.slice(trimIndexStart, trimIndexEnd));\r\n\r\n            for (var i = trimIndexStart; i <= trimIndexEnd; i++) {\r\n                newGroup.items.push(groups[i]);\r\n            }\r\n\r\n            // Value inside Value consider as solved\r\n            if (startIndex === 0 && parentGroup.items.length === groups.length && parentGroup.solved &&\r\n                typeEqualsToOneOf(wrapType, ...GscFileParser.valueTypes) && \r\n                parentGroup.typeEqualsToOneOf(...GscFileParser.valueTypes)) \r\n            {\r\n                newGroup.solved = true;\r\n            }\r\n\r\n            // Wrap this into variable\r\n            parentGroup.items.splice(startIndex, groups.length, newGroup);\r\n\r\n            return newGroup;\r\n        }\r\n\r\n\r\n        function replaceGroupsWithSingleGroup(parentGroup: GscGroup, startIndex: number, endIndex: number, type: GroupType): GscGroup {\r\n\r\n            var newGroup = new GscGroup({\r\n                parent: parentGroup,\r\n                type: type,\r\n                tokenIndexStart: parentGroup.items[startIndex].tokenIndexStart,\r\n                tokenIndexEnd: parentGroup.items[endIndex].tokenIndexEnd\r\n            }, tokens);\r\n\r\n            // Delete items and replace them with one\r\n            parentGroup.items.splice(startIndex, endIndex - startIndex + 1, newGroup);\r\n\r\n            return newGroup;\r\n        }\r\n\r\n\r\n        function groupByBracketPairs(group: GscGroup, tokenTypeStart: TokenType, tokenTypeEnd:TokenType, groupType: GroupType) {\r\n            const startIndexes: number[] = [];\r\n\r\n            if (group.items.length <= 1) { return; }\r\n\r\n            for (var i = 0; i <= group.items.length; i++) {\r\n                const tokenType = (i >= group.items.length)\r\n                                    ? undefined \r\n                                    : (group.items[i].getSingleTokenType() ?? TokenType.Unknown); // groups will be unknown\r\n\r\n                if (tokenType === tokenTypeStart) {\r\n                    startIndexes.push(i);\r\n\r\n                } else if (tokenType === tokenTypeEnd) {\r\n\r\n                    // Revert to parent group\r\n                    var indexStart = startIndexes.pop();\r\n                    \r\n                    // Update at which token the scope ends (group is the scope) and then go to parent scope\r\n                    if (indexStart !== undefined) { \r\n                        groupItems(group, indexStart, groupType, 1, 1, group.items.slice(indexStart, i + 1));\r\n                        i = indexStart - 1;\r\n                        continue; // go again to the same index\r\n                    }\r\n                }\r\n                else if (tokenType === undefined) {\r\n                    \r\n                    // If there are unclosed open bracket, add them\r\n                    while (true) {\r\n                        var indexStart = startIndexes.pop();\r\n                        if (indexStart === undefined) { break; }\r\n                        if (indexStart === group.items.length - 1) { continue; } // ignore last open bracket\r\n                        groupItems(group, indexStart, groupType, 1, 0, group.items.slice(indexStart, group.items.length));\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        function change_singleUnknownTokens(parentGroup: GscGroup) {\r\n            for (var i = 0; i < parentGroup.items.length; i++) {\r\n                var childGroup = parentGroup.items[i];\r\n\r\n                var unknownToken = childGroup.getUnknownToken();\r\n                if (unknownToken === undefined) { continue; }\r\n\r\n                switch (unknownToken.type as TokenType) {\r\n                    case TokenType.Number:\r\n                    case TokenType.String:\r\n                    case TokenType.LocalizedString:\r\n                    case TokenType.CvarString:\r\n                    case TokenType.Array:\r\n                        childGroup.type = GroupType.Constant;\r\n                        break;\r\n\r\n                    case TokenType.Preprocessor:\r\n                        childGroup.type = GroupType.ReservedKeyword;\r\n                        break;\r\n\r\n                    case TokenType.Keyword:\r\n                        const knownKeywords = [\"return\", \"if\", \"else\", \"for\", \"while\", \"switch\", \"continue\", \"break\", \"case\", \"default\", \"thread\", \"wait\", \"waittillframeend\", \"waittill\", \"waittillmatch\", \"endon\", \"notify\", \"breakpoint\"];\r\n                        const knownConstants = [\"true\", \"false\", \"undefined\"];\r\n\r\n                        if (knownConstants.includes(unknownToken.name)) {\r\n                            childGroup.type = GroupType.Constant;\r\n                        } else if (knownKeywords.includes(unknownToken.name)) {\r\n                            childGroup.type = GroupType.ReservedKeyword;\r\n                        } else {\r\n                            childGroup.type = GroupType.Identifier;\r\n                        }\r\n                        break;\r\n\r\n                    case TokenType.Semicolon:\r\n                        childGroup.type = GroupType.Terminator;\r\n                        \r\n                        break;\r\n        \r\n                }\r\n            }\r\n        }\r\n\r\n\r\n\r\n        function typeEqualsToOneOf(type: GroupType | undefined, ...groups: GroupType[]) {\r\n            if (type === undefined) { return false; }\r\n            return groups.includes(type);\r\n        }\r\n\r\n\r\n        function group_path(parentGroup: GscGroup) {\r\n            var iPathStart = -1;\r\n            if (parentGroup.items.length === 0 || parentGroup.type === GroupType.Path) { return; }\r\n            for (var i = 0; i <= parentGroup.items.length; i++) {             \r\n                const childGroup1 = parentGroup.items.at(i);\r\n                if (childGroup1?.solved === true) { continue; }\r\n                const childGroup2 = parentGroup.items.at(i + 1);\r\n                if (childGroup2?.solved === true) { continue; }\r\n                const typeOfUnknownToken2 = childGroup2?.getTypeOfUnknownToken();\r\n\r\n                const isWord = childGroup1?.typeEqualsToOneOf(GroupType.Identifier, GroupType.ReservedKeyword) ?? false;\r\n\r\n                // First word must be an identifier, after the first \\ it may also contain preserved keywords\r\n\r\n                if (((iPathStart === -1 && childGroup1?.type === GroupType.Identifier) || \r\n                     (iPathStart !== -1 && isWord)) &&           \r\n                   (typeOfUnknownToken2 === TokenType.PathSeparator || typeOfUnknownToken2 === TokenType.FunctionPointer)) \r\n                {     \r\n                    if (iPathStart === -1) {\r\n                        iPathStart = i; // This is a path start\r\n                    }\r\n                    if (typeOfUnknownToken2 === TokenType.PathSeparator) {\r\n                        i++;\r\n                    }\r\n                } else if (iPathStart > -1) {                  \r\n                    const iPathEnd = (isWord) ? i : i - 1;\r\n                    replaceGroupsWithSingleGroup(parentGroup, iPathStart, iPathEnd, GroupType.Path);\r\n                    i = iPathStart - 1;\r\n                    iPathStart = -1;\r\n                }\r\n            } \r\n        }\r\n\r\n        // (-1 - -1)    (+1 + 1)    (-.1 + +.1)    (-1, +1, -1)\r\n        function group_numberSign(parentGroup: GscGroup) {\r\n            if (parentGroup.items.length === 0 || parentGroup.type === GroupType.Value) { return; }\r\n            for (var i = -1; i <= parentGroup.items.length - 3; i++) {             \r\n                // operator\r\n                const childGroup1 = i === -1 ? undefined : parentGroup.items[i];\r\n                if (childGroup1 !== undefined && !childGroup1.isUnsolvedGroupOfOneOfType(GroupType.ReservedKeyword) &&\r\n                    !childGroup1.isUnsolvedSingleTokenOfOneOfType(\r\n                    TokenType.Operator, TokenType.ParameterSeparator, TokenType.Assignment, TokenType.Assignment2, TokenType.OperatorLeft)) { continue; }\r\n                \r\n                // + - ,\r\n                const childGroup2 = parentGroup.items[i + 1];\r\n                if (!childGroup2.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.Operator)) { continue; }\r\n                if (![\"+\", \"-\"].includes(childGroup2.getSingleToken()?.name ?? \"\")) { continue; }\r\n                \r\n                // 0.1\r\n                const childGroup3 = parentGroup.items[i + 2];\r\n                if (!childGroup3.isUnsolvedSingleTokenOfOneOfType(TokenType.Number)) { continue; }\r\n\r\n                groupItems(parentGroup, i + 1, GroupType.Value, 0, 0, [childGroup2, childGroup3]);\r\n                childGroup2.type = GroupType.Token;\r\n                childGroup2.solved = true;\r\n                childGroup3.solved = true;\r\n                // no need to exist because next index will be this new group\r\n            } \r\n        }\r\n\r\n\r\n        // [[func]]()\r\n        function group_functionPointerDereference() {\r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.items.length === 0) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {             \r\n                    // array\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (!childGroup1.isUnsolvedGroupOfOneOfType(GroupType.Array) || childGroup1.items.length !== 1) { continue; }\r\n                    const innerGroup1 = childGroup1.items[0];\r\n                    if (!innerGroup1.isUnsolvedGroupOfOneOfType(GroupType.Array) || innerGroup1.items.length === 0) { continue; }\r\n                    const childGroup2 = parentGroup.items[i + 1];\r\n                    if (!childGroup2.isUnsolvedGroupOfOneOfType(GroupType.Expression)) { continue; }\r\n\r\n                    // Everything inside consider as value, will be solved later\r\n                    if (innerGroup1.items.length === 1) {\r\n                        changeGroupToSolvedAndChangeType(innerGroup1, innerGroup1.items[0], GroupType.Value);\r\n                    } else {\r\n                        const newGroup2 = groupItems(innerGroup1, 0, GroupType.Value, 0, 0, innerGroup1.items);\r\n                        newGroup2.solved = true;\r\n                    }\r\n\r\n                    const openBrackets = new GscGroup({\r\n                        parent: childGroup1,\r\n                        type: GroupType.ReservedKeyword,\r\n                        tokenIndexStart: childGroup1.tokenIndexStart,\r\n                        tokenIndexEnd: childGroup1.tokenIndexStart + 1\r\n                    }, tokens);\r\n                    openBrackets.solved = true;\r\n\r\n                    const closeBrackets = new GscGroup({\r\n                        parent: childGroup1,\r\n                        type: GroupType.ReservedKeyword,\r\n                        tokenIndexStart: childGroup1.tokenIndexEnd - 1,\r\n                        tokenIndexEnd: childGroup1.tokenIndexEnd\r\n                    }, tokens);\r\n                    closeBrackets.solved = true;\r\n\r\n                    childGroup1.type = GroupType.FunctionDereference;\r\n                    childGroup1.items.splice(0, 1, openBrackets, ...innerGroup1.items, closeBrackets); // delete the additional array\r\n\r\n                    const newGroup = groupItems(parentGroup, i, GroupType.FunctionCall, 0, 0, [childGroup1, childGroup2]);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.FunctionDereference);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.FunctionParametersExpression);\r\n                }\r\n            });\r\n        }\r\n        \r\n\r\n        // Find expression with 3 numbers separated by comma   (0, 0, 0)\r\n        function change_expressionToVector(parentGroup: GscGroup) {\r\n            if (parentGroup.items.length !== 5 || parentGroup.type === GroupType.Vector || parentGroup.type !== GroupType.Expression) { return; }\r\n            for (var i = 0; i <= parentGroup.items.length - 5; i++) {             \r\n                const childGroup1 = parentGroup.items[i];\r\n                if (!childGroup1.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier)) { continue; }\r\n                const childGroup2 = parentGroup.items[i + 1];\r\n                if (!childGroup2.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator)) { continue; }\r\n                const childGroup3 = parentGroup.items[i + 2];\r\n                if (!childGroup3.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier)) { continue; }\r\n                const childGroup4 = parentGroup.items[i + 3];\r\n                if (!childGroup4.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator)) { continue; }\r\n                const childGroup5 = parentGroup.items[i + 4];\r\n                if (!childGroup5.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier)) { continue; }\r\n\r\n                parentGroup.type = GroupType.Vector;\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Value);\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup2, GroupType.Token);\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup3, GroupType.Value);\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup4, GroupType.Token);\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup5, GroupType.Value);        \r\n            } \r\n        }\r\n\r\n\r\n        function changeGroupToSolvedAndChangeType(parentGroup: GscGroup, group: GscGroup, newType: GroupType | undefined) {           \r\n            if (newType !== undefined) {\r\n                const i = parentGroup.items.indexOf(group);\r\n                if (i === -1) {\r\n                    throw new Error(\"group was not found in parent group!\");\r\n                }\r\n\r\n                // This identifier must be resolved to variable\r\n                if (group.type === GroupType.Identifier && (newType === GroupType.Value || newType === GroupType.Reference)) {\r\n                    const newGroup = groupItems(parentGroup, i, GroupType.Reference, 0, 0, [group]);\r\n                    newGroup.solved = true;\r\n                    group.type = GroupType.VariableName;    \r\n                }\r\n\r\n                // This type is already considered as value, don't wrap into another value group\r\n                else if (typeEqualsToOneOf(group.type, ...GscFileParser.valueTypes) && group.type !== GroupType.Expression && newType === GroupType.Value)\r\n                {}   \r\n\r\n                // Check type directly without making new group\r\n                else if (group.type === GroupType.Unknown || group.type === newType || (\r\n                    group.type === GroupType.Identifier && typeEqualsToOneOf(newType, GroupType.VariableName, GroupType.FunctionName, GroupType.StructureField, GroupType.XAnim)\r\n                ) || (\r\n                    group.type === GroupType.Expression && (typeEqualsToOneOf(newType, GroupType.FunctionParametersExpression, GroupType.KeywordParametersExpression, GroupType.ForExpression, GroupType.CastExpression)) \r\n                ) || (\r\n                    group.type === GroupType.FunctionCall && (newType === GroupType.FunctionDeclaration)\r\n                ) || (\r\n                    group.type === GroupType.Scope && (typeEqualsToOneOf(newType, GroupType.FunctionScope, GroupType.IfScope, GroupType.ForScope, GroupType.WhileScope, GroupType.SwitchScope))\r\n                ) || (\r\n                    newType === GroupType.ForStatement && (typeEqualsToOneOf(group.type, GroupType.TerminatedStatement, GroupType.Terminator))\r\n                )) {\r\n                    group.type = newType;\r\n                } else {\r\n\r\n                    const newGroup = groupItems(parentGroup, i, newType, 0, 0, [group]);\r\n                    newGroup.solved = true;\r\n                    /*if (group.type === GroupType.Identifier && newType === GroupType.VariableReference) {\r\n                        group.type = GroupType.VariableName; // Identifiers inside VariableReference change to VariableName\r\n                    }*/\r\n                }\r\n            }\r\n            group.solved = true;\r\n        }\r\n\r\n        function group_byTokenAndGroup(tokenType: TokenType, groupTypesRight: GroupType[], finalType: GroupType, finalGroup1Type: GroupType, finalGroup2Type: GroupType | undefined) {        \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n                    var typeOfUnknownToken1 = childGroup1.getTypeOfUnknownToken();\r\n    \r\n                    if (typeOfUnknownToken1 === tokenType &&\r\n                        typeEqualsToOneOf(childGroup2.type, ...groupTypesRight)) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                } \r\n            });\r\n        }\r\n\r\n        function group_byGroupAndToken(groupTypesLeft: GroupType[], tokenType: TokenType, finalType: GroupType, finalGroup1Type: GroupType, finalGroup2Type: GroupType) {        \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n                    var typeOfUnknownToken2 = childGroup2.getTypeOfUnknownToken();\r\n\r\n                    if (typeEqualsToOneOf(childGroup1.type, ...groupTypesLeft) && \r\n                        typeOfUnknownToken2 === tokenType) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                } \r\n            });\r\n        }\r\n\r\n        function group_byGroupAndTokenAndGroup(groupTypesLeft: GroupType[], tokenType: TokenType, groupTypesRight: GroupType[], finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined, finalGroup3Type: GroupType | undefined) {        \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                for (var i = 0; i < parentGroup.items.length - 2; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n                    var childGroup3 = parentGroup.items[i + 2];\r\n                    if (childGroup3.solved) { continue; }\r\n                    var typeOfUnknownToken2 = childGroup2.getTypeOfUnknownToken();\r\n\r\n                    if (typeEqualsToOneOf(childGroup1.type, ...groupTypesLeft) &&\r\n                        typeOfUnknownToken2 === tokenType &&\r\n                        typeEqualsToOneOf(childGroup3.type, ...groupTypesRight)) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, [childGroup1, childGroup2, childGroup3]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup3, finalGroup3Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                } \r\n            });\r\n        }\r\n\r\n        function group_byGroupAndGroup(groupTypesLeft: GroupType[], groupTypesRight: GroupType[], finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined, backward: boolean = false) {                  \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; true; i++) {\r\n                    var index = i;\r\n                    if (backward) {\r\n                        index = parentGroup.items.length - 2 - i;\r\n                        if (index < 0) { break; }\r\n                    } else {\r\n                        if (index > parentGroup.items.length - 2) { break; }\r\n                    }\r\n                    var childGroup1 = parentGroup.items[index];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[index + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n    \r\n                    if (typeEqualsToOneOf(childGroup1.type, ...groupTypesLeft) &&\r\n                        typeEqualsToOneOf(childGroup2.type, ...groupTypesRight)) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, index, finalType, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                } \r\n            });\r\n        }\r\n\r\n\r\n        function group_variables_and_function_call(rootGroup: GscGroup) {\r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.items.length === 0) { return; }\r\n                for (var i = 0; i < parentGroup.items.length; i++) {   \r\n                    // func();\r\n                    //  var func();\r\n                    //  var thread func();\r\n                    //  thread func();\r\n                    // func() func();\r\n                    // func() thread func();\r\n                    // var func() thread func();\r\n                    // [[f]]() thread ttt();\r\n                    // ::getVar thread ttt();\r\n                    \r\n                    // variable or keyword or object reference (func call)\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    const childGroup2 = parentGroup.items.at(i + 1);\r\n                    if (childGroup2?.solved) { continue; } \r\n                    const childGroup3 = parentGroup.items.at(i + 2);\r\n                    const childGroup4 = parentGroup.items.at(i + 3);\r\n\r\n                    const typeOfUnknownToken2 = childGroup2?.getTypeOfUnknownToken();\r\n    \r\n                    // Allowed types that may appear before function call\r\n                    const allowedTypes = [\r\n                        GroupType.Identifier, GroupType.Reference, \r\n                        ...GscFileParser.functionCallTypes,\r\n                        GroupType.FunctionDereference, GroupType.FunctionPointer, GroupType.FunctionPointerExternal\r\n                    ];\r\n\r\n                    var group1_isVarReference = childGroup1.isUnsolvedGroupOfOneOfType(...allowedTypes);\r\n                    // Expressions may hide the inner groups, unwrap\r\n                    if (childGroup1.isUnsolvedGroupOfOneOfType(GroupType.Expression)) \r\n                    {\r\n                        const innerGroup = childGroup1.unwrapType(GroupType.Expression);\r\n                        group1_isVarReference = innerGroup.typeEqualsToOneOf(...allowedTypes);\r\n                    }\r\n                    const group2_isThread = childGroup2?.isReservedKeywordOfName(\"thread\") ?? false;\r\n                    const group3_isFuncCall = childGroup3?.isUnsolvedGroupOfOneOfType(GroupType.FunctionCall) ?? false;\r\n                    \r\n                    // var thread func()\r\n                    if (group1_isVarReference && group2_isThread && group3_isFuncCall) {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.FunctionCallWithObjectAndThread, 0, 0, [childGroup1, childGroup2!, childGroup3!]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Reference); \r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2!, GroupType.ReservedKeyword);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup3!, GroupType.FunctionCall);\r\n                        i--; continue; // go to same index again\r\n                    }\r\n\r\n                    const group2_isCall = childGroup2?.isUnsolvedGroupOfOneOfType(GroupType.FunctionCall, GroupType.KeywordCall) ?? false;\r\n\r\n                    // var func();   or    var waittill();\r\n                    if (group1_isVarReference && group2_isCall) {\r\n                        const finalType = childGroup2!.type === GroupType.FunctionCall \r\n                            ? GroupType.FunctionCallWithObject\r\n                            : GroupType.KeywordCallWithObject;\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, [childGroup1, childGroup2!]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Reference);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2!, undefined); // keep what it was\r\n                        i--; continue; // go to same index again\r\n                    }\r\n\r\n                    const group1_isThread = childGroup1.isReservedKeywordOfName(\"thread\");\r\n\r\n                    // thread func();\r\n                    if (group1_isThread && group2_isCall) {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.FunctionCallWithThread, 0, 0, [childGroup1, childGroup2!]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.ReservedKeyword);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2!, GroupType.FunctionCall);\r\n                        i--; continue; // go to same index again\r\n                    }\r\n\r\n\r\n                    const group1_isObject = (typeEqualsToOneOf(childGroup1.type, \r\n                        GroupType.Identifier, GroupType.Reference, GroupType.Expression, ...GscFileParser.functionCallTypes) ||\r\n                        childGroup1.type === GroupType.Constant && childGroup1.getSingleTokenType() === TokenType.String);\r\n\r\n\r\n\r\n                    // level.aaa    level.aaa.bbb    (level).aaa     getarray().size   \"weapon_\".size   \r\n                    if (childGroup2 !== undefined && childGroup3 !== undefined && \r\n                        group1_isObject &&\r\n                        typeOfUnknownToken2 === TokenType.Structure &&\r\n                        childGroup3.type === GroupType.Identifier) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Reference, 0, 0, [childGroup1, childGroup2, childGroup3]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Reference);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Token);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup3, GroupType.StructureField);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n    \r\n                    // game[]     level.aaa[]   (level.aaa)[]     getarray()[x]   \"weapon_\"[0]\r\n                    if (childGroup2 !== undefined && \r\n                        group1_isObject &&\r\n                        childGroup2.type === GroupType.Array && \r\n                        (childGroup2.items.length !== 1 || childGroup2.items[0].type !== GroupType.Array))  // ignore func dereference [[]]\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Reference, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Reference);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Array);\r\n                        // Everything inside [] consider as value, will be solved later\r\n                        if (childGroup2.items.length === 1) {\r\n                            changeGroupToSolvedAndChangeType(childGroup2, childGroup2.items[0], GroupType.Value);\r\n                        } else {\r\n                            const newGroup2 = groupItems(childGroup2, 0, GroupType.Value, 0, 0, childGroup2.items);\r\n                            newGroup2.solved = true;\r\n                        }\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n\r\n\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_casting(rootGroup: GscGroup) {\r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.items.length === 0) { return; }\r\n                for (var i = parentGroup.items.length - 2; i >= 0; i--) {\r\n                    \r\n                    // variable or keyword or object reference (func call)\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    const childGroup2 = parentGroup.items.at(i + 1);\r\n                    if (childGroup2?.solved) { continue; }\r\n\r\n                    const child1Inner1 = childGroup1.items.at(0);\r\n\r\n                    const types = [\"int\", \"bool\", \"float\", \"string\"];\r\n\r\n                    if (childGroup1.type === GroupType.Expression && childGroup1.items.length === 1 && \r\n                        child1Inner1?.type === GroupType.Identifier && types.includes(child1Inner1.getTokensAsString()) &&\r\n                        childGroup2?.typeEqualsToOneOf(...GscFileParser.valueTypesWithIdentifier))\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Value, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.CastExpression);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Value);\r\n                        child1Inner1.type = GroupType.DataTypeKeyword;\r\n                        child1Inner1.solved = true;\r\n                        i++; continue; // go again to the same index\r\n                    }\r\n                }\r\n            });\r\n        }\r\n \r\n\r\n\r\n        function group_value_operations(rootGroup: GscGroup) {\r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.items.length === 0) { return; }\r\n                for (var i = 0; i < parentGroup.items.length; i++) {   \r\n                    \r\n                    // variable or keyword or object reference (func call)\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    const childGroup2 = parentGroup.items.at(i + 1);\r\n                    if (childGroup2?.solved) { continue; } \r\n                    const childGroup3 = parentGroup.items.at(i + 2);\r\n                    const childGroup4 = parentGroup.items.at(i + 3);\r\n\r\n                    const typeOfUnknownToken1 = childGroup1.getTypeOfUnknownToken();\r\n\r\n                    // !var1   !level.aaa   !(...)      ~var1\r\n                    if (typeOfUnknownToken1 === TokenType.OperatorLeft &&\r\n                        childGroup2?.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier))\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Value, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Token);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Value);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n\r\n                    const typeOfUnknownToken3 = childGroup3?.getTypeOfUnknownToken();\r\n                    const typeOfUnknownToken2 = childGroup2?.getTypeOfUnknownToken();\r\n\r\n                    // aaa && bbb     + - * / % < > == \r\n                    if (childGroup1.typeEqualsToOneOf(...GscFileParser.valueTypesWithIdentifier) &&\r\n                        typeOfUnknownToken2 === TokenType.Operator) \r\n                    {\r\n                        // If next tokens after operator needs to be joined first\r\n                        // aaa && !var1   aaa && !level.aaa   aaa && !(...)\r\n                        if (typeOfUnknownToken3 === TokenType.OperatorLeft &&\r\n                            childGroup4?.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier))\r\n                        {\r\n                            const newGroup = groupItems(parentGroup, i + 2, GroupType.Value, 0, 0, [childGroup3!, childGroup4]);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup3!, GroupType.Token);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup4, GroupType.Value);\r\n                            i--; continue; // go again to the same index\r\n                        }\r\n\r\n                        // If next tokens after operator needs to be joined first\r\n                        // %anim_file_name\r\n                        if (childGroup3?.getSingleToken()?.name === \"%\" && \r\n                            childGroup4?.typeEqualsToOneOf(GroupType.Identifier)) \r\n                        {\r\n                            const newGroup = groupItems(parentGroup, i+2, GroupType.Constant, 0, 0, [childGroup3, childGroup4]);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup3, GroupType.Token);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup4, GroupType.XAnim);\r\n                            i--; continue; // go again to the same index\r\n                        }\r\n\r\n                        if (childGroup3?.typeEqualsToOneOf(...GscFileParser.valueTypesWithIdentifier)) {\r\n                            const newGroup = groupItems(parentGroup, i, GroupType.Value, 0, 0, [childGroup1, childGroup2!, childGroup3]);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Value);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup2!, GroupType.Token);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup3!, GroupType.Value);\r\n                            i--; continue; // go again to the same index\r\n                        }\r\n                    }\r\n\r\n                    // %anim_file_name\r\n                    else if (childGroup1.getSingleToken()?.name === \"%\" && \r\n                        childGroup2?.typeEqualsToOneOf(GroupType.Identifier)) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Constant, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Token);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.XAnim);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_byKeyword(keywordNames: string[], finalType: GroupType, finalGroup1Type: GroupType | undefined) {        \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childTokenName = childGroup1.getSingleToken()?.name;//.toLocaleLowerCase();\r\n\r\n                    // return\r\n                    if (childGroup1.type === GroupType.ReservedKeyword && keywordNames.includes(childTokenName ?? \"\"))\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, [childGroup1]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_byKeywordNameAndGroup(keywordNames: string[], groupTypesRight: GroupType[], finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined) {            \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n                    var childTokenName = childGroup1.getSingleToken()?.name;//.toLocaleLowerCase();\r\n    \r\n                    // if ()\r\n                    if (childGroup1.type === GroupType.ReservedKeyword && keywordNames.includes(childTokenName ?? \"\") &&\r\n                        childGroup2.typeEqualsToOneOf(...groupTypesRight))\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_byKeywordAndGroupAndToken(keywordNamesLeft: string[], groupTypes: GroupType[], tokenType: TokenType, finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined, finalGroup3Type: GroupType | undefined) {            \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 2; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (!childGroup1.isReservedKeywordOfName(...keywordNamesLeft)) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (!childGroup2.isUnsolvedGroupOfOneOfType(...groupTypes)) { continue; }\r\n                    var childGroup3 = parentGroup.items[i + 2];\r\n                    if (!childGroup3.isUnknownUnsolvedSingleTokenOfOneOfType(tokenType)) { continue; }\r\n    \r\n                    const newGroup = groupItems(parentGroup, i, finalType, 0, 0, [childGroup1, childGroup2, childGroup3]);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup3, finalGroup3Type);\r\n                    i--; continue; // go again to the same index           \r\n                }\r\n            });\r\n        }\r\n\r\n        \r\n        function group_byKeywordAndToken(keywordNamesLeft: string[], tokenType: TokenType, finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined) {            \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (!childGroup1.isReservedKeywordOfName(...keywordNamesLeft)) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (!childGroup2.isUnknownUnsolvedSingleTokenOfOneOfType(tokenType)) { continue; }\r\n    \r\n                    const newGroup = groupItems(parentGroup, i, finalType, 0, 0, [childGroup1, childGroup2]);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                    i--; continue; // go again to the same index           \r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_declarations() {\r\n            const map = new Map<GroupType, GroupType>([\r\n                [GroupType.IfDeclaration, GroupType.IfScope],\r\n                [GroupType.ForDeclaration, GroupType.ForScope],\r\n                [GroupType.WhileDeclaration, GroupType.WhileScope],\r\n                [GroupType.SwitchDeclaration, GroupType.SwitchScope]\r\n            ]);      \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === GroupType.TerminatedStatement) { return; }\r\n                for (var i = parentGroup.items.length - 2; i >= 0; i--) {\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (!childGroup1.isUnsolvedGroupOfOneOfType(...map.keys())) { continue; }\r\n                    const childGroup2 = parentGroup.items[i + 1];\r\n\r\n                    // Statement may be also in developer block (found in CoD1 raw code)\r\n                    // According test in CoD2 engine, developer block /##/ act the same as {}\r\n                    //   if (1) /# a = 1; b = 1;#/  (both a and b get assigned)\r\n                    if (!childGroup2.isUnsolvedGroupOfOneOfType(GroupType.Scope, GroupType.TerminatedStatement, GroupType.DeveloperBlock)) { continue; }\r\n                    // Developer block /##/ is not valid for switch\r\n                    if (childGroup1.type === GroupType.SwitchDeclaration && childGroup2.type === GroupType.DeveloperBlock) { continue; }\r\n                    \r\n                    const childGroup3 = parentGroup.items.at(i + 2);\r\n                    const childGroup4 = parentGroup.items.at(i + 3);\r\n\r\n                    if (childGroup1.type === GroupType.IfDeclaration && childGroup3 !== undefined && childGroup4 !== undefined && childGroup3.isReservedKeywordOfName(\"else\")) {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.TerminatedStatement, 0, 0, [childGroup1, childGroup2, childGroup3, childGroup4]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.IfDeclaration);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.IfScope);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup3, GroupType.ReservedKeyword);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup4, GroupType.IfScope);\r\n                    }\r\n                    else {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.TerminatedStatement, 0, 0, [childGroup1, childGroup2]);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, undefined);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, map.get(childGroup1.type));    \r\n                    }\r\n\r\n                    i++; continue; // go again to the same index\r\n                }\r\n            });\r\n        }\r\n\r\n        function group_the_rest(group: GscGroup, parentGroup: GscGroup | undefined = undefined, lastFunctionScope: GscGroup | undefined = undefined) {   \r\n\r\n            if (group.type === GroupType.FunctionScope) {\r\n                lastFunctionScope = group;\r\n            }\r\n\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < group.items.length; i++) {\r\n                const innerGroup = group.items[i];\r\n                group_the_rest(innerGroup, group, lastFunctionScope);\r\n            }\r\n\r\n            switch (group.type as GroupType) {\r\n\r\n                case GroupType.DeveloperBlock:\r\n                    // Developer block inside function change to DeveloperBlockInner\r\n                    if (lastFunctionScope !== undefined) {\r\n                        group.type = GroupType.DeveloperBlockInner;\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.ForExpression:\r\n                    // for (;;) is minimum\r\n                    if (group.items.length < 2) {\r\n                        group.solved = false;\r\n                        return;\r\n                    }\r\n                    // First join second argument Value and TerminatedStatement\r\n                    var paramPos = 0;\r\n                    for (var i = 0; i < group.items.length; i++) {\r\n                        const childGroup1 = group.items[i];\r\n                        childGroup1.solved = false; // reset solve status because TerminatedStatement is already solved\r\n\r\n                        // for (;;)                 Terminator          Terminator\r\n                        // for (;; i++)             Terminator          Terminator  TerminatedStatement\r\n                        // for (i = 1;;)            TerminatedStatement Terminator\r\n                        // for (; i < 5;)           TerminatedStatement Value       Terminator\r\n                        // for (; i < 5; i++)       TerminatedStatement Value       Terminator          TerminatedStatement   \r\n                        // for (i = 1; i < 5; i++)  TerminatedStatement Value       Terminator          TerminatedStatement\r\n\r\n                        // for (;)                  Terminator                      // excluded by (group.items.length < 2)\r\n                        // for (i = 1;)             TerminatedStatement             // excluded by (group.items.length < 2)\r\n                        // for (; i < 5)            TerminatedStatement Value\r\n                        // for (i = 1; i < 5)       TerminatedStatement Value\r\n\r\n\r\n                        if (paramPos === 0 && childGroup1.type === GroupType.TerminatedStatement) {\r\n                            changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.ForStatement);\r\n                            childGroup1.solved = true;\r\n                            paramPos++;\r\n\r\n                        } else if (paramPos === 0 && childGroup1.type === GroupType.Terminator) {\r\n                            const newGroup = groupItems(group, i, GroupType.ForStatement, 0, 0, [childGroup1]);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Terminator);\r\n                            newGroup.solved = true;\r\n                            paramPos++;\r\n\r\n                        // Change Value + TerminatedStatement (1+1)+(;) into single ForStatement\r\n                        } else if (paramPos === 1 && typeEqualsToOneOf(childGroup1.type, ...GscFileParser.valueTypesWithIdentifier)) {\r\n                            const childGroup2 = group.items.at(i + 1);\r\n                            if (childGroup2?.type === GroupType.Terminator) \r\n                            {\r\n                                const newGroup = groupItems(group, i, GroupType.ForStatement, 0, 0, [childGroup1, childGroup2]);\r\n                                childGroup1.solved = true;\r\n                                changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Terminator);\r\n                                newGroup.solved = true;\r\n                            }\r\n                            paramPos++;\r\n\r\n                        } else if (paramPos === 1 && childGroup1.type === GroupType.Terminator) {\r\n                            const newGroup = groupItems(group, i, GroupType.ForStatement, 0, 0, [childGroup1]);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Terminator);\r\n                            newGroup.solved = true;\r\n                            paramPos++;\r\n\r\n                        } else if (paramPos === 2 && typeEqualsToOneOf(childGroup1.type, GroupType.Statement)) {\r\n                            changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.ForStatement);\r\n\r\n                        } else {\r\n                            paramPos++;\r\n                        }\r\n                    }\r\n                    if (paramPos >= 3) {\r\n                        group.solved = false;\r\n                        return;\r\n                    }\r\n                    break;\r\n\r\n            \r\n                case GroupType.SwitchScope:  \r\n                    // First join non-CaseLabel groups, so we end up only with CaseLabel and CaseScope groups\r\n                    var lastLabel = -1;\r\n                    for (var i = 0; i <= group.items.length; i++) {\r\n                        const childGroup1 = i === group.items.length ? undefined : group.items[i];                   \r\n                        if (lastLabel !== -1 && i > lastLabel + 1 && (childGroup1 === undefined || childGroup1.type === GroupType.CaseLabel)) {\r\n                            const groups = group.items.slice(lastLabel + 1, i);\r\n                            const newGroup = groupItems(group, lastLabel + 1, GroupType.CaseScope, 0, 0, groups);\r\n                            i -= groups.length;\r\n                            lastLabel = -1;\r\n                        }                      \r\n                        if (childGroup1 !== undefined && childGroup1.type === GroupType.CaseLabel) {\r\n                            lastLabel = i;\r\n                        }\r\n                    }\r\n\r\n                    // Validate scope always start with CaseLabel which is followed by another CaseLabel or CaseScope\r\n                    for (var i = 0; i < group.items.length; i++) {\r\n                        const childGroup1 = group.items[i];\r\n                        const childGroup2 = group.items.at(i + 1);    \r\n        \r\n                        // Label followed by label or scope is valid\r\n                        if (childGroup1.type === GroupType.CaseLabel && childGroup2?.type === GroupType.CaseLabel){\r\n                            childGroup1.solved = true;\r\n                            continue;\r\n\r\n                        // Label followed by another label is ok\r\n                        } else if (childGroup1.type === GroupType.CaseLabel && childGroup2?.type === GroupType.CaseScope) {\r\n                            childGroup1.solved = true;\r\n                            childGroup2.solved = true;\r\n                            i++;\r\n                            continue;\r\n\r\n                        // Label that is last, don't have any scope and is missing break; is also valid\r\n                        } else if (childGroup1.type === GroupType.CaseLabel && childGroup2 === undefined) {\r\n                            childGroup1.solved = true;\r\n                            continue;\r\n                        \r\n                        } else {\r\n                            childGroup1.solved = false;\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n            \r\n                case GroupType.FunctionParametersExpression:\r\n                    for (var i = 0; i < group.items.length; i++) {\r\n                        const childGroup1 = group.items[i];\r\n\r\n                        // Parameter\r\n                        if ((i % 2) === 0) {\r\n                            \r\n                            // Function definition\r\n                            if (lastFunctionScope === undefined && childGroup1.type === GroupType.Identifier) {                          \r\n                                childGroup1.type = GroupType.FunctionParameterName;\r\n                                childGroup1.solved = true;\r\n                                \r\n                            // Function call\r\n                            } else if (typeEqualsToOneOf(childGroup1.type, ...GscFileParser.valueTypesWithIdentifier)) {\r\n                                if (childGroup1.type === GroupType.Identifier) {\r\n                                    changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.Reference);\r\n                                } else {\r\n                                    childGroup1.solved = true;\r\n                                }\r\n                            }\r\n\r\n                        // Separator\r\n                        } else if (i + 1 < group.items.length) {\r\n                            if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator) && (i % 2) !== 0) {\r\n                                changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.Token);\r\n                            }\r\n                        }\r\n        \r\n                    } \r\n                    break;\r\n\r\n\r\n                case GroupType.KeywordParametersExpression:\r\n                    for (var i = 0; i < group.items.length; i++) {\r\n                        const childGroup1 = group.items[i];\r\n\r\n                        // Parameter\r\n                        if ((i % 2) === 0) {                           \r\n                            if (typeEqualsToOneOf(childGroup1.type, ...GscFileParser.valueTypesWithIdentifier)) {\r\n                                if (childGroup1.type === GroupType.Identifier) {\r\n                                    changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.Reference);\r\n                                } else {\r\n                                    childGroup1.solved = true;\r\n                                }\r\n                            }\r\n                        // Separator\r\n                        } else if (i + 1 < group.items.length) {\r\n                            if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator) && (i % 2) !== 0) {\r\n                                changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.Token);\r\n                            }\r\n                        }\r\n        \r\n                    } \r\n                    break;\r\n            \r\n\r\n                case GroupType.Expression:\r\n\r\n                    // (var1)\r\n                    if (group.items.length === 1 && group.items[0].type === GroupType.Identifier) {\r\n                        changeGroupToSolvedAndChangeType(group, group.items[0], GroupType.Reference);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function solve_unsolved(\r\n            group: GscGroup,\r\n            parentGroup: GscGroup | undefined = undefined,\r\n            previousItem: GscGroup | undefined = undefined,\r\n            lastFunctionScope: GscGroup | undefined = undefined, \r\n            lastDeveloperScope: GscGroup | undefined = undefined\r\n        )\r\n        {\r\n            for (var i = 0; i < group.items.length; i++) {\r\n                const innerGroup = group.items[i];\r\n                const previousGroup = i === 0 ? undefined : group.items[i - 1];\r\n                solve_unsolved(\r\n                    innerGroup, \r\n                    group, \r\n                    previousGroup,\r\n                    group.type === GroupType.FunctionScope ? group : lastFunctionScope, \r\n                    group.typeEqualsToOneOf(GroupType.DeveloperBlock, GroupType.DeveloperBlockInner) ? group : lastDeveloperScope\r\n                );        \r\n            }\r\n\r\n            \r\n            switch (group.type as GroupType) {\r\n\r\n                case GroupType.Root:\r\n                    //parentGroup.solved = true;\r\n                    break;\r\n\r\n                case GroupType.TerminatedPreprocessorStatement:\r\n                case GroupType.FunctionDefinition:\r\n                    if (parentGroup !== undefined && lastFunctionScope === undefined &&\r\n                        parentGroup.typeEqualsToOneOf(GroupType.Root, GroupType.DeveloperBlock)) {\r\n                        group.solved = true; \r\n                    }\r\n                    break;\r\n\r\n                case GroupType.DeveloperBlock:\r\n                    // In root\r\n                    group.solved = lastFunctionScope === undefined && lastDeveloperScope === undefined;\r\n                    break;\r\n\r\n                case GroupType.DeveloperBlockInner:\r\n                    // In function\r\n                    group.solved = lastFunctionScope !== undefined && lastDeveloperScope === undefined;\r\n                    break;\r\n\r\n                case GroupType.Scope:\r\n                case GroupType.TerminatedStatement:\r\n                case GroupType.Terminator:\r\n                    if (parentGroup !== undefined && (\r\n                        (parentGroup.typeEqualsToOneOf(...GscFileParser.scopeTypes) && parentGroup.type !== GroupType.SwitchScope))) \r\n                    {\r\n                        if (group.type === GroupType.Terminator) {\r\n                            if (group.solved === false && (previousItem === undefined || previousItem.solved)) {\r\n                                group.type = GroupType.ExtraTerminator;\r\n                                group.solved = true; \r\n                            }\r\n                        } else {\r\n\r\n                            group.solved = true; \r\n                        }\r\n\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.Expression:\r\n\r\n                    // (( ))  Expression -> Expression!\r\n                    // ((0))  Expression -> Expression -> Constant\r\n                    if (group.items.length === 0) {\r\n                        group.solved = false;\r\n                    } else {\r\n                        if (group.items[0].typeEqualsToOneOf(...GscFileParser.valueTypes) && group.items[0].type !== GroupType.Expression) {\r\n                            group.items[0].solved = true;\r\n                        }\r\n                        if (lastFunctionScope !== undefined) {\r\n                            group.solved = true;\r\n                        }\r\n                    }\r\n                    \r\n\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n        // Create root tree item\r\n        var rootGroup = new GscGroup({\r\n            parent: undefined,\r\n            type: GroupType.Root,\r\n            tokenIndexStart: tokens.length > 0 ? 0 : -1,\r\n            tokenIndexEnd: tokens.length - 1\r\n        }, tokens);\r\n\r\n        // All tokens convert to tree item\r\n        var unsolvedTokens = tokens.map((f, i) => {\r\n            var group = new GscGroup({\r\n                parent: rootGroup,\r\n                type: GroupType.Unknown,\r\n                tokenIndexStart: i,\r\n                tokenIndexEnd: i\r\n            }, tokens);\r\n            return group;\r\n        });\r\n\r\n        //rootGroup.items.push(...unsolvedTokens);\r\n\r\n        unsolvedTokens.forEach(t => {\r\n            rootGroup.items.push(t);\r\n        });\r\n\r\n\r\n        // https://en.cppreference.com/w/c/language/operator_precedence\r\n        \r\n\r\n        walkGroup(rootGroup, (group) => { \r\n            groupByBracketPairs(group, TokenType.DeveloperStart, TokenType.DeveloperEnd, GroupType.DeveloperBlock);\r\n        });\r\n        walkGroup(rootGroup, (group) => { \r\n            groupByBracketPairs(group, TokenType.ScopeStart, TokenType.ScopeEnd, GroupType.Scope);\r\n        });\r\n        walkGroup(rootGroup, (group) => { \r\n            groupByBracketPairs(group, TokenType.ExpressionStart, TokenType.ExpressionEnd, GroupType.Expression);\r\n        });\r\n        walkGroup(rootGroup, (group) => { \r\n            groupByBracketPairs(group, TokenType.ArrayStart, TokenType.ArrayEnd, GroupType.Array);\r\n        });\r\n\r\n\r\n        //console.log(this.debug(tokens, rootGroup, true));\r\n\r\n        \r\n        // Change numbers, strings, true, false etc.. into known types like Identifiers, Constant, ReservedKeywords\r\n        walkGroup(rootGroup, (group) => { change_singleUnknownTokens(group); });\r\n\r\n        // Join +1 -1  -.1  into value\r\n        walkGroup(rootGroup, (group) => { group_numberSign(group); });\r\n\r\n        // Join path - maps\\mp\\aaa\r\n        walkGroup(rootGroup, (group) => { group_path(group); });\r\n\r\n\r\n\r\n\r\n        // Preprocessors\r\n        group_byKeywordNameAndGroup([\"#include\"], [GroupType.Path],\r\n            GroupType.PreprocessorStatement, GroupType.ReservedKeyword, GroupType.Path);\r\n        group_byKeywordNameAndGroup([\"#using_animtree\"], [GroupType.Expression],\r\n            GroupType.PreprocessorStatement, GroupType.ReservedKeyword, GroupType.PreprocessorAnimtreeParametersExpression);\r\n        group_byKeyword([\"#animtree\"], GroupType.Constant, GroupType.ReservedKeyword);\r\n\r\n        \r\n\r\n        // Join function pointer dereference, which consists of 2 inner array and expression\r\n        // [[funcPointer]]()\r\n        group_functionPointerDereference();\r\n\r\n\r\n\r\n        // Join function call = function name + expression\r\n        // CountPlayers()\r\n        group_byGroupAndGroup([GroupType.Identifier], [GroupType.Expression], \r\n            GroupType.FunctionCall, GroupType.FunctionName, GroupType.FunctionParametersExpression);\r\n\r\n        // Join function call = path + function call\r\n        // maps\\mp\\gametypes\\_teams::CountPlayers()\r\n        group_byGroupAndTokenAndGroup([GroupType.Path], TokenType.FunctionPointer, [GroupType.FunctionCall], \r\n            GroupType.FunctionCall, GroupType.Path, GroupType.Token, GroupType.FunctionCall);\r\n\r\n\r\n\r\n        // Join keyword call = keyword + expression\r\n        // waittill (\"abc\", ...)\r\n        const keywordsWithExpressionAndVar = [\"waittill\", \"waittillmatch\", \"notify\", \"endon\"];\r\n        group_byKeywordNameAndGroup(keywordsWithExpressionAndVar, [GroupType.Expression], \r\n            GroupType.KeywordCall, GroupType.ReservedKeyword, GroupType.KeywordParametersExpression);\r\n\r\n\r\n\r\n        // if ()\r\n        group_byKeywordNameAndGroup([\"if\"], [GroupType.Expression], \r\n            GroupType.IfDeclaration, GroupType.ReservedKeyword, GroupType.Expression);\r\n        // for ()\r\n        group_byKeywordNameAndGroup([\"for\"], [GroupType.Expression], \r\n            GroupType.ForDeclaration, GroupType.ReservedKeyword, GroupType.ForExpression);\r\n        // while ()\r\n        group_byKeywordNameAndGroup([\"while\"], [GroupType.Expression], \r\n            GroupType.WhileDeclaration, GroupType.ReservedKeyword, GroupType.Expression);\r\n        // switch ()\r\n        group_byKeywordNameAndGroup([\"switch\"], [GroupType.Expression], \r\n            GroupType.SwitchDeclaration, GroupType.ReservedKeyword, GroupType.Expression);\r\n\r\n\r\n        // case \"aaa\":\r\n        group_byKeywordAndGroupAndToken([\"case\"], [GroupType.Constant], TokenType.Case, \r\n            GroupType.CaseLabel, GroupType.ReservedKeyword, GroupType.Constant, GroupType.Token);\r\n        // default:\r\n        group_byKeywordAndToken([\"default\"], TokenType.Case,\r\n            GroupType.CaseLabel, GroupType.ReservedKeyword, GroupType.Token);\r\n\r\n\r\n\r\n        // ::CountPlayers\r\n        group_byTokenAndGroup(TokenType.FunctionPointer, [GroupType.Identifier], \r\n            GroupType.FunctionPointer, GroupType.Token, GroupType.FunctionName );\r\n\r\n        // maps\\mp\\gametypes\\_teams::CountPlayers\r\n        group_byGroupAndGroup([GroupType.Path], [GroupType.FunctionPointer],\r\n            GroupType.FunctionPointerExternal, GroupType.Path, GroupType.FunctionPointer);\r\n        \r\n\r\n\r\n        // Join variables - level.aaa  game[\"aaa\"] \r\n        // thread {FunctionCall}            ->   thread CountPlayers()\r\n        // var1 {FunctionCall}              ->   var1 CountPlayers()\r\n        // var1 {FunctionCallWithThread}    ->   var1 thread CountPlayers()\r\n        group_variables_and_function_call(rootGroup);\r\n\r\n        //console.log(this.debugAsString(tokens, rootGroup, true));\r\n\r\n        // Join (int)1   (int)level.name\r\n        group_casting(rootGroup);\r\n \r\n        // Join operations\r\n        // !var1   !level.aaa   !(...)   ~var1   aaa && !var1   aaa && !level.aaa   aaa && !(...)  aaa && bbb  %anim_file_name\r\n        group_value_operations(rootGroup);\r\n\r\n\r\n\r\n        // Change expression with 3 parameters to vector -> (0, 0, 0)\r\n        walkGroup(rootGroup, (group) => { change_expressionToVector(group); }); \r\n\r\n\r\n\r\n        // Assignment\r\n\r\n        // aaa = (...)\r\n        group_byGroupAndTokenAndGroup([GroupType.Identifier, GroupType.Reference], TokenType.Assignment, GscFileParser.valueTypesWithIdentifier, \r\n            GroupType.Statement, GroupType.Reference, GroupType.Token, GroupType.Value);\r\n        \r\n        // aaa += (...)\r\n        group_byGroupAndTokenAndGroup([GroupType.Identifier, GroupType.Reference], TokenType.Assignment2, GscFileParser.valueTypesWithIdentifier, \r\n            GroupType.Statement, GroupType.Reference, GroupType.Token, GroupType.Value);\r\n\r\n        // level.aaa++\r\n        group_byGroupAndToken([GroupType.Identifier, GroupType.Reference], TokenType.Assignment3, \r\n            GroupType.Statement, GroupType.Reference, GroupType.Token);\r\n\r\n\r\n\r\n\r\n        // return {Value}\r\n        group_byKeywordNameAndGroup([\"return\"], GscFileParser.valueTypesWithIdentifier, \r\n            GroupType.Statement, GroupType.ReservedKeyword, GroupType.Value);\r\n                         \r\n        // wait 0.1\r\n        group_byKeywordNameAndGroup([\"wait\"], GscFileParser.valueTypesWithIdentifier, \r\n            GroupType.Statement, GroupType.ReservedKeyword, GroupType.Value);\r\n\r\n        // Single keywords\r\n        // return     \r\n        // waittillframeend\r\n        // break\r\n        // waittillframeend\r\n        group_byKeyword([\"return\", \"break\", \"continue\", \"waittillframeend\", \"breakpoint\"], GroupType.Statement, GroupType.ReservedKeyword);\r\n                \r\n\r\n\r\n        // statement;\r\n        const terminationNeededFor = [GroupType.Statement, ...GscFileParser.functionCallTypes,\r\n            GroupType.KeywordCall, GroupType.KeywordCallWithObject];\r\n        group_byGroupAndGroup(terminationNeededFor, [GroupType.Terminator], \r\n            GroupType.TerminatedStatement, GroupType.Statement, GroupType.Terminator);\r\n\r\n        // preprocessor;\r\n        group_byGroupAndGroup([GroupType.PreprocessorStatement], [GroupType.Terminator], \r\n            GroupType.TerminatedPreprocessorStatement, GroupType.PreprocessorStatement, GroupType.Terminator);\r\n\r\n\r\n        // Declaration join\r\n        // if() {} else\r\n        // for (...) {}       \r\n        // for (...) var1=1;\r\n        group_declarations();\r\n\r\n        \r\n\r\n        // Function definition\r\n        // {FunctionCall} {Scope}    ->  funcName() { ... }\r\n        group_byGroupAndGroup([GroupType.FunctionCall], [GroupType.Scope], \r\n            GroupType.FunctionDefinition, GroupType.FunctionDeclaration, GroupType.FunctionScope);\r\n\r\n\r\n        group_the_rest(rootGroup);\r\n\r\n\r\n\r\n        solve_unsolved(rootGroup);\r\n\r\n\r\n\r\n        //console.log(this.debugGroupAsObject(tokens, rootGroup));\r\n        //console.warn(\"- finished -\");\r\n\r\n\r\n        return rootGroup;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Analyze the data structure tree and save it. Analyzed stuff:\r\n     *  - function definitions\r\n     *  - variable definitions\r\n     * @param rootGroup The root tree of data structure tree\r\n     * @returns Data containing info about functions, global and local variables, etc...\r\n     */\r\n    public static analyze(rootGroup: GscGroup, content: string): GscData {\r\n\r\n        var data = new GscData(rootGroup, content);\r\n\r\n        walkGroupItems(rootGroup, rootGroup.items);\r\n\r\n        function walkGroupItems(\r\n            parentGroup: GscGroup, \r\n            items: GscGroup[],\r\n            lastFunction: GscFunction | undefined = undefined) \r\n        {\r\n            for (var i = 0; i < items.length; i++) {\r\n                var innerGroup = items[i];\r\n\r\n                var func: GscFunction | undefined = undefined;\r\n\r\n                switch (innerGroup.type as GroupType) {\r\n\r\n                    // Save #include path\r\n                    case GroupType.Path:\r\n                        if (parentGroup.type === GroupType.PreprocessorStatement &&\r\n                            parentGroup.getFirstToken().name === \"#include\") \r\n                        {\r\n                            data.includes.push(innerGroup.getTokensAsString());\r\n                        }\r\n                        break;\r\n\r\n                    // Save functions\r\n                    case GroupType.FunctionDefinition:\r\n                        if (innerGroup.items.length === 2 && // declaration and scope\r\n                            innerGroup.items[0].type === GroupType.FunctionDeclaration &&\r\n                            innerGroup.items[0].items.length === 2 && // function name and parameters\r\n                            innerGroup.items[0].items[0].type === GroupType.FunctionName &&\r\n                            innerGroup.items[0].items[1].type === GroupType.FunctionParametersExpression &&\r\n                            innerGroup.items[1].type === GroupType.FunctionScope\r\n                        ) {\r\n                            const paramTokens: GscToken[] = [];\r\n                            for (let i = 0; i < innerGroup.items[0].items[1].items.length; i += 2) {\r\n                                const element = innerGroup.items[0].items[1].items[i];\r\n                                if (element.type === GroupType.FunctionParameterName) {\r\n                                    paramTokens.push(element.getSingleToken()!);\r\n                                }\r\n                            }\r\n                            func = {\r\n                                name: innerGroup.items[0].items[0].getSingleToken()!.name,\r\n                                parameters: paramTokens,\r\n                                localVariableDefinitions: [],\r\n                                range: innerGroup.getRange(),\r\n                                scopeRange: innerGroup.items[1].getRange()\r\n                            };\r\n\r\n\r\n                            data.functions.push(func);\r\n                        }                                 \r\n                        break;\r\n\r\n                    // Save variable definitions\r\n                    case GroupType.Statement:\r\n\r\n                        // varName = ...;    varNameStruct.aaa = ...;\r\n                        if (lastFunction !== undefined && innerGroup.items.length >= 2 &&\r\n                            innerGroup.items[0].type === GroupType.Reference &&\r\n                            innerGroup.items[0].items.length >= 1 &&\r\n                            innerGroup.items[1].type === GroupType.Token &&\r\n                            innerGroup.items[1].getFirstToken().type === TokenType.Assignment)  // =\r\n                        {\r\n                            const variableReference = innerGroup.items[0];\r\n                            const firstToken = variableReference.getFirstToken();\r\n\r\n                            if (firstToken.name === \"level\") {\r\n                                addDefinition(data.levelVariablesDefinitions, variableReference);\r\n                            } else if (firstToken.name === \"game\") {\r\n                                addDefinition(data.gameVariablesDefinitions, variableReference);\r\n                            } else {\r\n                                // Arrays does not have to be explicitly defined like 'aaa = [];', \r\n                                // Expression like 'aaa[0] = 1;' means that aaa is defined as array\r\n                                const otherReferences: GscGroup[] = [];\r\n                                var currentGroup = variableReference;\r\n                                while (currentGroup.items.at(1)?.type === GroupType.Array) {\r\n                                    otherReferences.unshift(currentGroup.items[0]);\r\n                                    currentGroup = currentGroup.items[0];\r\n                                }\r\n                                otherReferences.forEach(r => \r\n                                    addDefinition(lastFunction.localVariableDefinitions, r, GscVariableDefinitionType.Array)\r\n                                );                       \r\n                                addDefinition(lastFunction.localVariableDefinitions, variableReference);\r\n                            }\r\n\r\n                            function addDefinition(\r\n                                array: GscVariableDefinition[],\r\n                                variableReference: GscGroup,\r\n                                type: GscVariableDefinitionType = GscVariableDefinitionType.Unknown) \r\n                            {\r\n                                var variableDefinition: GscVariableDefinition = {\r\n                                    variableReference: variableReference,\r\n                                    type: type\r\n                                };\r\n\r\n                                array.push(variableDefinition);\r\n\r\n                                // If type is not resolved yet, determine it from assigned value\r\n                                if (type === GscVariableDefinitionType.Unknown) {\r\n                                    const valueGroup = innerGroup.items.at(2);\r\n        \r\n                                    switch (valueGroup?.type) {\r\n                                        case GroupType.Constant:\r\n                                            const token = valueGroup.getFirstToken();\r\n                                            switch (token.type) {\r\n                                                case TokenType.Array:\r\n                                                    variableDefinition.type = GscVariableDefinitionType.Array; break;\r\n                                                case TokenType.String:\r\n                                                    variableDefinition.type = GscVariableDefinitionType.String; break;\r\n                                                case TokenType.LocalizedString:\r\n                                                    variableDefinition.type = GscVariableDefinitionType.LocalizedString; break;\r\n                                                case TokenType.CvarString:\r\n                                                    variableDefinition.type = GscVariableDefinitionType.CvarString; break;  \r\n                                                case TokenType.Number:\r\n                                                    const isFloat = token.name.includes(\".\");\r\n                                                    variableDefinition.type = isFloat ? GscVariableDefinitionType.Float : GscVariableDefinitionType.Integer; break;\r\n\r\n                                                case TokenType.Keyword:\r\n                                                    switch (token.name) {\r\n                                                        case \"undefined\":\r\n                                                            variableDefinition.type = GscVariableDefinitionType.Undefined;\r\n                                                            break;\r\n                                                        case \"true\":\r\n                                                        case \"false\":\r\n                                                            variableDefinition.type = GscVariableDefinitionType.Bool;\r\n                                                            break;\r\n                                                    }\r\n                                                    break;                                         \r\n                                                // #animtree \r\n                                                case TokenType.Preprocessor:\r\n                                                    if (token.name === \"#animtree\") {\r\n                                                        variableDefinition.type = GscVariableDefinitionType.XAnim; \r\n                                                    }\r\n                                                    break;\r\n                                                // %anim_file_name\r\n                                                case TokenType.Operator:\r\n                                                    if (valueGroup.items.length === 2 && valueGroup.items[1].type === GroupType.XAnim) {\r\n                                                        variableDefinition.type = GscVariableDefinitionType.XAnim; \r\n                                                    }\r\n                                                    break;\r\n                                            }\r\n                                            break;\r\n        \r\n                                        case GroupType.FunctionPointer:\r\n                                        case GroupType.FunctionPointerExternal:\r\n                                            variableDefinition.type = GscVariableDefinitionType.Function;\r\n                                            break;\r\n    \r\n                                        case GroupType.Vector:\r\n                                            variableDefinition.type = GscVariableDefinitionType.Vector;\r\n                                            break;\r\n        \r\n                                        case GroupType.Value:\r\n                                            variableDefinition.type = GscVariableDefinitionType.UnknownValue;\r\n                                            break;\r\n        \r\n                                        case GroupType.Reference:\r\n                                            variableDefinition.type = GscVariableDefinitionType.UnknownValueFromVariable;\r\n                                            break;\r\n            \r\n                                        case GroupType.FunctionCall:\r\n                                            const funcName = valueGroup.items.at(0)?.getFirstToken();\r\n                                            if (funcName !== undefined) {\r\n                                                switch (funcName.name.toLowerCase()) {\r\n                                                    case \"spawnstruct\":\r\n                                                        variableDefinition.type = GscVariableDefinitionType.Structure;\r\n                                                        break;\r\n                                                    case \"spawn\":\r\n                                                        variableDefinition.type = GscVariableDefinitionType.Entity;\r\n                                                        break;\r\n                                                    case \"getdvar\":\r\n                                                        variableDefinition.type = GscVariableDefinitionType.String;\r\n                                                        break;\r\n                                                    default:\r\n                                                        variableDefinition.type = GscVariableDefinitionType.UnknownValueFromFunction;\r\n                                                        break;\r\n                                                }\r\n                                                \r\n                                            }\r\n                                            break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                        \r\n                        break;\r\n                }\r\n\r\n                walkGroupItems(innerGroup, innerGroup.items, func ?? lastFunction);\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n\r\n\r\n    public static debugGroupAsObject(tokens: GscToken[], currentGroup: GscGroup): debugObject {\r\n        \r\n        var type = \"\" + GroupType[currentGroup.type];     \r\n        if (currentGroup.tokenIndexEnd - currentGroup.tokenIndexStart <= 2) {\r\n            type += \"   (\" + tokens.slice(currentGroup.tokenIndexStart, currentGroup.tokenIndexEnd+1).map(f => TokenType[f.type]).join(\" \") + \")\";\r\n        }\r\n\r\n        var tkns = \"(\" + currentGroup.tokenIndexStart + \" - \" + currentGroup.tokenIndexEnd + \")  ->  \" + \r\n        tokens.slice(currentGroup.tokenIndexStart, currentGroup.tokenIndexEnd+1).map(f => f.name).join(\" \") + \"\";\r\n\r\n\r\n        var data: debugObject = {\r\n            a03_unsolved: (currentGroup.solved) ? undefined : \"!!! UNSOLVED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\",\r\n            a04_deadCode: (!currentGroup.deadCode) ? undefined : \"!!! DEADCODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\",\r\n            a01_type: type,\r\n            a02_tokens: tkns,\r\n            a06_itemsArray: []\r\n        };                        \r\n        \r\n        for (let item of currentGroup.items) {\r\n            const itemDebug = this.debugGroupAsObject(tokens, item);\r\n            data.a06_itemsArray.push(itemDebug);\r\n        }\r\n        \r\n        return data;\r\n    }\r\n\r\n\r\n    \r\n   \r\n    public static debugAsString(tokens: GscToken[], rootGroup: GscGroup, printChilds: boolean, startGroup: GscGroup | undefined = undefined): string {\r\n        var s: string[] = [];\r\n        function write(text: string) {\r\n            s.push(text);\r\n        }\r\n        function writeLine(text: string) {\r\n            write(text + \"\\n\");\r\n        }\r\n        \r\n        //writeLine(\"--------------------------------------------------------------\");\r\n        //writeLine(\"tokens: \" + tokens.length + \" [\" +  tokens.map(f => f.name).join(\" \") + \"]\");\r\n        //writeLine(\"--------------------------------------------------------------\");\r\n\r\n        write(this.debugGroupAsString(tokens, undefined, rootGroup, 0, printChilds, startGroup));\r\n\r\n        writeLine(\"--------------------------------------------------------------\");\r\n\r\n        return s.join(\"\");\r\n    }\r\n\r\n\r\n    public static debugGroupAsString(tokens: GscToken[], parentGroup: GscGroup | undefined, currentGroup: GscGroup, level: number, printChilds: boolean, startGroup: GscGroup | undefined = undefined): string {\r\n        var s: string[] = [];\r\n        var startGroupFound: boolean = false;\r\n\r\n        function write(text: string) {\r\n            s.push(text);\r\n        }\r\n        function writeLine(text: string) {\r\n            write(text + \"\\n\");\r\n        }\r\n        \r\n        //var spaces1 = \".    \".repeat((level+1)/2);\r\n        //var spaces2 = \".    \".repeat((level+1)/2) + \".  \";\r\n\r\n        var spaces1 = \".  \".repeat((level+1)/2);\r\n        var spaces2 = \".  \".repeat((level+1)/2) + \". \";\r\n\r\n        if (startGroup !== undefined && startGroupFound === false) {\r\n            writeLine(spaces1 + GroupType[currentGroup.type] + \" (\"+currentGroup.tokenIndexStart + \" - \" + currentGroup.tokenIndexEnd + \"):\");\r\n        }\r\n\r\n        if (startGroup !== undefined && currentGroup !== startGroup) {\r\n            for (let item of currentGroup.items) {\r\n                write(this.debugGroupAsString(tokens, currentGroup, item, level + 2, printChilds, startGroup));\r\n            }\r\n            return s.join(\"\");\r\n        } else if (currentGroup === startGroup) {\r\n            startGroupFound = true;\r\n        }\r\n\r\n        //var spaces2 = new Array((level+1) * 2 + 1).join(' ');\r\n        writeLine(spaces1 + \"{\");\r\n       \r\n        // writeLine(spaces2 + \"solved: \" + currentGroup.solved);\r\n        if (!currentGroup.solved) {\r\n            writeLine(spaces2 + \"!!! UNSOLVED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n        }\r\n\r\n        // writeLine(spaces2 + \"deadCode: \" + currentGroup.deadCode);\r\n        if (currentGroup.deadCode) {\r\n            writeLine(spaces2 + \"!!! DEADCODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n        }\r\n\r\n        if (currentGroup.parent !== parentGroup) {\r\n            writeLine(spaces2 + \"!!! PARENT MISMATCH !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n        }\r\n\r\n        write(spaces2 + \"type: \" + GroupType[currentGroup.type]);\r\n        if (currentGroup.tokenIndexEnd - currentGroup.tokenIndexStart <= 3) {\r\n            write(\"   (\" + \r\n                tokens.slice(currentGroup.tokenIndexStart, currentGroup.tokenIndexEnd+1).map(f => TokenType[f.type]).join(\" \") + \")\");\r\n        }\r\n        writeLine(\"\");\r\n\r\n        writeLine(spaces2 + \"tokens: \" + \r\n                            \"(\"+currentGroup.tokenIndexStart + \" - \" + currentGroup.tokenIndexEnd + \")  ->  \" + \r\n                            tokens.slice(currentGroup.tokenIndexStart, currentGroup.tokenIndexEnd+1).map(f => f.name).join(\" \") + \"\");\r\n        \r\n\r\n        if (currentGroup.tokenIndexStart >= 0 && currentGroup.tokenIndexEnd >= 0 ) {\r\n            writeLine(spaces2 + \"range: (\" + \r\n            \"L:\" + tokens[currentGroup.tokenIndexStart].range.start.line + \" \" +\r\n            \"C:\" + tokens[currentGroup.tokenIndexStart].range.start.character + \"\" +\r\n            \" - \" +\r\n            \"L:\" + tokens[currentGroup.tokenIndexEnd].range.end.line + \" \" +\r\n            \"C:\" + tokens[currentGroup.tokenIndexEnd].range.end.character + \")\");\r\n        }\r\n\r\n \r\n        \r\n\r\n                            \r\n        \r\n        if (currentGroup.items.length > 0) {\r\n            writeLine(spaces2 + \"items: (\" + currentGroup.items.length + \")\");\r\n            if (printChilds) {\r\n                writeLine(spaces2 + \"[\");\r\n                for (let item of currentGroup.items) {\r\n                    write(this.debugGroupAsString(tokens, currentGroup, item, level + 2, printChilds, startGroup));\r\n                }\r\n                writeLine(spaces2 + \"]\");\r\n            }\r\n        }\r\n        writeLine(spaces1 + \"},\");\r\n\r\n        return s.join(\"\");\r\n    }\r\n\r\n\r\n\r\n    public static generateTestChecks(tokens: GscToken[], rootGroup: GscGroup): string {\r\n\r\n        var s: string[] = [];\r\n\r\n        walkGroup(rootGroup, \"checkGroup2(rootGroup, rootGroup\");\r\n\r\n        function walkGroup(currentGroup: GscGroup, prefix: string) {\r\n            s.push(prefix);\r\n            s.push(\", \");\r\n            s.push(\"GroupType.\");\r\n            s.push(GroupType[currentGroup.type]);\r\n            s.push(\", \");\r\n            s.push(currentGroup.tokenIndexStart.toString());\r\n            s.push(\", \");\r\n            s.push(currentGroup.tokenIndexEnd.toString());\r\n            s.push(\", \");\r\n            s.push(currentGroup.solved ? \"true\" : \"false\");\r\n            s.push(\", \");\r\n            s.push(currentGroup.items.length.toString());/*\r\n            s.push(\", \");\r\n            s.push(currentGroup.deadCode ? \"true\" : \"false\");*/\r\n            s.push(\");\\n\");\r\n            \r\n            for (var i = 0; i < currentGroup.items.length; i++) {\r\n                walkGroup(currentGroup.items[i], prefix + \".items[\" + i + \"]\");\r\n            }\r\n        }\r\n        return s.join(\"\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport interface GscToken {\r\n    index: number;\r\n    name: string;\r\n    type: TokenType;\r\n    offset: number;\r\n    range: vscode.Range;\r\n    commentBefore?: string;\r\n}\r\n\r\nexport enum TokenType {\r\n    Unknown,\r\n    DeveloperStart,\r\n    DeveloperEnd,\r\n    Preprocessor,\r\n    /** Char '{' */\r\n    ScopeStart,\r\n    /** Char '}' */\r\n    ScopeEnd,\r\n    /** Char '(' */\r\n    ExpressionStart,\r\n    /** Char ')' */\r\n    ExpressionEnd,\r\n    /** Char '[' */\r\n    ArrayStart,\r\n    /** Char ']' */\r\n    ArrayEnd,\r\n\r\n    /** Char '.' */\r\n    Structure,\r\n    /** Char '\\\\' */\r\n    PathSeparator,\r\n    /** Chars '::' */\r\n    FunctionPointer,\r\n    /** Char ',' */\r\n    ParameterSeparator,\r\n    /** Char ':' */\r\n    Case,\r\n\r\n    /** Char '=' */\r\n    Assignment,\r\n    /** Char '+=', '-=', '*=', '/=', '%=', '|=', '&=', '^=' */\r\n    Assignment2,\r\n    /** Right-sided operators - chars '++', '--' */\r\n    Assignment3,\r\n\r\n    /** 2-sided operators - chars ('+', '-','*', '/', '%'),   ('|', '&', '^', '<<', '>>')   ('==', '!=', '<', '>', '<=', '>=', '&&', '||')   */\r\n    Operator,\r\n    /** Left-sided operator - char '!', '~' */\r\n    OperatorLeft,\r\n\r\n    /** Char ';' */\r\n    Semicolon,\r\n\r\n    String,\r\n    /** Like &\"STRING_ABC\" */\r\n    LocalizedString,\r\n    /** Like #\"sv_running\" - only for COD:BO1 */\r\n    CvarString,\r\n\r\n    Number,\r\n    /** Char '[]' */\r\n    Array,\r\n    Keyword,\r\n\r\n    /* Char # */\r\n    Hashtag\r\n}\r\n\r\nenum Level {\r\n    Default,\r\n    SingleLineComment,\r\n    MultiLineComment,\r\n    PreprocessorName,\r\n    String,\r\n    LocalizedString,\r\n    CvarString,\r\n    Number,\r\n    Float,\r\n    Keyword\r\n}\r\n\r\n\r\n\r\n\r\nexport class GscGroup {\r\n    //public readonly debug: string;\r\n    public parent: GscGroup | undefined;\r\n    public items: GscGroup[] = [];\r\n    public type: GroupType;\r\n    public tokenIndexStart: number;\r\n    public tokenIndexEnd: number;\r\n    public solved: boolean = false;\r\n    public deadCode: boolean = false;\r\n\r\n    public readonly tokensAll: GscToken[];\r\n\r\n    constructor({parent, type, tokenIndexStart, tokenIndexEnd}: {parent: GscGroup | undefined, type: GroupType, tokenIndexStart: number, tokenIndexEnd: number},\r\n                tokens: GscToken[]) {\r\n        this.parent = parent;\r\n        this.type = type;\r\n        this.tokenIndexStart = tokenIndexStart;\r\n        this.tokenIndexEnd = tokenIndexEnd;\r\n        this.tokensAll = tokens;\r\n        //this.debug = this.toString();\r\n    }\r\n\r\n    public getSingleToken(): GscToken | undefined {\r\n        if (this.tokenIndexStart === this.tokenIndexEnd && this.items.length === 0) {\r\n            return this.tokensAll[this.tokenIndexStart];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    public getUnknownToken(): GscToken | undefined {\r\n        if (this.tokenIndexStart === this.tokenIndexEnd && this.items.length === 0 && this.type === GroupType.Unknown) {\r\n            return this.tokensAll[this.tokenIndexStart];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    public getFirstToken(): GscToken {\r\n        return this.tokensAll[this.tokenIndexStart];\r\n    }\r\n\r\n    public getTypeOfUnknownToken(): TokenType | undefined {\r\n        return this.getUnknownToken()?.type;\r\n    }\r\n\r\n    public getSingleTokenType(): TokenType | undefined {\r\n        return this.getSingleToken()?.type;\r\n    }\r\n\r\n    public isUnknownUnsolvedSingleTokenOfOneOfType(...type: TokenType[]): boolean {\r\n        if (this.tokenIndexStart === this.tokenIndexEnd && this.items.length === 0 && this.type === GroupType.Unknown && this.solved === false) {\r\n            return type.includes(this.tokensAll[this.tokenIndexStart].type);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public isUnsolvedSingleTokenOfOneOfType(...type: TokenType[]): boolean {\r\n        if (this.tokenIndexStart === this.tokenIndexEnd && this.items.length === 0 && this.solved === false) {\r\n            return type.includes(this.tokensAll[this.tokenIndexStart].type);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public isUnsolvedGroupOfOneOfType(...type: GroupType[]): boolean {\r\n        if (this.solved === false) {\r\n            return type.includes(this.type);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public isReservedKeywordOfName(...names: string[]): boolean {\r\n        if (this.type === GroupType.ReservedKeyword) {\r\n            const name = this.getSingleToken()?.name;\r\n            if (name === undefined) { return false; }\r\n            return names.includes(name);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public typeEqualsToOneOf(...groups: GroupType[]) {\r\n        if (this.type === undefined) { return false; }\r\n        return groups.includes(this.type);\r\n    }\r\n\r\n    public getRange(): vscode.Range {\r\n        return new vscode.Range(this.tokensAll[this.tokenIndexStart].range.start, this.tokensAll[this.tokenIndexEnd].range.end);\r\n    }\r\n\r\n\r\n    public getIndex(): number | undefined {\r\n        if (this.parent === undefined) {\r\n            return undefined;\r\n        }\r\n        var index = this.parent.items.indexOf(this);\r\n        if (index === -1) {\r\n            return undefined;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    public findLastParentInSequenceOfType(type: GroupType): GscGroup | undefined {\r\n        var group = this as GscGroup;\r\n        while (group.parent?.type === type) {\r\n            group = group.parent;\r\n        }\r\n        if (group.type === type) {\r\n            return group;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n\r\n    public findParentOfType(...type: GroupType[]): GscGroup | undefined {\r\n        var group: GscGroup | undefined = this as GscGroup;\r\n        while (group?.parent !== undefined && !type.includes(group?.parent.type)) {\r\n            group = group.parent;\r\n        }\r\n        if (group?.parent !== undefined && type.includes(group?.parent.type)) {\r\n            return group?.parent;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n\r\n    public unwrapType(type: GroupType): GscGroup {\r\n        var group = this as GscGroup;\r\n        while (group.type === type && group.items.length === 1) {\r\n            group = group.items[0];\r\n        }\r\n        return group;\r\n    }\r\n\r\n\r\n    public findGroupOnLeftAtPosition(position: vscode.Position, lastGroup: GscGroup | undefined = undefined, level: number = 0): GscGroup | undefined {\r\n\r\n        // Create an array of ranges and related group\r\n        const items = this.items.map(t => { \r\n            return {\r\n                range: t.getRange(),\r\n                group: t,\r\n                isTrueGroup: true\r\n            };\r\n        } );\r\n\r\n        // If last child node does not end with with the same token as the parent, add it into array\r\n        // Scopes like {} [] () does not have their tokens defined\r\n        const lastChildGroup = this.items.at(-1);\r\n        if (lastChildGroup !== undefined) {\r\n            for (var i = lastChildGroup.tokenIndexEnd + 1; i <= this.tokenIndexEnd; i++) {\r\n                items.push({\r\n                    range: this.tokensAll[i].range, \r\n                    group: this,\r\n                    isTrueGroup: false\r\n                });\r\n            }\r\n        }\r\n\r\n        for (var data of items) {\r\n            const range = data.range;\r\n\r\n            if (range.end.isBeforeOrEqual(position) && \r\n               (lastGroup === undefined || (range.start.isAfterOrEqual(lastGroup.getRange().start)))) {\r\n                lastGroup = data.group;\r\n            }\r\n\r\n            //if (range.contains(position)) {\r\n            if (((position.line === range.start.line && position.character > range.start.character) || position.line > range.start.line) && \r\n                ((position.line === range.end.line && position.character <= range.end.character) || position.line < range.end.line)\r\n                && data.isTrueGroup) \r\n            {\r\n                lastGroup = data.group;\r\n                lastGroup = data.group.findGroupOnLeftAtPosition(position, lastGroup, level + 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (lastGroup !== undefined && level === 0) {\r\n            lastGroup = lastGroup.findGroupOnLeftAtPosition(position, lastGroup, level + 1);\r\n        }\r\n\r\n        return lastGroup; \r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Select variable tokens like 'level.aaa.bbb' from document\r\n     * Needs to find boundaries of variable, for example: (| indicates cursor pos)\r\n     * \r\n     *      ...; abcd|         => abcd\r\n     *      abcd[abcd[0]|]     => abcd[0]\r\n     * \r\n     * @param position \r\n     * @returns \r\n     */\r\n    public getVariableStringBeforePosition(position: vscode.Position): string {\r\n        const groupAtCursor = this as GscGroup;\r\n\r\n        const tokens = groupAtCursor.tokensAll;\r\n\r\n        // Select variable tokens like 'level.aaa.bbb' from document\r\n        // Needs to find boundaries of variable, for example: (| indicates cursor pos)\r\n        //   ...; abcd|         => abcd\r\n        //   abcd[abcd[0]|]     => abcd[0]\r\n        var variableBeforeCursor = \"\";\r\n\r\n        // Find parent of scope or array\r\n        var scopeOfCursorGroup = groupAtCursor;\r\n        if (!groupAtCursor.typeEqualsToOneOf(...GscFileParser.scopeTypes)) {\r\n            scopeOfCursorGroup = groupAtCursor.findParentOfType(...GscFileParser.scopeTypes, GroupType.Array) ?? groupAtCursor;\r\n        }\r\n\r\n        // Loop tokens\r\n        for (var i = groupAtCursor.tokenIndexEnd; i >= 0; i--) {\r\n            const token = tokens[i];\r\n\r\n            if (token.range.end.isAfter(position)) {\r\n                continue;\r\n            }\r\n\r\n            const variableTokens = [TokenType.Keyword, TokenType.Structure, TokenType.ArrayStart, TokenType.ArrayEnd, TokenType.Array, TokenType.Number, \r\n                TokenType.String, TokenType.LocalizedString, TokenType.CvarString];\r\n            if (!variableTokens.includes(token.type) || i === scopeOfCursorGroup.tokenIndexStart) {\r\n                const startIndex = i + 1;\r\n                \r\n                // Now go to right until cursor pos is reached\r\n                for (i = startIndex; i <= groupAtCursor.tokenIndexEnd; i++) {\r\n                    const token = tokens[i];\r\n                    var tokenName = \"\";\r\n\r\n                    if (token.range.contains(position)) {\r\n                        const endIndex = token.name.length - (token.range.end.character - position.character);\r\n                        tokenName = token.name.substring(0, endIndex);\r\n                    } else if (token.range.start.isBefore(position)) {\r\n                        tokenName = token.name;\r\n                    }\r\n                    // If token does not start with word character, exit, because its not variable start\r\n                    if (variableBeforeCursor === \"\" && !/^[a-zA-Z_]/.test(tokenName[0])) {\r\n                        break;\r\n                    }\r\n                    variableBeforeCursor += tokenName;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return variableBeforeCursor;\r\n    }\r\n\r\n\r\n    /**\r\n     * Create array of variable parts where structure fields and array accessors are considered as part.\r\n     * For example:\r\n     * \r\n     *      struct1.field1      => [\"struct1\", \".field\"]\r\n     *      array1[0].field1    => [\"array1\", \"[0]\", \".field1\"]\r\n     *      array1[1][0]        => [\"array1\", \"[1]\", \"[0]\"]\r\n     * \r\n     * @returns Array of parts\r\n     */\r\n    public getVariableParts(): {text: string, implicitType: GscVariableDefinitionType, kind: vscode.CompletionItemKind}[] {\r\n\r\n        const variableParts: {text: string, implicitType: GscVariableDefinitionType, kind: vscode.CompletionItemKind}[] = [];\r\n\r\n        loopVariableReference(this);\r\n\r\n\r\n        function loopVariableReference(group: GscGroup): boolean {\r\n            for (var i = 0; i < group.items.length; i++) {\r\n                const innerGroup = group.items[i];        \r\n                const prevPart = variableParts.at(-1);\r\n    \r\n                switch (innerGroup.type) {\r\n                \r\n                    case GroupType.VariableName:\r\n                        variableParts.push({\r\n                            text: innerGroup.getFirstToken().name,\r\n                            implicitType: GscVariableDefinitionType.Unknown,\r\n                            kind: vscode.CompletionItemKind.Variable\r\n                        });\r\n                        break;\r\n    \r\n                    case GroupType.Array:\r\n    \r\n                        // Previous part is of array type\r\n                        if (prevPart !== undefined) {\r\n                            prevPart.implicitType = GscVariableDefinitionType.Array;\r\n                        }\r\n    \r\n                        // Make sure arrays with non-constant values (eg game[1+1]) are ignored\r\n                        if (innerGroup.items.at(0)?.type !== GroupType.Constant) {\r\n                            variableParts.push({\r\n                                text: \"[]\",\r\n                                implicitType: GscVariableDefinitionType.Unknown,\r\n                                kind: vscode.CompletionItemKind.Variable\r\n                            });\r\n                            continue;\r\n                        } else {\r\n                            variableParts.push({\r\n                                text: \"[\" + innerGroup.items[0].getFirstToken().name + \"]\",\r\n                                implicitType: GscVariableDefinitionType.Unknown,\r\n                                kind: vscode.CompletionItemKind.Variable\r\n                            });\r\n                        }\r\n                    break;\r\n    \r\n                    case GroupType.Token: // .\r\n    \r\n                        // Previous part is of structure type\r\n                        if (prevPart !== undefined) {\r\n                            prevPart.implicitType = GscVariableDefinitionType.Structure;\r\n                        }\r\n    \r\n                        const field = group.items.at(i + 1);\r\n                        if (field?.type === GroupType.StructureField) {\r\n                            variableParts.push({\r\n                                text: innerGroup.getFirstToken().name + field.getFirstToken().name,\r\n                                implicitType: GscVariableDefinitionType.Unknown,\r\n                                kind: vscode.CompletionItemKind.Field\r\n                            });\r\n                            i++;\r\n                            continue;\r\n                        } else {\r\n                            variableParts.push({\r\n                                text: innerGroup.getFirstToken().name,\r\n                                implicitType: GscVariableDefinitionType.Unknown,\r\n                                kind: vscode.CompletionItemKind.Field\r\n                            });\r\n                        }\r\n                        break;\r\n    \r\n                    case GroupType.Reference:\r\n                        const mayContinue = loopVariableReference(innerGroup);\r\n                        if (mayContinue === false) {\r\n                            return false;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n    \r\n            // Continue\r\n            return true;\r\n        }\r\n\r\n        return variableParts;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Get path\r\n     * @param position \r\n     * @returns \r\n     */\r\n    public getPathStringBeforePosition(position: vscode.Position): string {\r\n        const groupAtCursor = this as GscGroup;\r\n\r\n        if (groupAtCursor.type !== GroupType.Path) {\r\n            return \"\";\r\n        }\r\n\r\n        const tokens = groupAtCursor.tokensAll;\r\n        var stringBeforeCursor = \"\";\r\n\r\n        // Loop tokens\r\n        for (var i = groupAtCursor.tokenIndexStart; i <= groupAtCursor.tokenIndexEnd; i++) {\r\n            const token = tokens[i];\r\n            if (token.range.contains(position)) {\r\n                const endIndex = token.name.length - (token.range.end.character - position.character);\r\n                stringBeforeCursor += token.name.substring(0, endIndex);\r\n            } else if (token.range.start.isBefore(position)) {\r\n                stringBeforeCursor += token.name;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return stringBeforeCursor;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets function name and path. The group must be of type {@linkcode GroupType.FunctionName}.\r\n     * @example\r\n     *  funcName()                          => {name: \"funcName\", path: \"\"}\r\n     *  maps\\mp\\gametypes\\file::funcName()  => {name: \"funcName\", path: \"maps\\mp\\gametypes\\file\"}\r\n     * @returns \r\n     */\r\n    public getFunctionNameAndPath(): {name: string, path: string} | undefined {\r\n        const locations: vscode.Location[] = [];\r\n        const group = this as GscGroup;\r\n        if (group.type !== GroupType.FunctionName) {\r\n            return undefined;\r\n        }\r\n\r\n        const funcName = group.getFirstToken().name;\r\n        var path = \"\";\r\n\r\n        // Its external function call\r\n        if (((group.parent?.type === GroupType.FunctionCall && group.parent?.parent?.type === GroupType.FunctionCall) ||\r\n              group.parent?.type === GroupType.FunctionPointer && group.parent?.parent?.type === GroupType.FunctionPointerExternal) &&\r\n            group.parent.parent.items[0].type === GroupType.Path) \r\n        {\r\n            path = group.parent.parent.items[0].getTokensAsString();\r\n        }\r\n        \r\n        return {name: funcName, path: path};\r\n    }\r\n\r\n\r\n\r\n\r\n    public getTokensBeforePosition(position: vscode.Position) {\r\n        return this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1).filter(f => position.isAfterOrEqual(f.range.end));\r\n    }\r\n\r\n    public getTokens() {\r\n        return this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1);\r\n    }\r\n\r\n    public getTokensAsString() {\r\n        return this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1).map(f => f.name).join(\"\");\r\n    }\r\n\r\n    public printTokens() {\r\n        return this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1).map(f => f.name).join(\" \");\r\n    }\r\n\r\n    public toString = () : string => {\r\n        return `{type: ${GroupType[this.type]}, tokens: ${this.tokenIndexStart} - ${this.tokenIndexEnd}, ${this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1).map((t) => t.name).join(\" \")}}`;\r\n    };\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport class GscData {\r\n    root: GscGroup;\r\n    functions: GscFunction[] = [];\r\n    levelVariablesDefinitions: GscVariableDefinition[] = [];\r\n    gameVariablesDefinitions: GscVariableDefinition[] = [];\r\n    includes: string[] = [];\r\n    content: string;\r\n\r\n    constructor(structure: GscGroup, content: string) {\r\n        this.root = structure;\r\n        this.content = content;\r\n    }\r\n}\r\n\r\n\r\n\r\ntype GscFunction = {\r\n    name: string;\r\n    parameters: GscToken[];\r\n    /** Local variable declarations like \"a = 1;\". Its always statement with item[0] as Reference */\r\n    localVariableDefinitions: GscVariableDefinition[];\r\n    range: vscode.Range;\r\n    scopeRange: vscode.Range;\r\n};\r\n\r\nexport type GscVariableDefinition = {\r\n    variableReference: GscGroup,\r\n    type: GscVariableDefinitionType\r\n};\r\n\r\n\r\n\r\n\r\nexport enum KeywordType {\r\n    Keyword,\r\n    Variable,\r\n    Constant,\r\n    Function,\r\n    Parameter,\r\n    Path\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport enum GscVariableDefinitionType {\r\n    Unknown,\r\n    Undefined,\r\n    Object,\r\n    String,\r\n    LocalizedString,\r\n    CvarString,\r\n    Vector,\r\n    Integer,\r\n    Float,\r\n    Structure,\r\n    Array,\r\n    Function,\r\n    Entity,\r\n    Bool,\r\n    XAnim,\r\n    UnknownValue,\r\n    UnknownValueFromVariable,\r\n    UnknownValueFromFunction\r\n}\r\n\r\n\r\n\r\n\r\ntype debugObject = {\r\n    a01_type: string,\r\n    a02_tokens: string,\r\n    a03_unsolved: string | undefined,\r\n    a04_deadCode: string | undefined,\r\n    a06_itemsArray: debugObject[]\r\n};\r\n\r\n\r\n","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscData } from './GscFileParser';\r\n\r\nexport class GscHoverProvider implements vscode.HoverProvider {\r\n    \r\n    static async activate(context: vscode.ExtensionContext) {       \r\n        context.subscriptions.push(vscode.languages.registerHoverProvider('gsc', new GscHoverProvider()));\r\n    }\r\n\r\n    public async provideHover(\r\n        document: vscode.TextDocument,\r\n        position: vscode.Position,\r\n        token: vscode.CancellationToken\r\n    ): Promise<vscode.Hover | undefined> \r\n    {\r\n        // Get parsed file\r\n        const gscData = await GscFile.getFile(document.uri);\r\n\r\n        const hover = await this.getHover(gscData, position, document.uri);\r\n\r\n        return hover;\r\n    }\r\n\r\n    public async getHover(gscData: GscData, position: vscode.Position, uri: vscode.Uri): Promise<vscode.Hover> {\r\n        let hoverText = new vscode.MarkdownString();\r\n\r\n        // Get group before cursor\r\n        var groupAtCursor = gscData.root.findGroupOnLeftAtPosition(position);\r\n\r\n        if (groupAtCursor?.type === GroupType.FunctionName) {\r\n            const funcNameAndPath = groupAtCursor.getFunctionNameAndPath();\r\n            if (funcNameAndPath !== undefined) {\r\n\r\n                // Get file URI and position where the file is defined\r\n                const definitions = await GscFile.getFunctionNameDefinitions(funcNameAndPath.name, funcNameAndPath.path, uri);\r\n\r\n                definitions.forEach(async d => {\r\n\r\n                    const gscData = await GscFile.getFile(d.uri);\r\n\r\n                    const functionData = gscData.functions.find(f => f.name === funcNameAndPath.name);\r\n\r\n                    if (functionData === undefined) { return; }\r\n\r\n                    const parametersText = functionData.parameters.map(p => p.name).join(\", \");\r\n\r\n                    hoverText.appendText(vscode.workspace.asRelativePath(d.uri));\r\n                    hoverText.appendMarkdown(\"\\n\\n\"); // Two newlines for a new paragraph, for more space you could use \"\\n\\n---\\n\\n\" for a horizontal rule\r\n                    hoverText.appendMarkdown(`**${funcNameAndPath.name}**(${parametersText})`);\r\n                });\r\n            }\r\n        }\r\n\r\n        \r\n\r\n\r\n        return new vscode.Hover(hoverText);\r\n    }\r\n}","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscGroup} from './GscFileParser';\r\n\r\n\r\nexport class GscSemanticTokensProvider implements vscode.DocumentSemanticTokensProvider {\r\n\t\r\n    //https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#standard-token-types-and-modifiers\r\n    public static tokenTypes = [\r\n        'namespace',    // (blue-green) For identifiers that declare or reference a namespace, module, or package.\r\n        'class',        // (blue-green) For identifiers that declare or reference a class type.\r\n        'keyword',      // (purple) For tokens that represent a language keyword.\r\n        'function',     // (yellow) For identifiers that declare a function.\r\n        'parameter',    // (light-blue) For identifiers that declare or reference a function or method parameters.\r\n        'variable',     // (light-blue) For identifiers that declare or reference a local or global variable.\r\n        'property',     // (light-blue) For identifiers that declare or reference a member property, member field, or member variable.\r\n        'enumMember',   // (dark blue) For identifiers that declare or reference an enumeration property, constant, or member.\r\n        'event',        // (light-blue)\r\n        'method',       // (yellow)\r\n        'macro',        // (dark dark blue)\r\n        'label',        // (white)\r\n        'string'        // (orange) For tokens that represent a string literal.\r\n    ];  \r\n    public static tokenModifiers = [\r\n        'declaration',      // For declarations of symbols.\r\n        'static',           // For class members (static members).\r\n        'readonly',         // For readonly variables and member fields (constants).\r\n        'modification',\t    // For variable references where the variable is assigned to.\r\n        'defaultLibrary'    // For symbols that are part of the standard library.\r\n    ];\r\n    \r\n    public static legend = new vscode.SemanticTokensLegend(this.tokenTypes, this.tokenModifiers);\r\n    \r\n\r\n    static async activate(context: vscode.ExtensionContext) {\r\n        \r\n        context.subscriptions.push(vscode.languages.registerDocumentSemanticTokensProvider({ language: 'gsc' }, new GscSemanticTokensProvider(), GscSemanticTokensProvider.legend));\r\n    }\r\n\r\n\r\n\r\n    async provideDocumentSemanticTokens(\r\n\t  document: vscode.TextDocument\r\n\t): Promise<vscode.SemanticTokens | undefined> {\r\n\t  // analyze the document and return semantic tokens\r\n\r\n\t\tconst builder = new vscode.SemanticTokensBuilder(GscSemanticTokensProvider.legend);\r\n\r\n\t\t//vscode.window.showWarningMessage(\"SemanticTokensBuilder\");\r\n\r\n   \r\n        var gsc = await GscFile.parseAndCacheFile(document.uri);\r\n\r\n        \r\n        function walkGroupItems(parentGroup: GscGroup, items: GscGroup[], action: (parentGroup: GscGroup, group: GscGroup) => void) {\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < items.length; i++) {\r\n                var innerGroup = items[i];\r\n                walkGroupItems(innerGroup, innerGroup.items, action);\r\n                action(parentGroup, innerGroup);\r\n            }\r\n        }\r\n\r\n\r\n        walkGroupItems(gsc.root, gsc.root.items, (parentGroup, group) => {\r\n\r\n            /*          \r\n                'class',        // (blue-green) For identifiers that declare or reference a class type.\r\n                'keyword',      // (purple) For tokens that represent a language keyword.\r\n                'function',     // (yellow) For identifiers that declare a function.\r\n                'parameter',    // (light-blue) For identifiers that declare or reference a function or method parameters.\r\n                'variable',     // (light-blue, dark-blue with readonly) For identifiers that declare or reference a local or global variable.\r\n                'property',     // (light-blue, dark-blue with readonly) For identifiers that declare or reference a member property, member field, or member variable.\r\n                'enumMember',   // (dark blue) For identifiers that declare or reference an enumeration property, constant, or member.\r\n                'event',        // (light-blue)\r\n                'method',       // (yellow)\r\n                'macro',        // (dark dark blue)\r\n                'label',        // (white)\r\n                'string'        // (orange) For tokens that represent a string literal.\r\n            */     \r\n\r\n            if (group.type === GroupType.Path) {\r\n                builder.push(\r\n                    group.getRange(),\r\n                    'namespace',\r\n                    ['declaration']\r\n                );\r\n            }\r\n            else if (group.type === GroupType.FunctionName) {\r\n                builder.push(\r\n                    group.getRange(),\r\n                    'function',\r\n                    ['declaration']\r\n                );\r\n            }\r\n            else if (group.type === GroupType.VariableName) {\r\n                var token = group.getSingleToken();\r\n                if (token !== undefined && (token.name === \"level\" || token.name === \"game\" || token.name === \"self\")) {\r\n                    builder.push(\r\n                        group.getRange(),\r\n                        'variable',\r\n                        ['readonly']\r\n                    );\r\n                } else {\r\n                    builder.push(\r\n                        group.getRange(),\r\n                        'variable',\r\n                        ['declaration']\r\n                    );\r\n                }\r\n            }\r\n\r\n            else if (group.type === GroupType.StructureField) {\r\n                builder.push(\r\n                    group.getRange(),\r\n                    'variable',\r\n                    ['declaration']\r\n                );            \r\n            }\r\n            else if (group.type === GroupType.ReservedKeyword) {\r\n                builder.push(\r\n                    group.getRange(),\r\n                    'keyword',\r\n                    ['declaration']\r\n                );\r\n            }\r\n        });\r\n\r\n        //vscode.window.showInformationMessage(\"SemanticTokensBuilder done\");\r\n        \t\r\n\t\treturn builder.build();\r\n\t}\r\n};","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport { Gsc } from './Gsc';\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n\n\tconsole.log(\" \");\n\tconsole.log(\"- GSC extension ----------------------------------------------------------------------------\");\n\tconsole.log(\" \");\n\n\tGsc.activate(context);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}"],"names":["activate","context","GscFile","GscDiagnosticsCollection","GscSemanticTokensProvider","GscCompletionItemProvider","GscDefinitionProvider","GscHoverProvider","subscriptions","push","vscode","languages","registerCompletionItemProvider","provideCompletionItems","document","position","token","gscData","parseAndCacheFile","uri","getCompletionItems","onlyVariables","completionItems","startTime","performance","now","groupAtCursor","root","findGroupOnLeftAtPosition","undefined","parent","functionGroup","functions","find","f","range","scopeRange","line","start","character","end","type","GroupType","Path","this","createVariableItems","localVariableDefinitions","createPathItems","duration","console","log","variableItems","variableBeforeCursor","getVariableStringBeforePosition","inVariableName","typeEqualsToOneOf","VariableName","Identifier","inStructureVariable","StructureField","getFirstToken","name","inArrayBrackets","Array","getRange","at","nonWordChars","match","lastNonWordIndexInCursorVar","lastIndexOf","length","getCompletionItemFromVariableDefinition","g","variableParts","variableReference","getVariableParts","varName","GscVariableDefinitionType","Unknown","kind","CompletionItemKind","Variable","labelName","i","part","isLast","text","implicitType","startsWith","substring","endsWith","Value","getTokensAsString","existingItem","p","types","add","detail","Set","Structure","forEach","getCachedFiles","levelVariablesDefinitions","gameVariablesDefinitions","CompletionItem","label","description","getItemDescriptionFromTypes","Constant","Keyword","pathBeforeCursor","getPathStringBeforePosition","fileSubPath","lastPathIndex","replace","files","workspace","findFiles","keywords","file","relativePath","asRelativePath","path","subpathIndex","indexOf","subpathKeyword","slashIndex","folderName","some","k","Folder","exec","toLowerCase","fileName","File","unknownValueTypes","UnknownValue","UnknownValueFromFunction","UnknownValueFromVariable","typesString","filter","t","includes","map","str","join","registerDefinitionProvider","provideDefinition","getFile","getFunctionDefinitionLocations","documentUri","locations","FunctionName","funcData","getFunctionNameAndPath","getFunctionNameDefinitions","static","diagnosticCollection","createDiagnosticCollection","onDidParseDocument","updateDiagnostics","onDidDeleteDocument","deleteDiagnostics","diagnostics","walkGroupItems","parentGroup","items","innerGroup","nextGroup","diagnostic","action","group","Diagnostic","DiagnosticSeverity","Error","solved","Statement","TerminatedStatement","Expression","ForExpression","firstToken","getSingleToken","toString","ExtraTerminator","Information","set","delete","createDiagnosticsForAll","clear","gsc","Uri","parse","Map","EventEmitter","parseAllFiles","onDidCreateFiles","onCreateFiles","onDidDeleteFiles","onDeleteFiles","onDidRenameFiles","onRenameFiles","commands","registerCommand","async","window","activeTextEditor","debugParsedFile","GscFileParser","debugAsString","tokensAll","_onDidParseDocument","event","_onDidDeleteDocument","e","removeCachedFile","oldUri","newUri","parseAndCacheAllFiles","elapsed","parsedFiles","size","fileUri","parseFile","fire","get","openedTextDocument","textDocuments","doc","content","getText","fileContent","fs","readFile","Buffer","from","endLoading","endParsing","toFixed","error","showErrorMessage","funcName","filePath","data","Location","Position","parameters","v","padEnd","TokenType","Level","KeywordType","FunctionScope","IfScope","ForScope","WhileScope","SwitchScope","CaseScope","Scope","DeveloperBlock","DeveloperBlockInner","FunctionCall","FunctionCallWithThread","FunctionCallWithObjectAndThread","FunctionCallWithObject","Reference","Vector","functionCallTypes","FunctionPointer","FunctionPointerExternal","valueTypes","tokens","tokenize","rootGroup","analyze","level","Default","levelChangeStart","char","skip","sLastComment","len","c","c_prev","c_next","SingleLineComment","MultiLineComment","PreprocessorName","test","addToken","Preprocessor","String","LocalizedString","CvarString","Number","Float","DeveloperStart","Assignment2","Operator","DeveloperEnd","Hashtag","ParameterSeparator","ScopeStart","ScopeEnd","ExpressionStart","ExpressionEnd","ArrayStart","ArrayEnd","PathSeparator","Case","Assignment3","OperatorLeft","Assignment","Semicolon","startOffset","endOffset","index","offset","Range","commentBefore","walkGroup","currentGroup","callForEmptyGroups","stack","processed","pop","groupItems","startIndex","wrapType","trimGroupStartBy","trimGroupEndBy","groups","newGroup","GscGroup","tokenIndexStart","tokenIndexEnd","trimIndexStart","trimIndexEnd","splice","replaceGroupsWithSingleGroup","endIndex","groupByBracketPairs","tokenTypeStart","tokenTypeEnd","groupType","startIndexes","tokenType","getSingleTokenType","indexStart","slice","changeGroupToSolvedAndChangeType","newType","XAnim","FunctionParametersExpression","KeywordParametersExpression","CastExpression","FunctionDeclaration","ForStatement","Terminator","group_byGroupAndTokenAndGroup","groupTypesLeft","groupTypesRight","finalType","finalGroup1Type","finalGroup2Type","finalGroup3Type","childGroup1","childGroup2","childGroup3","typeOfUnknownToken2","getTypeOfUnknownToken","group_byGroupAndGroup","backward","group_byKeyword","keywordNames","childTokenName","ReservedKeyword","group_byKeywordNameAndGroup","keywordNamesLeft","groupTypes","Root","childGroup","unknownToken","getUnknownToken","knownKeywords","change_singleUnknownTokens","isUnsolvedGroupOfOneOfType","isUnsolvedSingleTokenOfOneOfType","isUnknownUnsolvedSingleTokenOfOneOfType","Token","group_numberSign","iPathStart","isWord","group_path","PreprocessorStatement","PreprocessorAnimtreeParametersExpression","innerGroup1","openBrackets","closeBrackets","FunctionDereference","KeywordCall","IfDeclaration","ForDeclaration","WhileDeclaration","SwitchDeclaration","CaseLabel","isReservedKeywordOfName","group_byKeywordAndToken","group_byTokenAndGroup","allowedTypes","group1_isVarReference","unwrapType","group2_isThread","group3_isFuncCall","group2_isCall","KeywordCallWithObject","group1_isObject","group_variables_and_function_call","child1Inner1","valueTypesWithIdentifier","DataTypeKeyword","group_casting","childGroup4","typeOfUnknownToken3","group_value_operations","childGroup5","change_expressionToVector","group_byGroupAndToken","TerminatedPreprocessorStatement","keys","group_declarations","FunctionDefinition","group_the_rest","lastFunctionScope","paramPos","lastLabel","FunctionParameterName","solve_unsolved","previousItem","lastDeveloperScope","scopeTypes","GscData","lastFunction","func","paramTokens","element","addDefinition","otherReferences","unshift","r","array","variableDefinition","valueGroup","isFloat","Integer","Undefined","Bool","Function","Entity","debugGroupAsObject","tkns","a03_unsolved","a04_deadCode","deadCode","a01_type","a02_tokens","a06_itemsArray","item","itemDebug","printChilds","startGroup","s","write","debugGroupAsString","startGroupFound","writeLine","spaces1","repeat","spaces2","generateTestChecks","prefix","constructor","names","getIndex","findLastParentInSequenceOfType","findParentOfType","lastGroup","isTrueGroup","lastChildGroup","isBeforeOrEqual","isAfterOrEqual","scopeOfCursorGroup","isAfter","tokenName","contains","isBefore","loopVariableReference","prevPart","field","Field","stringBeforeCursor","getTokensBeforePosition","getTokens","printTokens","structure","registerHoverProvider","provideHover","getHover","hoverText","MarkdownString","funcNameAndPath","d","functionData","parametersText","appendText","appendMarkdown","Hover","SemanticTokensLegend","tokenTypes","tokenModifiers","registerDocumentSemanticTokensProvider","language","legend","provideDocumentSemanticTokens","builder","SemanticTokensBuilder","build","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","Gsc"],"sourceRoot":""}