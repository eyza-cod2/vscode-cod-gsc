{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://cod-gsc/./src/Gsc.ts","webpack://cod-gsc/./src/GscCompletionItemProvider.ts","webpack://cod-gsc/./src/GscDefinitionProvider.ts","webpack://cod-gsc/./src/GscDiagnosticsCollection.ts","webpack://cod-gsc/./src/GscFile.ts","webpack://cod-gsc/./src/GscFileParser.ts","webpack://cod-gsc/./src/GscHoverProvider.ts","webpack://cod-gsc/./src/GscSemanticTokensProvider.ts","webpack://cod-gsc/external commonjs \"vscode\"","webpack://cod-gsc/webpack/bootstrap","webpack://cod-gsc/./src/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GscCompletionItemProvider } from './GscCompletionItemProvider'; \r\nimport { GscSemanticTokensProvider } from './GscSemanticTokensProvider';\r\nimport { GscDiagnosticsCollection } from './GscDiagnosticsCollection';\r\nimport { GscDefinitionProvider } from './GscDefinitionProvider';\r\nimport { GscHoverProvider } from './GscHoverProvider';\r\n\r\n\r\nexport class Gsc {\r\n\r\n    static async activate(context: vscode.ExtensionContext) {\r\n\r\n        // Register events\r\n        GscFile.activate(context);\r\n        GscDiagnosticsCollection.activate(context);\r\n        GscSemanticTokensProvider.activate(context);\r\n        GscCompletionItemProvider.activate(context);\r\n        GscDefinitionProvider.activate(context);\r\n        GscHoverProvider.activate(context);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscData, GscGroup, GscVariableDefinition, GscVariableDefinitionType } from './GscFileParser';\r\n\r\nexport class GscCompletionItemProvider implements vscode.CompletionItemProvider {\r\n    \r\n    static async activate(context: vscode.ExtensionContext) {        \r\n        context.subscriptions.push(vscode.languages.registerCompletionItemProvider('gsc', new GscCompletionItemProvider(), '\\\\', '.', '[', ']'));\r\n    }\r\n    \r\n    async provideCompletionItems( document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken\r\n    ): Promise<vscode.CompletionItem[] | vscode.CompletionList | undefined> \r\n    {\r\n        // Get parsed file\r\n        const gscData = await GscFile.parseAndCacheFile(document.uri);\r\n\r\n        const items = await GscCompletionItemProvider.getCompletionItems(gscData, position);\r\n\r\n        return items;\r\n    }\r\n    \r\n\r\n    /**\r\n     * This function get suggestions for auto-complete. It supports:\r\n     *  - variable names (eg. level.field1, game[\"abc\"])\r\n     *  - path (eg. maps\\mp\\gametypes)\r\n     * @returns \r\n     */\r\n    public static async getCompletionItems(\r\n        gscData: GscData,\r\n        position: vscode.Position,\r\n        onlyVariables: boolean = false\r\n    ): Promise<vscode.CompletionItem[]> \r\n    {\r\n        const completionItems: vscode.CompletionItem[] = [];\r\n\r\n        //console.log(\"CompletionItemProvider --------------------------------------------------------\");\r\n\r\n        const startTime = performance.now();\r\n\r\n\r\n        // Get group before cursor\r\n        var groupAtCursor = gscData.root.findGroupOnLeftAtPosition(position);\r\n        if (groupAtCursor === undefined || groupAtCursor.parent === undefined) {\r\n            return completionItems;\r\n        }    \r\n        //console.log(\"Group at cursor: \" + groupAtCursor.toString());\r\n\r\n\r\n        // Get current function data\r\n        const functionGroup = gscData.functions.find(f => {\r\n            const range = f.scopeRange;\r\n            if (((position.line === range.start.line && position.character > range.start.character) || position.line > range.start.line) && \r\n                ((position.line === range.end.line && position.character < range.end.character) || position.line < range.end.line)) \r\n            {\r\n                return true;\r\n            }\r\n        });\r\n       \r\n        // Debug all local variables of function\r\n        //functionGroup?.localVariableDefinitions.forEach(c => console.log(c.variableReference.getTokensAsString() + \" \" + GscVariableDefinitionType[c.type]));\r\n\r\n\r\n        if (functionGroup !== undefined) {\r\n\r\n            // Create items for variables like level.aaa, game[\"bbb\"] and local1.aaa[0][1]\r\n            if (groupAtCursor.type !== GroupType.Path) {\r\n                this.createVariableItems(completionItems, position, groupAtCursor, gscData, functionGroup.localVariableDefinitions, onlyVariables);\r\n            }\r\n\r\n\r\n            // Keywords like true, false, undefined, if, else, waittillframeend, ...\r\n            if (onlyVariables === false) {\r\n                await this.createPathItems(completionItems, position, groupAtCursor);\r\n            }\r\n        }\r\n\r\n        const duration = performance.now() - startTime;\r\n        console.log(\"CompletionProvider done, exec time: \" + duration + \"ms\");\r\n\r\n        return completionItems;\r\n    }\r\n\r\n\r\n\r\n\r\n    private static createVariableItems(completionItems: vscode.CompletionItem[], position: vscode.Position, \r\n        groupAtCursor: GscGroup, gscData : GscData, localVariableDefinitions: GscVariableDefinition[], onlyVariables: boolean) \r\n    {\r\n        // Select local variables \r\n        const variableItems: {name: string, detail: string | undefined, types: Set<GscVariableDefinitionType>, kind: vscode.CompletionItemKind}[] = [];\r\n\r\n        // Get variable string before cursor\r\n        // For example:\r\n        //  level.aaa\r\n        //  array1[\"abc\"][0]\r\n        var variableBeforeCursor = groupAtCursor.getVariableStringBeforePosition(position);\r\n        //console.log(\"Var before: '\" + variableBeforeCursor + \"'\");\r\n\r\n        // Decide where we are\r\n        const inVariableName = variableBeforeCursor === \"\" || groupAtCursor?.typeEqualsToOneOf(GroupType.VariableName, GroupType.Identifier);\r\n        const inStructureVariable = (groupAtCursor?.type === GroupType.StructureField || (groupAtCursor?.getFirstToken().name === \".\"));\r\n        const inArrayBrackets = (\r\n            (groupAtCursor?.type === GroupType.Array && position.character < groupAtCursor.getRange().end.character) || // xxx[...]\r\n            (variableBeforeCursor.at(-1) === \"[\") // xxx[\r\n        );\r\n\r\n        // If user typed 'level.aaa.bbb', we want to get 'level.aaa.' (last non word char index)\r\n        const nonWordChars = variableBeforeCursor.match(/\\W/g);\r\n        const lastNonWordIndexInCursorVar = nonWordChars ? variableBeforeCursor.lastIndexOf(nonWordChars[nonWordChars.length - 1]) : -1;\r\n\r\n        //console.log(\"   inVariableName: \" + inVariableName);\r\n        //console.log(\"   inStructureVariable: \" + inStructureVariable);\r\n        //console.log(\"   inArrayVariable: \" + inArrayBrackets);\r\n\r\n\r\n\r\n        // Definition of global variables\r\n        if (!inStructureVariable && (inVariableName || inArrayBrackets)) {\r\n            variableItems.push({name: \"level\", detail: \"\", types: new Set<GscVariableDefinitionType>([GscVariableDefinitionType.Structure]), kind: vscode.CompletionItemKind.Variable});\r\n            variableItems.push({name: \"game\", detail: \"\", types: new Set<GscVariableDefinitionType>([GscVariableDefinitionType.Array]), kind: vscode.CompletionItemKind.Variable});\r\n            variableItems.push({name: \"self\", detail: \"\", types: new Set<GscVariableDefinitionType>([GscVariableDefinitionType.Unknown]), kind: vscode.CompletionItemKind.Variable});\r\n        }\r\n\r\n        // Local variables\r\n        localVariableDefinitions.forEach(g => {\r\n            getCompletionItemFromVariableDefinition(g);\r\n        });\r\n\r\n        // Level variables\r\n        if (variableBeforeCursor.startsWith(\"level\")) {\r\n            const gscFiles = GscFile.getCachedFiles();\r\n            gscFiles.forEach(g => {\r\n                g.levelVariablesDefinitions.forEach(g => {\r\n                    getCompletionItemFromVariableDefinition(g);\r\n                });\r\n            });\r\n        }\r\n\r\n        // Game variables\r\n        if (variableBeforeCursor.startsWith(\"game\")) {\r\n            const gscFiles = GscFile.getCachedFiles();\r\n            gscFiles.forEach(g => {\r\n                g.gameVariablesDefinitions.forEach(g => {\r\n                    getCompletionItemFromVariableDefinition(g);\r\n                });\r\n            });\r\n        }\r\n\r\n\r\n        function getCompletionItemFromVariableDefinition(g: GscVariableDefinition) {\r\n\r\n            // Turn group of variable reference into variable parts\r\n            //    struct1.field1      => [\"struct1\", \".field\"]\r\n            //    array1[0].field1    => [\"array1\", \"[0]\", \".field1\"]\r\n            //    array1[1][0]        => [\"array1\", \"[1]\", \"[0]\"]\r\n            const variableParts = g.variableReference.getVariableParts();\r\n\r\n\r\n            var varName = \"\";\r\n            var type: GscVariableDefinitionType = GscVariableDefinitionType.Unknown;\r\n            var kind = vscode.CompletionItemKind.Variable;\r\n            var labelName = \"\";\r\n            var detail = \"\";\r\n\r\n            for (var i = 0; i < variableParts.length; i++) {\r\n                const part = variableParts[i];\r\n                const isLast = i === (variableParts.length - 1);\r\n                \r\n                varName += part.text;\r\n                type = isLast ? g.type : part.implicitType;\r\n                kind = part.kind;\r\n\r\n\r\n                // Var name is now longer by one part, or its last value -> time to exit\r\n                // For example:\r\n                //  Text before cursor  VarName\r\n                //  struct1             struct1.aaa\r\n                //  struct1.            struct1.aaa\r\n                //  struct1.aaa         struct1.aaa[0]\r\n                if (!variableBeforeCursor.startsWith(varName) || isLast) {\r\n\r\n                    // If this longer variable name text still starts with the pre-typed text\r\n                    if (varName.startsWith(variableBeforeCursor)) {\r\n                        labelName = varName.substring(lastNonWordIndexInCursorVar + 1);\r\n\r\n                        if (inArrayBrackets) {\r\n                            if (!labelName.startsWith(\"[\") && labelName.endsWith(\"]\")) {\r\n                                labelName = labelName.substring(0, labelName.length - 1); // remove array end ]\r\n                            }\r\n                            kind = vscode.CompletionItemKind.Value;\r\n                        }\r\n                    }\r\n\r\n                    // This var does not match with text before cursor\r\n                    // If its in structure field, don't show this variable\r\n                    else if (inStructureVariable) {\r\n                        varName = \"\";\r\n                    }\r\n\r\n                    // This var does not match with text before cursor\r\n                    // If its in array, show only the root variable names\r\n                    else if (inArrayBrackets) {\r\n                        labelName = variableParts[0].text;\r\n                        type = (variableParts.length === 1) ? g.type : variableParts[0].implicitType;      \r\n                        kind = variableParts[0].kind;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Debug\r\n            const fullVarName = g.variableReference.getTokensAsString();\r\n            //console.log(fullVarName.padEnd(18) + \"   ->   \" + varName.padEnd(15) + \"   ->   \" + labelName.padEnd(10) + \"   ->   \" + GscVariableDefinitionType[type]/* + \"   ->   \" + detail*/ + \"   ->   \" + GscVariableDefinitionType[g.type]);\r\n\r\n            // Ignore empty\r\n            if (labelName === \"\") {\r\n                return;\r\n            }\r\n\r\n            // Add new the variable into completion items or update existing\r\n            const existingItem = variableItems.find(p => p.name === labelName);\r\n            if (existingItem !== undefined) {\r\n                existingItem.types.add(type);\r\n                existingItem.kind = kind;\r\n            } else {\r\n                variableItems.push({name: labelName, detail: detail, types: new Set<GscVariableDefinitionType>([type]), kind: kind});\r\n            }\r\n        }\r\n\r\n        // Insert local variables into completion items\r\n        variableItems.forEach(i => {\r\n            completionItems.push(new vscode.CompletionItem({\r\n                label: i.name,\r\n                detail: i.detail,\r\n                description: GscCompletionItemProvider.getItemDescriptionFromTypes([...i.types])\r\n            }, i.kind));\r\n        });\r\n\r\n\r\n        // Add predefined keywords\r\n        if (onlyVariables === false && (inVariableName || inArrayBrackets)) {\r\n            completionItems.push(new vscode.CompletionItem({label: \"true\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Constant));\r\n            completionItems.push(new vscode.CompletionItem({label: \"false\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Constant));\r\n            completionItems.push(new vscode.CompletionItem({label: \"undefined\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Constant));\r\n    \r\n            if (inVariableName) {\r\n                completionItems.push(new vscode.CompletionItem({label: \"if\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"else\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"for\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"while\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"switch\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"return\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                \r\n                completionItems.push(new vscode.CompletionItem({label: \"case\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"default\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                \r\n                completionItems.push(new vscode.CompletionItem({label: \"break\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"continue\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                \r\n                completionItems.push(new vscode.CompletionItem({label: \"thread\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"wait\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"waittill\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"waittillmatch\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));      \r\n                completionItems.push(new vscode.CompletionItem({label: \"waittillframeend\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"notify\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"endon\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n                completionItems.push(new vscode.CompletionItem({label: \"breakpoint\", description: \"\", detail: \"\"}, vscode.CompletionItemKind.Keyword));\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    \r\n\r\n\r\n    /**\r\n     * Get path before cursor and search for this path in workspace folders.\r\n     */\r\n    private static async createPathItems(completionItems: vscode.CompletionItem[], position: vscode.Position, groupAtCursor: GscGroup) {\r\n        \r\n        const pathBeforeCursor = groupAtCursor.getPathStringBeforePosition(position);\r\n      \r\n        var fileSubPath = \"\";\r\n        \r\n        // Remove last word after \\\r\n        //  maps\\mp\\file -> maps\\mp\r\n        var lastPathIndex = pathBeforeCursor.lastIndexOf(\"\\\\\");\r\n        if (lastPathIndex !== -1) {\r\n            fileSubPath = pathBeforeCursor.substring(0, lastPathIndex);\r\n\r\n            // Normalize backslashes or forward slashes for consistency\r\n            fileSubPath = fileSubPath.replace(/\\\\/g, '/');\r\n        }\r\n\r\n        if (fileSubPath === \"\") {\r\n            //vscode.window.showInformationMessage(\"not a valid file path\");\r\n            return;\r\n        }\r\n\r\n        // Find any files in workspace that contains this path.\r\n        // Since this function does not return folders, search also for files in subfolder\r\n        const files = await vscode.workspace.findFiles(`**/${fileSubPath}/{*.gsc,*/*.gsc}`);\r\n\r\n        // Debug files\r\n        //files.forEach(f => console.log(f.path));\r\n\r\n        // Loop files\r\n        const keywords: {label: string, detail: string, kind: vscode.CompletionItemKind}[] = [];\r\n        for (const file of files) {\r\n\r\n            // Convert c:/folder1/workspaceFolder/maps/mp/file.gsc  ->  root/workspaceFolder/maps/mp/file.gsc\r\n            var relativePath = vscode.workspace.asRelativePath(file.path, false);\r\n\r\n            // Remove the folder prefix that user pre-typed\r\n            //  root/workspaceFolder/maps/mp/file.gsc       -> file.gsc\r\n            //  root/workspaceFolder/maps/mp/dir/file.gsc   -> dir/file.gsc\r\n            const subpathIndex = relativePath.indexOf(fileSubPath);  \r\n            if (subpathIndex !== -1) {\r\n                var subpathKeyword = relativePath.substring(subpathIndex + fileSubPath.length + 1);\r\n\r\n                const slashIndex = subpathKeyword.indexOf(\"/\");\r\n\r\n                // Folder\r\n                if (slashIndex !== -1) {\r\n                    const folderName = subpathKeyword.substring(0, slashIndex);\r\n                    const exists = keywords.some(k => k.label === folderName);\r\n                    if (!exists) {\r\n                        keywords.push({label: folderName, detail: \"\", kind: vscode.CompletionItemKind.Folder});\r\n                    }\r\n                }\r\n                // File\r\n                else {\r\n                    // Get file extension\r\n                    var re = /(?:\\.([^.]+))?$/;\r\n                    const fileExtension = re.exec(subpathKeyword)?.[1] ?? \"\";\r\n                    if (fileExtension.toLowerCase() !== \"gsc\") {\r\n                        continue;\r\n                    }\r\n                    var fileName = subpathKeyword.substring(0, subpathKeyword.length - 4); // remove .gsc extension from file name\r\n\r\n                    keywords.push({label: fileName, detail: \".gsc\", kind: vscode.CompletionItemKind.File});\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add completion items\r\n        keywords.forEach(k => {\r\n            completionItems.push(new vscode.CompletionItem({ label: k.label, description: \"\", detail: k.detail}, k.kind));\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    public static getItemDescriptionFromTypes(types: GscVariableDefinitionType[]) {\r\n        const unknownValueTypes = [GscVariableDefinitionType.UnknownValue, GscVariableDefinitionType.UnknownValueFromFunction, GscVariableDefinitionType.UnknownValueFromVariable];\r\n        \r\n        var typesString = types\r\n            .filter(t => !unknownValueTypes.includes(t))\r\n            .map(type => {\r\n                if (type === GscVariableDefinitionType.Unknown) {\r\n                    return \"?\";\r\n                } else {\r\n                    function addSpaceBetweenLowerUpper(str: string): string {\r\n                        return str.replace(/([a-z])([A-Z])/g, '$1 $2');\r\n                    }\r\n                    return addSpaceBetweenLowerUpper(GscVariableDefinitionType[type]).toLowerCase();\r\n                }\r\n            })\r\n            .join(\", \");\r\n\r\n        if (typesString === \"?\") {\r\n            typesString = \"\";\r\n        }\r\n        if (typesString !== \"\") {\r\n            typesString = \"(\" + typesString + \")\";\r\n        }\r\n\r\n        return typesString;\r\n    }\r\n\r\n\r\n\r\n\r\n}","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscData, GscFileParser } from './GscFileParser';\r\n\r\nexport class GscDefinitionProvider implements vscode.DefinitionProvider {\r\n\r\n    static async activate(context: vscode.ExtensionContext) {       \r\n        context.subscriptions.push(vscode.languages.registerDefinitionProvider('gsc', new GscDefinitionProvider()));\r\n    }\r\n\r\n    async provideDefinition(\r\n        document: vscode.TextDocument, \r\n        position: vscode.Position, \r\n        token: vscode.CancellationToken\r\n    ): Promise<vscode.Location[] | null> \r\n    {\r\n        // Get parsed file\r\n        const gscData = await GscFile.getFile(document.uri);\r\n\r\n        const locations = await this.getFunctionDefinitionLocations(gscData, position, document.uri);\r\n\r\n        return locations;\r\n    }\r\n\r\n\r\n    /**\r\n     * This function finds definitions of function names in current file, included files and in external files\r\n     *  @example\r\n     *     function(1, 2);\r\n     *     function_included();\r\n     *     _tests\\definition_file::function_file();\r\n     * @returns \r\n     */\r\n    public async getFunctionDefinitionLocations(gscData: GscData, position: vscode.Position, documentUri: vscode.Uri): Promise<vscode.Location[]> {\r\n        const locations: vscode.Location[] = [];\r\n        \r\n        // Get group before cursor\r\n        var groupAtCursor = gscData.root.findGroupOnLeftAtPosition(position);\r\n        if (groupAtCursor === undefined || groupAtCursor.parent === undefined) {\r\n            return locations;\r\n        }\r\n\r\n        if (groupAtCursor.type === GroupType.FunctionName) {\r\n            const funcData = groupAtCursor.getFunctionNameAndPath();\r\n            if (funcData !== undefined) {\r\n                locations.push(...await GscFile.getFunctionNameDefinitions(funcData.name, funcData.path, documentUri));\r\n            }\r\n        }\r\n\r\n        //console.log(groupAtCursor.toString());\r\n\r\n        //console.log(locations.map(l => l.uri.path).join(\"\\n\"));\r\n\r\n        return locations;\r\n    }\r\n\r\n}","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscGroup, TokenType } from './GscFileParser';\r\n\r\nexport class GscDiagnosticsCollection {\r\n    private static diagnosticCollection: vscode.DiagnosticCollection;\r\n\r\n    static async activate(context: vscode.ExtensionContext) {\r\n        this.diagnosticCollection = vscode.languages.createDiagnosticCollection('gsc');\r\n        context.subscriptions.push(this.diagnosticCollection);\r\n\r\n        GscFile.onDidParseDocument(uri => this.updateDiagnostics(uri));\r\n        GscFile.onDidDeleteDocument(uri => this.deleteDiagnostics(uri));\r\n\r\n        // TODO on rename\r\n    }\r\n\r\n\r\n    /**\r\n     * This function is called when some gsc file is parsed. \r\n     * The parsed gsc file will be analyzed for commons errors like:\r\n     *  - missing ;\r\n     *  - unexpected tokens (bad syntax)\r\n     */\r\n    static async updateDiagnostics(uri: vscode.Uri) {\r\n        //console.log(\"[DiagnosticsProvider]\", \"Document changed, creating diagnostics...\");\r\n\r\n        var diagnostics: vscode.Diagnostic[] = [];\r\n\r\n        var gsc2 = await GscFile.getFile(uri);\r\n\r\n        function walkGroupItems(parentGroup: GscGroup, items: GscGroup[], action: (parentGroup: GscGroup, group: GscGroup) => boolean) {\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < items.length; i++) {\r\n                var innerGroup = items[i];\r\n                const fullRangeErrorSet = action(parentGroup, innerGroup);\r\n                if (fullRangeErrorSet === false) {\r\n                    walkGroupItems(innerGroup, innerGroup.items, action);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        walkGroupItems(gsc2.root, gsc2.root.items, (parentGroup, group) => {\r\n\r\n            const terminationNeededFor = [GroupType.Statement,\r\n                GroupType.FunctionCall, GroupType.FunctionCallWithThread, GroupType.FunctionCallWithObject, GroupType.FunctionCallWithObjectAndThread,\r\n                GroupType.KeywordCall, GroupType.KeywordCallWithObject];\r\n\r\n            if (group.type === GroupType.Unknown) {\r\n                diagnostics.push(new vscode.Diagnostic(group.getRange(), \"Unexpected token\", vscode.DiagnosticSeverity.Error));\r\n                return true;\r\n            }\r\n            else if (group.solved === false) {\r\n\r\n                if (group.type === GroupType.Statement && parentGroup.type !== GroupType.TerminatedStatement) {\r\n                    diagnostics.push(new vscode.Diagnostic(group.getRange(), \"Missing ;\", vscode.DiagnosticSeverity.Error));\r\n                    return true;\r\n                }\r\n                else if (group.typeEqualsToOneOf(GroupType.Expression, GroupType.ForExpression) && group.items.length === 0) {\r\n                    diagnostics.push(new vscode.Diagnostic(group.getRange(), \"Empty expression\", vscode.DiagnosticSeverity.Error));\r\n                    return true;\r\n                }\r\n                else\r\n                {\r\n                    const firstToken = group.getFirstToken();\r\n    \r\n                    var token = group.getSingleToken();\r\n                    if (token !== undefined) {\r\n                        diagnostics.push(new vscode.Diagnostic(group.getRange(), \"Unexpected token \" + firstToken.name, vscode.DiagnosticSeverity.Error));\r\n                        return true;\r\n                    } else {\r\n                        const range = group.getRange();\r\n                        diagnostics.push(new vscode.Diagnostic(range, \"Unexpected tokens - \" + group.toString(), vscode.DiagnosticSeverity.Error));\r\n                        return true;\r\n                        //diagnostics.push(new vscode.Diagnostic(new vscode.Range(range.start.line, range.start.character, range.start.line, range.start.character+1), \"Unsolved tokens - start\", vscode.DiagnosticSeverity.Error));\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                switch (group.type as GroupType) {\r\n \r\n                    case GroupType.ExtraTerminator:\r\n                        diagnostics.push(new vscode.Diagnostic(group.getRange(), \"Terminator ; is not needed\", vscode.DiagnosticSeverity.Information));\r\n                        return true;\r\n/*\r\n                    case GroupType.TerminatedStatement:\r\n                        if (group.items.length <= 1) {\r\n                            diagnostics.push(new vscode.Diagnostic(group.getRange(), \"Unreachable code\", vscode.DiagnosticSeverity.Warning));\r\n                            return true;\r\n                        }\r\n                        break;*/\r\n                }\r\n            }\r\n\r\n\r\n/*\r\n            if (group.deadCode && parentGroup.deadCode === false) {\r\n                diagnostics.push(new vscode.Diagnostic(group.getRange(), \"Unreachable code\", vscode.DiagnosticSeverity.Warning));\r\n                return true;\r\n            }*/\r\n\r\n            return false;\r\n        });\r\n\r\n\r\n        this.diagnosticCollection.set(uri, diagnostics);\r\n\r\n        //console.log(\"[DiagnosticsProvider]\", \"Diagnostics done\");\r\n    }\r\n\r\n    static deleteDiagnostics(uri: vscode.Uri) {\r\n        this.diagnosticCollection.delete(uri);\r\n    }\r\n\r\n    static async createDiagnosticsForAll() {\r\n        console.log(\"[DiagnosticsProvider]\", \"Creating overall diagnostics...\");\r\n\r\n        this.diagnosticCollection.clear();\r\n\r\n        var files = GscFile.getCachedFiles();\r\n\r\n        for(const [uri, gsc] of files) {\r\n            this.updateDiagnostics(vscode.Uri.parse(uri));\r\n        }\r\n\r\n        console.log(\"[DiagnosticsProvider]\", \"Creating overall diagnostics done\");\r\n    }\r\n}\r\n\r\n/*\r\n\r\n        // Define a simple object to hold the boolean value\r\n        type SolverData = {\r\n            scopeEnded: boolean;\r\n        };\r\n\r\n        function solve_unsolved(\r\n            parentGroup: GscGroup,\r\n            lastFunctionScope: GscGroup | undefined = undefined, \r\n            lastIfScope: GscGroup | undefined = undefined, \r\n            lastForScope: GscGroup | undefined = undefined, \r\n            lastWhileScope: GscGroup | undefined = undefined, \r\n            lastSwitchScope: GscGroup | undefined = undefined,  \r\n            lastCaseScope: GscGroup | undefined = undefined, \r\n            lastScope: GscGroup | undefined = undefined, \r\n            scopeEnded: boolean = false\r\n        ): SolverData\r\n        {\r\n            const data: SolverData = {\r\n                scopeEnded: false\r\n            };\r\n            \r\n            switch (parentGroup.type as GroupType) {   \r\n                case GroupType.FunctionScope:\r\n                    lastFunctionScope = parentGroup;\r\n                    break;  \r\n                case GroupType.IfScope:\r\n                    lastIfScope = parentGroup;\r\n                    break;          \r\n                case GroupType.ForScope:\r\n                    lastForScope = parentGroup;\r\n                    break;          \r\n                case GroupType.WhileScope:\r\n                    lastWhileScope = parentGroup;\r\n                    break;         \r\n                case GroupType.SwitchScope:\r\n                    lastSwitchScope = parentGroup;\r\n                    break;         \r\n                case GroupType.CaseScope:\r\n                    lastCaseScope = parentGroup;\r\n                    break;      \r\n                case GroupType.Scope:\r\n                    lastScope = parentGroup;\r\n                    break;\r\n            }\r\n\r\n            const inAnyOfScope = \r\n                lastFunctionScope !== undefined || lastIfScope !== undefined || lastForScope !== undefined || \r\n                lastWhileScope !== undefined || lastSwitchScope !== undefined || lastCaseScope !== undefined || lastScope !== undefined;\r\n\r\n            if (scopeEnded) {\r\n                parentGroup.deadCode = true;\r\n                data.scopeEnded = true;\r\n            }\r\n\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < parentGroup.items.length; i++) {\r\n                const innerGroup = parentGroup.items[i];\r\n                const innerData = solve_unsolved(innerGroup, lastFunctionScope, lastIfScope, lastForScope, lastWhileScope, lastSwitchScope, lastCaseScope, lastScope, scopeEnded);        \r\n                scopeEnded = innerData.scopeEnded;\r\n            }\r\n\r\n            \r\n            switch (parentGroup.type as GroupType) {\r\n\r\n                case GroupType.Root:\r\n                    break;\r\n\r\n                case GroupType.DeveloperBlock:\r\n                    parentGroup.solved = true; \r\n                    break;\r\n\r\n                case GroupType.FunctionDefinition:\r\n                    if (lastFunctionScope === undefined) { // root\r\n                        parentGroup.solved = true; \r\n                    } \r\n                    break;\r\n\r\n                \r\n                case GroupType.FunctionScope:\r\n                case GroupType.IfScope:\r\n                case GroupType.ForScope:\r\n                //case GroupType.WhileScope:\r\n                case GroupType.CaseScope:\r\n                case GroupType.Scope:\r\n                    // Scope inside known scopes are valid\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n                        const childGroup2 = parentGroup.items.at(i + 1);\r\n                        if (childGroup1.type === GroupType.Scope) {\r\n                            childGroup1.solved = true;\r\n                        }\r\n                        if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.Semicolon)) {\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Token);\r\n                            const newGroup = groupItems(parentGroup, i, GroupType.TerminatedStatement, 0, 0, childGroup1);\r\n                            newGroup.solved = true;\r\n                        }\r\n                    } \r\n                    break;\r\n\r\n                case GroupType.SwitchScope:\r\n\r\n                    break;\r\n\r\n                case GroupType.TerminatedStatement:\r\n\r\n                    if (inAnyOfScope) {\r\n\r\n                        if (lastSwitchScope === undefined || lastCaseScope !== undefined) { // switch scope can contain only CaseLabel\r\n                            parentGroup.solved = true;\r\n                        }\r\n\r\n                        if (parentGroup.items.length === 2 && \r\n                            parentGroup.items[0].type === GroupType.Statement && parentGroup.items[0].items.length === 1 &&\r\n                            parentGroup.items[0].items[0].type === GroupType.ReservedKeyword)\r\n                        {\r\n                            const name = parentGroup.items[0].items[0].getSingleToken()?.name;\r\n                            if (name === undefined) { break; }\r\n                            switch (name) {\r\n                                case \"break\": // for, while, case\r\n                                    if (lastForScope !== undefined || lastWhileScope !== undefined || lastCaseScope !== undefined) {\r\n                                        data.scopeEnded = true;   // everything in this scope is dead code\r\n                                    } else {\r\n                                        parentGroup.solved = false;\r\n                                    }\r\n                                    break;\r\n        \r\n                                case \"continue\": // for, while\r\n                                    if (lastForScope !== undefined || lastWhileScope !== undefined) {\r\n                                        data.scopeEnded = true; // everything in this scope is dead code\r\n                                    } else {\r\n                                        parentGroup.solved = false;\r\n                                    }\r\n                                    break;\r\n        \r\n                                case \"return\": // function\r\n                                    if (lastFunctionScope !== undefined) {\r\n                                        data.scopeEnded = true; // everything in this scope is dead code\r\n                                    } else {\r\n                                        parentGroup.solved = false;\r\n                                    }\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.TerminatedPreprocessorStatement:\r\n                    break;\r\n\r\n                case GroupType.VariableReference:\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n        \r\n                        // Make inside of array solved\r\n                        // game[] or level.aaa[]\r\n                        if (childGroup1.type === GroupType.Array && childGroup1.solved) \r\n                        {\r\n                            const innerGroup = childGroup1.items.at(0);\r\n                            if (innerGroup !== undefined && typeEqualsToOneOf(innerGroup.type, ...valueTypesWithIdentifier)) {\r\n                                changeGroupToSolvedAndChangeType(childGroup1, innerGroup, GroupType.Value);\r\n                            }\r\n                        }\r\n                    } \r\n                    break;\r\n\r\n                case GroupType.Expression:\r\n                    if (parentGroup.items.length === 1 && parentGroup.items[0].type === GroupType.Identifier) {\r\n                        changeGroupToSolvedAndChangeType(parentGroup, parentGroup.items[0], GroupType.VariableReference);\r\n                    }\r\n                    else if (parentGroup.items.length === 1 && typeEqualsToOneOf(parentGroup.items[0].type, ...valueTypes)) {\r\n                        parentGroup.items[0].solved = true;\r\n                    } else {\r\n                        parentGroup.solved = false; // empty expressions like ->  1 + ()\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.FunctionParametersExpression:\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n\r\n                        // Parameter\r\n                        if ((i % 2) === 0) {\r\n                            \r\n                            // Function definition\r\n                            if (inAnyOfScope === false && childGroup1.type === GroupType.Identifier) {                          \r\n                                if (inAnyOfScope === false) {\r\n                                    childGroup1.type = GroupType.FunctionParameterName;\r\n                                    childGroup1.solved = true;\r\n                                }                        \r\n                            // Function call\r\n                            } else if (inAnyOfScope && typeEqualsToOneOf(childGroup1.type, ...valueTypesWithIdentifier)) {\r\n                                if (childGroup1.type === GroupType.Identifier) {\r\n                                    changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.VariableReference);\r\n                                } else {\r\n                                    childGroup1.solved = true;\r\n                                }\r\n                            }\r\n\r\n                        // Separator\r\n                        } else if (i + 1 < parentGroup.items.length) {\r\n                            if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator) && (i % 2) !== 0) {\r\n                                changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Token);\r\n                            }\r\n                        }\r\n        \r\n                    } \r\n                    break;\r\n\r\n                case GroupType.KeywordParametersExpression:\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n\r\n                        // Parameter\r\n                        if ((i % 2) === 0) {                           \r\n                            if (typeEqualsToOneOf(childGroup1.type, ...valueTypesWithIdentifier)) {\r\n                                if (childGroup1.type === GroupType.Identifier) {\r\n                                    changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.VariableReference);\r\n                                } else {\r\n                                    childGroup1.solved = true;\r\n                                }\r\n                            }\r\n                        // Separator\r\n                        } else if (i + 1 < parentGroup.items.length) {\r\n                            if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator) && (i % 2) !== 0) {\r\n                                changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Token);\r\n                            }\r\n                        }\r\n        \r\n                    } \r\n                    break;\r\n\r\n                case GroupType.ForExpression:\r\n                    // for (;;) is minimum\r\n                    if (parentGroup.items.length < 2) {\r\n                        parentGroup.solved = false;\r\n                        break;\r\n                    }\r\n                    var paramPos = 0;\r\n                    for (var i = 0; i < parentGroup.items.length; i++) {\r\n                        const childGroup1 = parentGroup.items[i];\r\n\r\n                        // for (;;)\r\n                        // for (; i < 5;)\r\n                        // for (i = 1; i < 5; i++)\r\n                        // - first (i = 1;) will be already solved as TerminatedToken\r\n                        if (paramPos === 0 && typeEqualsToOneOf(childGroup1.type, GroupType.TerminatedStatement)) {\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.TerminatedStatement);\r\n                            paramPos++;\r\n                        }\r\n                        else if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.Semicolon)) {\r\n                            paramPos++;\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Token);\r\n\r\n                        } else if (paramPos === 1 && typeEqualsToOneOf(childGroup1.type, ...valueTypesWithIdentifier)) {\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Value);\r\n\r\n                        } else if (paramPos === 2 && typeEqualsToOneOf(childGroup1.type, GroupType.Statement)) {\r\n                            changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.TerminatedStatement);\r\n\r\n                        } else {\r\n                            paramPos++;\r\n                        }\r\n                    }\r\n                    if (paramPos >= 3) {\r\n                        parentGroup.solved = false;\r\n                        break;\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.ReservedKeyword:\r\n\r\n                    break;\r\n            }\r\n\r\n            return data;\r\n        }\r\n\r\n        */","import * as vscode from 'vscode';\r\nimport { GscFileParser, GscData } from './GscFileParser';\r\n\r\n\r\n/**\r\n * On startup scan every .gsc file, parse it, and save the result into memory.\r\n * Watch file changes and parse the files again when changed.\r\n * When file is opened in editor, use the editor content.\r\n */\r\nexport class GscFile {\r\n\r\n    private static parsedFiles: Map<string, GscData> = new Map();\r\n    private static _onDidParseDocument: vscode.EventEmitter<vscode.Uri> = new vscode.EventEmitter<vscode.Uri>();\r\n    private static _onDidDeleteDocument: vscode.EventEmitter<vscode.Uri> = new vscode.EventEmitter<vscode.Uri>();\r\n    private static parseAllFiles = false;\r\n\r\n    \r\n    static activate(context: vscode.ExtensionContext) {\r\n        this.parseAllFiles = true;\r\n\r\n        context.subscriptions.push(vscode.workspace.onDidCreateFiles(this.onCreateFiles));\r\n        context.subscriptions.push(vscode.workspace.onDidDeleteFiles(this.onDeleteFiles));\r\n        context.subscriptions.push(vscode.workspace.onDidRenameFiles(this.onRenameFiles));\r\n\r\n        // Command to print parsed gsc file data\r\n        context.subscriptions.push(vscode.commands.registerCommand('gsc.debugParsedGscFile', async () => {\r\n            if (vscode.window.activeTextEditor === undefined) {\r\n                return;\r\n            }\r\n            const gscData = await this.getFile(vscode.window.activeTextEditor.document.uri);\r\n            this.debugParsedFile(gscData);\r\n        }));\r\n\r\n        // Command to print parsed gsc file structure\r\n        context.subscriptions.push(vscode.commands.registerCommand('gsc.debugParsedGscFileStructure', async () => {\r\n            if (vscode.window.activeTextEditor === undefined) {\r\n                return;\r\n            }\r\n            const gscData = await this.getFile(vscode.window.activeTextEditor.document.uri);\r\n            console.log(GscFileParser.debugAsString(gscData.root.tokensAll, gscData.root, true));\r\n        }));\r\n    }\r\n\r\n    // Expose an event for external subscription\r\n    public static get onDidParseDocument(): vscode.Event<vscode.Uri> {\r\n        return this._onDidParseDocument.event;\r\n    }\r\n\r\n    public static get onDidDeleteDocument(): vscode.Event<vscode.Uri> {\r\n        return this._onDidDeleteDocument.event;\r\n    }\r\n\r\n    static onCreateFiles(e: vscode.FileCreateEvent) {\r\n        for(const file of e.files) {\r\n            this.parseAndCacheFile(file);       \r\n            console.log(this, \"Added \" + vscode.workspace.asRelativePath(file) + \" for parsing\");\r\n        }\r\n    }\r\n\r\n    static onDeleteFiles(e: vscode.FileDeleteEvent) {\r\n        for(const file of e.files) {\r\n            this.removeCachedFile(file);\r\n            console.log(this, \"Removed \" + vscode.workspace.asRelativePath(file) + \" from parsing\");\r\n        }\r\n    }\r\n\r\n    static onRenameFiles(e: vscode.FileRenameEvent) {\r\n        for(const {oldUri, newUri} of e.files) {\r\n            this.removeCachedFile(oldUri);\r\n            this.parseAndCacheFile(newUri);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load all .gsc files opened in editor or found in workspace file system, parse them and save them into memory\r\n     */\r\n    public static async parseAndCacheAllFiles() {\r\n        console.log(\"Parsing GSC files...\");\r\n        const start = new Date().getTime();\r\n\r\n        // Find all GSC files in repository\r\n        var files = await vscode.workspace.findFiles('**/*.gsc');\r\n        for (const file of files) {\r\n            var gsc = await this.parseAndCacheFile(file);\r\n        }\r\n        let elapsed = new Date().getTime() - start;\r\n\r\n        //this.debugParsedFiles(true);\r\n        //console.log(this, \"Files:\", this.parsedFiles.size, \"Total time:\", elapsed, \"Errors:\", errors);\r\n\r\n        console.log(\"All GSC files parsed, files: \" + this.parsedFiles.size + \", time: \" + elapsed + \"ms\");\r\n    }\r\n\r\n    /**\r\n     * Load specified .gsc from editor or from file system, parse it, and save them into memory\r\n     * @param fileUri Uri of file to parse\r\n     */\r\n    public static async parseAndCacheFile(fileUri: vscode.Uri): Promise<GscData>  {\r\n        var gsc = await this.parseFile(fileUri);\r\n        this.parsedFiles.set(fileUri.toString(), gsc); // Add or update\r\n        // Notify all subscribers that the document has been parsed\r\n        this._onDidParseDocument.fire(fileUri);\r\n\r\n        // Run initial scan of all files\r\n        if (this.parseAllFiles) {    \r\n            this.parseAllFiles = false;   \r\n            await GscFile.parseAndCacheAllFiles(); \r\n            return this.getFile(fileUri);\r\n        }\r\n\r\n        return gsc;\r\n    }\r\n\r\n    /**\r\n     * Load specified .gsc from editor or from file system, parse it, and save them into memory\r\n     * @param fileUri Uri of file to parse\r\n     */\r\n    public static removeCachedFile(fileUri: vscode.Uri) {\r\n        this.parsedFiles.delete(fileUri.toString());\r\n    }\r\n\r\n\r\n    public static async getFile(fileUri: vscode.Uri): Promise<GscData> {\r\n        var gsc = this.parsedFiles.get(fileUri.toString()) ?? await this.parseAndCacheFile(fileUri);\r\n        return gsc;\r\n    }\r\n\r\n    public static getCachedFiles(): Map<string, GscData> {\r\n        return this.parsedFiles;\r\n    }\r\n\r\n\r\n    /**\r\n     * Parse file according to Uri. If the file is opened is editor, the content is used. Otherwise the file's content is read from the file system.\r\n     * @param fileUri Uri of file to parse\r\n     * @returns Parsed data\r\n     */\r\n    private static async parseFile(fileUri: vscode.Uri): Promise<GscData> {\r\n        console.log(\"Parsing \" + vscode.workspace.asRelativePath(fileUri) + \"\");\r\n\r\n        // Check if the file is opened in any editor\r\n        const openedTextDocument = vscode.workspace.textDocuments.find(doc => doc.uri === fileUri);\r\n        \r\n        var content: string;\r\n        if (openedTextDocument) {\r\n            content = openedTextDocument.getText();\r\n        } else {\r\n            const fileContent = await vscode.workspace.fs.readFile(fileUri);      \r\n            content =  Buffer.from(fileContent).toString('utf8'); // Convert the Uint8Array content to a string\r\n        }\r\n        return GscFileParser.parse(content);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * \r\n     * @param documentUri \r\n     * @returns \r\n     */\r\n    public static async getFunctionNameDefinitions(funcName: string, path: string, documentUri: vscode.Uri): Promise<vscode.Location[]> {\r\n        const locations: vscode.Location[] = [];\r\n\r\n        // Its external function call\r\n        if (path !== \"\") \r\n        {\r\n            const filePath = path.replace(/\\\\/g, '/') + \".gsc\";\r\n\r\n            // Try to find the file in parsed files\r\n            const gscFiles = GscFile.getCachedFiles();\r\n            gscFiles.forEach((data, uri) => {\r\n                if (uri.endsWith(filePath)) {\r\n                    data.functions.forEach(f => {\r\n                        if (f.name === funcName) {\r\n                            locations.push(new vscode.Location(vscode.Uri.parse(uri), new vscode.Position(f.range.start.line, f.range.start.character)));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } \r\n\r\n        // Its local function or included function\r\n        else {\r\n\r\n            // Find function in this file\r\n            const gscData = await GscFile.getFile(documentUri);\r\n            gscData.functions.forEach(f => {\r\n                if (f.name === funcName) {\r\n                    locations.push(new vscode.Location(documentUri, new vscode.Position(f.range.start.line, f.range.start.character)));\r\n                }\r\n            });\r\n\r\n            // Find function also in included files\r\n            gscData.includes.forEach(path => {\r\n                const filePath = path.replace(/\\\\/g, '/') + \".gsc\";\r\n\r\n                // Try to find the file in parsed files\r\n                const gscFiles = GscFile.getCachedFiles();\r\n                gscFiles.forEach((data, uri) => {\r\n                    if (uri.endsWith(filePath)) {\r\n                        data.functions.forEach(f => {\r\n                            if (f.name === funcName) {\r\n                                locations.push(new vscode.Location(vscode.Uri.parse(uri), new vscode.Position(f.range.start.line, f.range.start.character)));\r\n                            }\r\n                        });\r\n                    }\r\n                });          \r\n            });\r\n        }\r\n        \r\n        return locations;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    public static debugParsedFile(gsc: GscData) {\r\n        \r\n        console.log(\"Functions:\");\r\n        gsc.functions.forEach(f => {\r\n            console.log(\"  \" + f.name + \"(\" + f.parameters.map(p => p.name).join(\", \") + \")\");\r\n        });\r\n        console.log(\"\");\r\n        console.log(\"Variable definitions:\");\r\n        gsc.levelVariablesDefinitions.forEach(v => {\r\n            console.log(\"  \" + v.variableReference.getTokensAsString().padEnd(30));\r\n        });\r\n        gsc.gameVariablesDefinitions.forEach(v => {\r\n            console.log(\"  \" + v.variableReference.getTokensAsString().padEnd(30));\r\n        });\r\n        gsc.functions.forEach(f => {\r\n            f.localVariableDefinitions.forEach(v => {\r\n                console.log(\"  \" + v.variableReference.getTokensAsString().padEnd(30), \"  -> \" + f.name + \"()\");\r\n            });\r\n        });\r\n    }\r\n}\r\n","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\n\r\n\r\nexport enum GroupType {\r\n    /** The root of the tree */\r\n    Root,\r\n    /** Unresolved group */\r\n    Unknown,\r\n\r\n    /** Content surrounded by /##/ */\r\n    DeveloperBlock,\r\n    /** Content surrounded by /##/ */\r\n    DeveloperBlockInner,\r\n    /** Content surrounded by {} */\r\n    Scope,\r\n    /** Content surrounded by () */\r\n    Expression,\r\n    /** Content surrounded by [] */\r\n    Array,\r\n\r\n    /** Single token like ; && || ++ -- ... */\r\n    Token,\r\n    /** Predefined words like if, else, return, ... */\r\n    ReservedKeyword,\r\n    /** Not resolved word, probably variable name or function name */\r\n    Identifier,\r\n    /** Tokens considered as constants - numbers, strings, ... */\r\n    Constant,\r\n    /** Path to an external file */\r\n    Path,\r\n    /** %xanim_file_name */\r\n    XAnim,\r\n    /** Expression with 3 parameters -> (0, 0, 0) */\r\n    Vector,\r\n    /** The result of an operation, like && */\r\n    Value,\r\n\r\n    /** Variable reference like level.aaa or game[\"aaa\"] or level.aaa[\"bbb\"].ccc */\r\n    Reference,\r\n    /** Name of the variable like level or game or var1 */\r\n    VariableName,\r\n    /** Field of structure variable like level.aaa  */\r\n    StructureField,\r\n\r\n    /** Statement like a=1 or a+=1 or a++ */\r\n    Statement,\r\n    /** Statement like a=1 or a+=1 or a++ terminated with ; */\r\n    TerminatedStatement,\r\n    /** Statement like #include path\\name */\r\n    PreprocessorStatement,\r\n    /** Statement like #include path\\name terminated with ; */\r\n    TerminatedPreprocessorStatement,\r\n    /** Parameters expression of preprocessor #using_animtree */\r\n    PreprocessorAnimtreeParametersExpression,\r\n\r\n    /** Single ; */\r\n    Terminator,\r\n    /** Unneeded ; after terminated statement */\r\n    ExtraTerminator,\r\n\r\n    /** Function definition funcName(p1, p2) { ... } */\r\n    FunctionDefinition,\r\n    /** Function declaration like funcName(p1, p2) */\r\n    FunctionDeclaration,\r\n    /** Like funcName() or maps\\script::funcName() */\r\n    FunctionCall,\r\n    /** Like var1 funcName() or var1 maps\\script::funcName() */\r\n    FunctionCallWithObject,\r\n    /** Like thread funcName() or thread maps\\script::funcName() */\r\n    FunctionCallWithThread,\r\n    /** Like var1 thread funcName() or var1 thread maps\\script::funcName() */\r\n    FunctionCallWithObjectAndThread,\r\n    /** Like ::funcName */\r\n    FunctionPointer,\r\n    /** Like maps\\script::funcName */\r\n    FunctionPointerExternal,\r\n    /** [[var]] */\r\n    FunctionDereference,\r\n    /** Like funcName */\r\n    FunctionName,\r\n    /** Like (..., ...) */\r\n    FunctionParametersExpression,\r\n    /** Like var1 */\r\n    FunctionParameterName,\r\n    /** func() {...} */\r\n    FunctionScope,\r\n\r\n    /** Keyword \"if\" and function parameter expression ()  */\r\n    IfDeclaration,  \r\n    /** If scope */\r\n    IfScope,\r\n\r\n    /** waittill (..., ...) */\r\n    KeywordCall,\r\n    /** level waittill (..., ...) */\r\n    KeywordCallWithObject,\r\n    /** level waittill (..., ...) */\r\n    KeywordParametersExpression,\r\n\r\n    ForDeclaration,\r\n    ForExpression,\r\n    ForScope,\r\n    ForStatement,\r\n\r\n    WhileDeclaration,\r\n    WhileScope,\r\n\r\n    SwitchDeclaration,\r\n    SwitchScope,\r\n    CaseLabel,\r\n    CaseScope\r\n}\r\n\r\n/**\r\n * First step is to parse file content into array of @see TokenType which represents words, brackets, operators, comments, strings,...\r\n * These tokens are parsed by function @see tokenize()\r\n * \r\n * Then these tokens are processed into data structure tree according to the language syntax rules via function @see group()\r\n * \r\n * The tree is then analyzed and @see GscData is returned - it contains data about functions, global variables (level, game), local variables, ...\r\n */\r\nexport class GscFileParser {\r\n\r\n    public static readonly scopeTypes: GroupType[] = [\r\n        GroupType.FunctionScope, GroupType.IfScope, GroupType.ForScope, GroupType.WhileScope, \r\n        GroupType.SwitchScope, GroupType.CaseScope, GroupType.Scope\r\n    ];\r\n\r\n    public static readonly functionCallTypes = [\r\n        GroupType.FunctionCall, GroupType.FunctionCallWithThread, GroupType.FunctionCallWithObjectAndThread, GroupType.FunctionCallWithObject\r\n    ];\r\n\r\n    public static readonly valueTypes = [\r\n        GroupType.Constant, GroupType.Reference, GroupType.Value,\r\n        GroupType.Expression, GroupType.Vector,\r\n        ...GscFileParser.functionCallTypes,\r\n        GroupType.FunctionPointer, GroupType.FunctionPointerExternal\r\n    ];\r\n\r\n    public static readonly valueTypesWithIdentifier = [...GscFileParser.valueTypes, GroupType.Identifier];\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Parse GSC file\r\n     * @param content File content of GSC file to be parsed\r\n     * @returns Parsed data\r\n     */\r\n    public static parse(content: string): GscData \r\n    {\r\n        var tokens = this.tokenize(content);\r\n        var rootGroup = this.group(tokens);\r\n        var data = this.analyze(rootGroup, content);\r\n        return data;\r\n    }\r\n\r\n\r\n    /**\r\n     * Parse file content into array of tokens\r\n     * @param content The file content\r\n     * @returns Array of tokens\r\n     */\r\n    public static tokenize(content: string): GscToken[]\r\n    {\r\n        var tokens: GscToken[] = [];\r\n             \r\n        var level: Level = Level.Default;\r\n        var levelChangeStart = -1;\r\n        var line = 0; // line number (starting from 0)\r\n        var char = 0; // char number (starting from 0)\r\n        var skip = 0;\r\n        var sLastComment: string | undefined = undefined;\r\n        var lastToken: GscToken | undefined = undefined;\r\n             \r\n        const len = content.length;\r\n\r\n        for (let i = 0; i <= len; i++) {\r\n            const c = i < len ? content[i] : '';\r\n            const c_prev = i > 0 ? content[i-1] : '';\r\n            const c_next = i < len - 1 ? content[i+1] : '';\r\n\r\n            /* First we need to tokenize the big blocks:\r\n                /* multi-line comments * /\r\n                // single-line comment\r\n                \"strings\" \r\n                keywords\r\n                0.001           // numbers\r\n                ' '             // other characters\r\n            */\r\n\r\n            // Count new lines and char\r\n            // Windows: \"\\r\\n\"    Linux:  \"\\n\"\r\n            if (i > 0) {\r\n                if (content[i-1] === '\\n') {\r\n                    line++;\r\n                    char = 0;\r\n                } else {\r\n                    char++;\r\n                }\r\n            }\r\n\r\n            // This char must be skipped, because is already processed\r\n            if (skip > 0) {\r\n                skip--;\r\n                continue;\r\n            }\r\n\r\n            function addToken(type: TokenType, startOffset: number, endOffset: number) {\r\n                var text = content.substring(startOffset, endOffset);\r\n                const token: GscToken = {\r\n                    index: tokens.length,\r\n                    name: text, \r\n                    offset: startOffset,\r\n                    range: new vscode.Range(line, char - (i - startOffset), line, char - (i - endOffset)),\r\n                    commentBefore: sLastComment,\r\n                    type: type\r\n                };\r\n                tokens.push(token);\r\n                lastToken = token;\r\n\r\n                sLastComment = undefined;\r\n            }\r\n\r\n            /***************************************************************************************************************************************************************\r\n            * Save content of things like function name, preprocessor name, ...\r\n            ****************************************************************************************************************************************************************/\r\n            switch (level as Level) {\r\n\r\n                case Level.SingleLineComment:\r\n                    if (c === '\\n' || c === '') {\r\n                        sLastComment = content.substring(levelChangeStart + 2, ((c_prev === '\\r') ? i - 1 : i));\r\n                        level = Level.Default;\r\n                    }\r\n                    continue; // go to next char\r\n                    \r\n                case Level.MultiLineComment:\r\n                    if ((c === '*' && c_next === '/') || c === '') {\r\n                        skip += 1;\r\n                        sLastComment = content.substring(levelChangeStart + 2, i);\r\n                        level = Level.Default;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                // Its in preprocessor name and this char is no longer a valid preprocessor name, save the name and move level\r\n                case Level.PreprocessorName:\r\n                    if (!/^[a-zA-Z_0-9]$/.test(c)) {\r\n                        addToken(TokenType.Preprocessor, levelChangeStart, i);\r\n                        level = Level.Default;\r\n                        break;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                // Its in string constant and this char is end of the string, save the string content and move level\r\n                case Level.String:\r\n                case Level.LocalizedString:\r\n                case Level.CvarString:  // only COD:BO1\r\n                    if (c === '\\\\' && c_next === '\\\\') { // skip escaped \\\r\n                        skip += 1;\r\n                    } else if (c === '\\\\' && c_next === '\"') { // skip escaped \"\r\n                        skip += 1;\r\n                    } else if (c === '\"' || c === '') {\r\n                        const map = new Map<Level, TokenType>([\r\n                            [Level.String, TokenType.String],\r\n                            [Level.LocalizedString, TokenType.LocalizedString],\r\n                            [Level.CvarString, TokenType.CvarString],\r\n                        ]);\r\n                        const tokeType = map.get(level);\r\n                        addToken(tokeType!, levelChangeStart, i + 1);\r\n                        level = Level.Default;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                // Number did not start with dot, but dot may appear once additionally\r\n                case Level.Number:\r\n                    if (c === '.') {\r\n                        level = Level.Float;\r\n                    }\r\n                    else if (!/^[0-9]$/.test(c)) {\r\n                        addToken(TokenType.Number, levelChangeStart, i);\r\n                        level = Level.Default;\r\n                        break;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                // Float number - the dot is already processed once, now only digits should appear\r\n                case Level.Float:\r\n                    if (!/^[0-9]$/.test(c)) {\r\n                        addToken(TokenType.Number, levelChangeStart, i);\r\n                        level = Level.Default;\r\n                        break;\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                case Level.Keyword:\r\n                    if (!/^[a-zA-Z_0-9]$/.test(c)) {\r\n                        addToken(TokenType.Keyword, levelChangeStart, i);\r\n                        level = Level.Default;\r\n                        break;\r\n                    }\r\n                    continue; // go to next char\r\n            }\r\n\r\n            // It was last char, exit\r\n            if (c === '') {\r\n                break;\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n            /***************************************************************************************************************************************************************\r\n            * Always skip comments, developer blocks and whitespace\r\n            ****************************************************************************************************************************************************************/\r\n            switch (c) {\r\n                case '/':\r\n\r\n                    switch(c_next) {\r\n                        case '/':\r\n                            level = Level.SingleLineComment;\r\n                            levelChangeStart = i;\r\n                            skip += 1;\r\n                            continue; // go to next char\r\n\r\n                        case '*':\r\n                            level = Level.MultiLineComment;\r\n                            levelChangeStart = i;\r\n                            skip += 1;\r\n                            continue; // go to next char\r\n\r\n                        case '#':\r\n                            addToken(TokenType.DeveloperStart, i, i + 2);\r\n                            skip += 1;\r\n                            continue; // go to next char\r\n\r\n                        case '=': \r\n                            addToken(TokenType.Assignment2, i, i + 2);  // /=\r\n                            skip += 1; \r\n                            continue; \r\n\r\n                        default: \r\n                            addToken(TokenType.Operator, i, i + 1);     // /\r\n                            continue; \r\n                    }\r\n                    break;\r\n\r\n                case '#':\r\n                    if (c_next === '/') {\r\n                        addToken(TokenType.DeveloperEnd, i, i + 2);\r\n                        skip += 1;\r\n                        continue; // go to next char\r\n                    }\r\n                    else if (/^[a-zA-Z_]$/.test(c_next)) {\r\n                        level = Level.PreprocessorName;\r\n                        levelChangeStart = i;\r\n                        continue; \r\n                    }\r\n                    else if (c_next === '\"') {\r\n                        level = Level.CvarString;\r\n                        levelChangeStart = i + 1;\r\n                        skip += 1;\r\n                        continue; \r\n                    }\r\n                    else {\r\n                        addToken(TokenType.Hashtag, i, i + 1);     // #\r\n                        continue; \r\n                    }\r\n                    break;\r\n\r\n                case '\"':\r\n                    level = Level.String;\r\n                    levelChangeStart = i;\r\n                    continue; // go to next char\r\n\r\n                case ',':\r\n                    addToken(TokenType.ParameterSeparator, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case '{':\r\n                    addToken(TokenType.ScopeStart, i, i + 1);\r\n                    continue; // go to next char\r\n                case '}':\r\n                    addToken(TokenType.ScopeEnd, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case '(':\r\n                    addToken(TokenType.ExpressionStart, i, i + 1);\r\n                    continue; // go to next char\r\n                case ')':\r\n                    addToken(TokenType.ExpressionEnd, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case '[':\r\n                    if (c_next === ']') {\r\n                        addToken(TokenType.Array, i, i + 2);\r\n                        skip += 1;\r\n                    } else {\r\n                        addToken(TokenType.ArrayStart, i, i + 1);\r\n                    }\r\n                    continue; // go to next char\r\n                case ']':\r\n                    addToken(TokenType.ArrayEnd, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case '.':\r\n                    // Floats starting with dot  .1337\r\n                    if (/^[0-9]$/.test(c_next)) {\r\n                        level = Level.Float;\r\n                        levelChangeStart = i;\r\n                    // Structure variables like level.aaa\r\n                    } else {\r\n                        addToken(TokenType.Structure, i, i + 1);\r\n                    }\r\n                    continue; // go to next char\r\n\r\n                case '\\\\':\r\n                    addToken(TokenType.PathSeparator, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                case ':':\r\n                    if (c_next === ':') {\r\n                        skip += 1;\r\n                        addToken(TokenType.FunctionPointer, i, i + 2);\r\n                    } else {\r\n                        addToken(TokenType.Case, i, i + 1);\r\n                    }\r\n                    continue; // go to next char\r\n\r\n\r\n\r\n\r\n\r\n                case '+': \r\n                case '-': \r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Assignment2, i, i + 2); skip = 1; continue; // +=\r\n                        default: \r\n                            if (c === c_next) {\r\n                                addToken(TokenType.Assignment3, i, i + 2); skip = 1;             // ++ --\r\n                            } else {\r\n                                addToken(TokenType.Operator, i, i + 1);                         // + -\r\n                            }\r\n                            continue; // go to next char\r\n                        }\r\n                        \r\n                case '*':\r\n                case '%':\r\n                case '^':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Assignment2, i, i + 2); skip = 1; continue; // *= /= %= ^=\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // * / % ^ \r\n                    }\r\n\r\n                case '~':\r\n                    addToken(TokenType.OperatorLeft, i, i + 1); continue;                       // ~\r\n\r\n                case '&':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Assignment2, i, i + 2); skip = 1; continue; // &=\r\n                        case '&': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // &&\r\n                        case '\"':                                                               // &\"\r\n                            level = Level.LocalizedString;\r\n                            levelChangeStart = i + 1;\r\n                            skip += 1;\r\n                            continue;\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // &\r\n                    }\r\n\r\n                case '|':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Assignment2, i, i + 2); skip = 1; continue; // |=\r\n                        case '|': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // ||\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // |\r\n                    }\r\n\r\n                case '<':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // <=\r\n                        case '<': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // <<\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // <\r\n                    }\r\n\r\n                case '>':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // >=\r\n                        case '>': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // >>\r\n                        default: addToken(TokenType.Operator, i, i + 1); continue;              // >\r\n                    }\r\n\r\n                case '!':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // !=\r\n                        default: addToken(TokenType.OperatorLeft, i, i + 1); continue;          // !\r\n                    }\r\n\r\n                case '=':\r\n                    switch (c_next) {\r\n                        case '=': addToken(TokenType.Operator, i, i + 2); skip = 1; continue;   // ==\r\n                        default: addToken(TokenType.Assignment, i, i + 1); continue;             // =\r\n                    }\r\n                    \r\n                case ';':\r\n                    addToken(TokenType.Semicolon, i, i + 1);\r\n                    continue; // go to next char\r\n\r\n                // Ignore white spaces\r\n                case ' ':\r\n                case '\\t':\r\n                case '\\f':\r\n                case '\\n':\r\n                case '\\r':\r\n                case '\\v':\r\n                    continue; // go to next char\r\n\r\n                default:\r\n\r\n                    // keyword name\r\n                    if (/^[a-zA-Z_]$/.test(c)) { \r\n                        level = Level.Keyword;\r\n                        levelChangeStart = i;\r\n                    }\r\n                    // Number  123  or  0.1  or  1337.1337  (these may contain decimal place later on)\r\n                    else if (/^[0-9]$/.test(c)) { \r\n                        level = Level.Number;\r\n                        levelChangeStart = i;\r\n\r\n                    } else {\r\n                        addToken(TokenType.Unknown, i, i + 1);\r\n                    }\r\n\r\n                    break;\r\n            }\r\n\r\n        }\r\n\r\n        return tokens;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Group tokens according to language syntax rules into tree items and return the root item\r\n     * @param tokens Array of parsed tokens of file\r\n     * @returns The root tree of data structure tree\r\n     */\r\n    public static group(tokens: GscToken[]): GscGroup {\r\n\r\n        function walkGroup(currentGroup: GscGroup, action: (currentGroup: GscGroup) => void, callForEmptyGroups: boolean = false) {\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < currentGroup.items.length; i++) {\r\n                var innerGroup = currentGroup.items[i];\r\n                walkGroup(innerGroup, action, callForEmptyGroups);\r\n            }\r\n            if (callForEmptyGroups || currentGroup.items.length > 0) {\r\n                action(currentGroup);\r\n            }\r\n        }\r\n\r\n        function groupItems(parentGroup: GscGroup, startIndex: number, wrapType: GroupType, trimGroupStartBy: number, trimGroupEndBy: number, ...groups: GscGroup[]): GscGroup {\r\n            if (groups.length === 0) {\r\n                throw new Error(\"No groups\");\r\n            }\r\n\r\n            // Don't wrap Value into another Value\r\n            if (startIndex === 0 && parentGroup.items.length === groups.length &&\r\n                wrapType === GroupType.Value && \r\n                parentGroup.type === GroupType.Value) {\r\n                return parentGroup;\r\n            }\r\n\r\n            const newGroup = new GscGroup({\r\n                parent: parentGroup,\r\n                type: wrapType,\r\n                tokenIndexStart: groups[0].tokenIndexStart,\r\n                tokenIndexEnd: groups[groups.length - 1].tokenIndexEnd\r\n            }, tokens);\r\n\r\n            groups.forEach(g => {\r\n                g.parent = newGroup;\r\n            });\r\n\r\n            var trimIndexStart = (trimGroupStartBy > 0) ? trimGroupStartBy : undefined;\r\n            var trimIndexEnd = (trimGroupEndBy > 0) ? (trimGroupEndBy * -1) : undefined;\r\n            newGroup.items.push(...groups.slice(trimIndexStart, trimIndexEnd));\r\n\r\n            // Value inside Value consider as solved\r\n            if (startIndex === 0 && parentGroup.items.length === groups.length && parentGroup.solved &&\r\n                typeEqualsToOneOf(wrapType, ...GscFileParser.valueTypes) && \r\n                parentGroup.typeEqualsToOneOf(...GscFileParser.valueTypes)) \r\n            {\r\n                newGroup.solved = true;\r\n            }\r\n\r\n            // Wrap this into variable\r\n            parentGroup.items.splice(startIndex, groups.length, newGroup);\r\n\r\n            return newGroup;\r\n        }\r\n\r\n\r\n        function replaceGroupsWithSingleGroup(parentGroup: GscGroup, startIndex: number, endIndex: number, type: GroupType): GscGroup {\r\n\r\n            var newGroup = new GscGroup({\r\n                parent: parentGroup,\r\n                type: type,\r\n                tokenIndexStart: parentGroup.items[startIndex].tokenIndexStart,\r\n                tokenIndexEnd: parentGroup.items[endIndex].tokenIndexEnd\r\n            }, tokens);\r\n\r\n            // Delete items and replace them with one\r\n            parentGroup.items.splice(startIndex, endIndex - startIndex + 1, newGroup);\r\n\r\n            return newGroup;\r\n        }\r\n\r\n\r\n        function groupByBracketPairs(group: GscGroup, tokenTypeStart: TokenType, tokenTypeEnd:TokenType, groupType: GroupType) {\r\n            const startIndexes: number[] = [];\r\n\r\n            if (group.items.length <= 1) { return; }\r\n\r\n            for (var i = 0; i <= group.items.length; i++) {\r\n                const tokenType = (i >= group.items.length)\r\n                                    ? undefined \r\n                                    : (group.items[i].getSingleTokenType() ?? TokenType.Unknown); // groups will be unknown\r\n\r\n                if (tokenType === tokenTypeStart) {\r\n                    startIndexes.push(i);\r\n\r\n                } else if (tokenType === tokenTypeEnd) {\r\n\r\n                    // Revert to parent group\r\n                    var indexStart = startIndexes.pop();\r\n                    \r\n                    // Update at which token the scope ends (group is the scope) and then go to parent scope\r\n                    if (indexStart !== undefined) { \r\n                        groupItems(group, indexStart, groupType, 1, 1, ...group.items.slice(indexStart, i + 1));\r\n                        i = indexStart - 1;\r\n                        continue; // go again to the same index\r\n                    }\r\n                }\r\n                else if (tokenType === undefined) {\r\n                    \r\n                    // If there are unclosed open bracket, add them\r\n                    while (true) {\r\n                        var indexStart = startIndexes.pop();\r\n                        if (indexStart === undefined) { break; }\r\n                        if (indexStart === group.items.length - 1) { continue; } // ignore last open bracket\r\n                        groupItems(group, indexStart, groupType, 1, 0, ...group.items.slice(indexStart, group.items.length));\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        function change_singleUnknownTokens(parentGroup: GscGroup) {\r\n            for (var i = 0; i < parentGroup.items.length; i++) {\r\n                var childGroup = parentGroup.items[i];\r\n\r\n                var unknownToken = childGroup.getUnknownToken();\r\n                if (unknownToken === undefined) { continue; }\r\n\r\n                switch (unknownToken.type as TokenType) {\r\n                    case TokenType.Number:\r\n                    case TokenType.String:\r\n                    case TokenType.LocalizedString:\r\n                    case TokenType.CvarString:\r\n                    case TokenType.Array:\r\n                        childGroup.type = GroupType.Constant;\r\n                        break;\r\n\r\n                    case TokenType.Preprocessor:\r\n                        childGroup.type = GroupType.ReservedKeyword;\r\n                        break;\r\n\r\n                    case TokenType.Keyword:\r\n                        const knownKeywords = [\"return\", \"if\", \"else\", \"for\", \"while\", \"switch\", \"continue\", \"break\", \"case\", \"default\", \"thread\", \"wait\", \"waittillframeend\", \"waittill\", \"waittillmatch\", \"endon\", \"notify\", \"breakpoint\"];\r\n                        const knownConstants = [\"true\", \"false\", \"undefined\"];\r\n\r\n                        if (knownConstants.includes(unknownToken.name)) {\r\n                            childGroup.type = GroupType.Constant;\r\n                        } else if (knownKeywords.includes(unknownToken.name)) {\r\n                            childGroup.type = GroupType.ReservedKeyword;\r\n                        } else {\r\n                            childGroup.type = GroupType.Identifier;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n\r\n        function typeEqualsToOneOf(type: GroupType | undefined, ...groups: GroupType[]) {\r\n            if (type === undefined) { return false; }\r\n            return groups.includes(type);\r\n        }\r\n\r\n\r\n        function group_path(parentGroup: GscGroup) {\r\n            var iPathStart = -1;\r\n            if (parentGroup.items.length === 0 || parentGroup.type === GroupType.Path) { return; }\r\n            for (var i = 0; i <= parentGroup.items.length; i++) {             \r\n                const childGroup1 = parentGroup.items.at(i);\r\n                if (childGroup1?.solved === true) { continue; }\r\n                const childGroup2 = parentGroup.items.at(i + 1);\r\n                if (childGroup2?.solved === true) { continue; }\r\n                const typeOfUnknownToken2 = childGroup2?.getTypeOfUnknownToken();\r\n\r\n                const isWord = childGroup1?.typeEqualsToOneOf(GroupType.Identifier, GroupType.ReservedKeyword) ?? false;\r\n\r\n                // First word must be an identifier, after the first \\ it may also contain preserved keywords\r\n\r\n                if (((iPathStart === -1 && childGroup1?.type === GroupType.Identifier) || \r\n                     (iPathStart !== -1 && isWord)) &&           \r\n                   (typeOfUnknownToken2 === TokenType.PathSeparator || typeOfUnknownToken2 === TokenType.FunctionPointer)) \r\n                {     \r\n                    if (iPathStart === -1) {\r\n                        iPathStart = i; // This is a path start\r\n                    }\r\n                    if (typeOfUnknownToken2 === TokenType.PathSeparator) {\r\n                        i++;\r\n                    }\r\n                } else if (iPathStart > -1) {                  \r\n                    const iPathEnd = (isWord) ? i : i - 1;\r\n                    replaceGroupsWithSingleGroup(parentGroup, iPathStart, iPathEnd, GroupType.Path);\r\n                    i = iPathStart - 1;\r\n                    iPathStart = -1;\r\n                }\r\n            } \r\n        }\r\n\r\n        // (-1 - -1)    (+1 + 1)    (-.1 + +.1)    (-1, +1, -1)\r\n        function group_numberSign(parentGroup: GscGroup) {\r\n            if (parentGroup.items.length === 0 || parentGroup.type === GroupType.Value) { return; }\r\n            for (var i = -1; i <= parentGroup.items.length - 3; i++) {             \r\n                // operator\r\n                const childGroup1 = i === -1 ? undefined : parentGroup.items[i];\r\n                if (childGroup1 !== undefined && !childGroup1.isUnsolvedGroupOfOneOfType(GroupType.ReservedKeyword) &&\r\n                    !childGroup1.isUnsolvedSingleTokenOfOneOfType(\r\n                    TokenType.Operator, TokenType.ParameterSeparator, TokenType.Assignment, TokenType.Assignment2, TokenType.OperatorLeft)) { continue; }\r\n                \r\n                // + - ,\r\n                const childGroup2 = parentGroup.items[i + 1];\r\n                if (!childGroup2.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.Operator)) { continue; }\r\n                if (![\"+\", \"-\"].includes(childGroup2.getSingleToken()?.name ?? \"\")) { continue; }\r\n                \r\n                // 0.1\r\n                const childGroup3 = parentGroup.items[i + 2];\r\n                if (!childGroup3.isUnsolvedSingleTokenOfOneOfType(TokenType.Number)) { continue; }\r\n\r\n                groupItems(parentGroup, i + 1, GroupType.Value, 0, 0, childGroup2, childGroup3);\r\n                childGroup2.type = GroupType.Token;\r\n                childGroup2.solved = true;\r\n                childGroup3.solved = true;\r\n                // no need to exist because next index will be this new group\r\n            } \r\n        }\r\n\r\n\r\n        // [[func]]()\r\n        function group_functionPointerDereference() {\r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.items.length === 0) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {             \r\n                    // array\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (!childGroup1.isUnsolvedGroupOfOneOfType(GroupType.Array) || childGroup1.items.length !== 1) { continue; }\r\n                    const innerGroup1 = childGroup1.items[0];\r\n                    if (!innerGroup1.isUnsolvedGroupOfOneOfType(GroupType.Array) || innerGroup1.items.length === 0) { continue; }\r\n                    const childGroup2 = parentGroup.items[i + 1];\r\n                    if (!childGroup2.isUnsolvedGroupOfOneOfType(GroupType.Expression)) { continue; }\r\n\r\n                    // Everything inside consider as value, will be solved later\r\n                    if (innerGroup1.items.length === 1) {\r\n                        changeGroupToSolvedAndChangeType(innerGroup1, innerGroup1.items[0], GroupType.Value);\r\n                    } else {\r\n                        const newGroup2 = groupItems(innerGroup1, 0, GroupType.Value, 0, 0, ...innerGroup1.items);\r\n                        newGroup2.solved = true;\r\n                    }\r\n\r\n                    const openBrackets = new GscGroup({\r\n                        parent: childGroup1,\r\n                        type: GroupType.ReservedKeyword,\r\n                        tokenIndexStart: childGroup1.tokenIndexStart,\r\n                        tokenIndexEnd: childGroup1.tokenIndexStart + 1\r\n                    }, tokens);\r\n                    openBrackets.solved = true;\r\n\r\n                    const closeBrackets = new GscGroup({\r\n                        parent: childGroup1,\r\n                        type: GroupType.ReservedKeyword,\r\n                        tokenIndexStart: childGroup1.tokenIndexEnd - 1,\r\n                        tokenIndexEnd: childGroup1.tokenIndexEnd\r\n                    }, tokens);\r\n                    closeBrackets.solved = true;\r\n\r\n                    childGroup1.type = GroupType.FunctionDereference;\r\n                    childGroup1.items.splice(0, 1, openBrackets, ...innerGroup1.items, closeBrackets); // delete the additional array\r\n\r\n                    const newGroup = groupItems(parentGroup, i, GroupType.FunctionCall, 0, 0, childGroup1, childGroup2);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.FunctionDereference);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.FunctionParametersExpression);\r\n                }\r\n            });\r\n        }\r\n        \r\n\r\n        // Find expression with 3 numbers separated by comma   (0, 0, 0)\r\n        function change_expressionToVector(parentGroup: GscGroup) {\r\n            if (parentGroup.items.length !== 5 || parentGroup.type === GroupType.Vector || parentGroup.type !== GroupType.Expression) { return; }\r\n            for (var i = 0; i <= parentGroup.items.length - 5; i++) {             \r\n                const childGroup1 = parentGroup.items[i];\r\n                if (!childGroup1.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier)) { continue; }\r\n                const childGroup2 = parentGroup.items[i + 1];\r\n                if (!childGroup2.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator)) { continue; }\r\n                const childGroup3 = parentGroup.items[i + 2];\r\n                if (!childGroup3.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier)) { continue; }\r\n                const childGroup4 = parentGroup.items[i + 3];\r\n                if (!childGroup4.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator)) { continue; }\r\n                const childGroup5 = parentGroup.items[i + 4];\r\n                if (!childGroup5.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier)) { continue; }\r\n\r\n                parentGroup.type = GroupType.Vector;\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup1, GroupType.Value);\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup2, GroupType.Token);\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup3, GroupType.Value);\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup4, GroupType.Token);\r\n                changeGroupToSolvedAndChangeType(parentGroup, childGroup5, GroupType.Value);        \r\n            } \r\n        }\r\n\r\n\r\n        function changeGroupToSolvedAndChangeType(parentGroup: GscGroup, group: GscGroup, newType: GroupType | undefined) {           \r\n            if (newType !== undefined) {\r\n                const i = parentGroup.items.indexOf(group);\r\n                if (i === -1) {\r\n                    throw new Error(\"group was not found in parent group!\");\r\n                }\r\n\r\n                // This identifier must be resolved to variable\r\n                if (group.type === GroupType.Identifier && (newType === GroupType.Value || newType === GroupType.Reference)) {\r\n                    const newGroup = groupItems(parentGroup, i, GroupType.Reference, 0, 0, group);\r\n                    newGroup.solved = true;\r\n                    group.type = GroupType.VariableName;    \r\n                }\r\n\r\n                // This type is already considered as value, don't wrap into another value group\r\n                else if (typeEqualsToOneOf(group.type, ...GscFileParser.valueTypes) && group.type !== GroupType.Expression && newType === GroupType.Value)\r\n                {}   \r\n\r\n                // Check type directly without making new group\r\n                else if (group.type === GroupType.Unknown || group.type === newType || (\r\n                    group.type === GroupType.Identifier && typeEqualsToOneOf(newType, GroupType.VariableName, GroupType.FunctionName, GroupType.StructureField, GroupType.XAnim)\r\n                ) || (\r\n                    group.type === GroupType.Expression && (typeEqualsToOneOf(newType, GroupType.FunctionParametersExpression, GroupType.KeywordParametersExpression, GroupType.ForExpression)) \r\n                ) || (\r\n                    group.type === GroupType.FunctionCall && (newType === GroupType.FunctionDeclaration)\r\n                ) || (\r\n                    group.type === GroupType.Scope && (typeEqualsToOneOf(newType, GroupType.FunctionScope, GroupType.IfScope, GroupType.ForScope, GroupType.WhileScope, GroupType.SwitchScope))\r\n                ) || (\r\n                    newType === GroupType.ForStatement && (typeEqualsToOneOf(group.type, GroupType.TerminatedStatement, GroupType.Terminator))\r\n                )) {\r\n                    group.type = newType;\r\n                } else {\r\n\r\n                    const newGroup = groupItems(parentGroup, i, newType, 0, 0, group);\r\n                    newGroup.solved = true;\r\n                    /*if (group.type === GroupType.Identifier && newType === GroupType.VariableReference) {\r\n                        group.type = GroupType.VariableName; // Identifiers inside VariableReference change to VariableName\r\n                    }*/\r\n                }\r\n            }\r\n            group.solved = true;\r\n        }\r\n\r\n        function group_byTokenAndGroup(tokenType: TokenType, groupTypesRight: GroupType[], finalType: GroupType, finalGroup1Type: GroupType, finalGroup2Type: GroupType | undefined) {        \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n                    var typeOfUnknownToken1 = childGroup1.getTypeOfUnknownToken();\r\n    \r\n                    if (typeOfUnknownToken1 === tokenType &&\r\n                        typeEqualsToOneOf(childGroup2.type, ...groupTypesRight)) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, childGroup1, childGroup2);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                } \r\n            });\r\n        }\r\n\r\n        function group_byGroupAndToken(groupTypesLeft: GroupType[], tokenType: TokenType, finalType: GroupType, finalGroup1Type: GroupType, finalGroup2Type: GroupType) {        \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n                    var typeOfUnknownToken2 = childGroup2.getTypeOfUnknownToken();\r\n\r\n                    if (typeEqualsToOneOf(childGroup1.type, ...groupTypesLeft) && \r\n                        typeOfUnknownToken2 === tokenType) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, childGroup1, childGroup2);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                } \r\n            });\r\n        }\r\n\r\n        function group_byGroupAndTokenAndGroup(groupTypesLeft: GroupType[], tokenType: TokenType, groupTypesRight: GroupType[], finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined, finalGroup3Type: GroupType | undefined) {        \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                for (var i = 0; i < parentGroup.items.length - 2; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n                    var childGroup3 = parentGroup.items[i + 2];\r\n                    if (childGroup3.solved) { continue; }\r\n                    var typeOfUnknownToken2 = childGroup2.getTypeOfUnknownToken();\r\n\r\n                    if (typeEqualsToOneOf(childGroup1.type, ...groupTypesLeft) &&\r\n                        typeOfUnknownToken2 === tokenType &&\r\n                        typeEqualsToOneOf(childGroup3.type, ...groupTypesRight)) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, childGroup1, childGroup2, childGroup3);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup3, finalGroup3Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                } \r\n            });\r\n        }\r\n\r\n        function group_byGroupAndGroup(groupTypesLeft: GroupType[], groupTypesRight: GroupType[], finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined, backward: boolean = false) {                  \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; true; i++) {\r\n                    var index = i;\r\n                    if (backward) {\r\n                        index = parentGroup.items.length - 2 - i;\r\n                        if (index < 0) { break; }\r\n                    } else {\r\n                        if (index > parentGroup.items.length - 2) { break; }\r\n                    }\r\n                    var childGroup1 = parentGroup.items[index];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[index + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n    \r\n                    if (typeEqualsToOneOf(childGroup1.type, ...groupTypesLeft) &&\r\n                        typeEqualsToOneOf(childGroup2.type, ...groupTypesRight)) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, index, finalType, 0, 0, childGroup1, childGroup2);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                } \r\n            });\r\n        }\r\n\r\n\r\n        function group_variables_and_function_call(rootGroup: GscGroup) {\r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.items.length === 0) { return; }\r\n                for (var i = 0; i < parentGroup.items.length; i++) {   \r\n                    // func();\r\n                    //  var func();\r\n                    //  var thread func();\r\n                    //  thread func();\r\n                    // func() func();\r\n                    // func() thread func();\r\n                    // var func() thread func();\r\n                    // [[f]]() thread ttt();\r\n                    // ::getVar thread ttt();\r\n                    \r\n                    // variable or keyword or object reference (func call)\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    const childGroup2 = parentGroup.items.at(i + 1);\r\n                    if (childGroup2?.solved) { continue; } \r\n                    const childGroup3 = parentGroup.items.at(i + 2);\r\n                    const childGroup4 = parentGroup.items.at(i + 3);\r\n\r\n                    const typeOfUnknownToken2 = childGroup2?.getTypeOfUnknownToken();\r\n    \r\n                    // Allowed types that may appear before function call\r\n                    const allowedTypes = [\r\n                        GroupType.Identifier, GroupType.Reference, \r\n                        ...GscFileParser.functionCallTypes,\r\n                        GroupType.FunctionDereference, GroupType.FunctionPointer, GroupType.FunctionPointerExternal\r\n                    ];\r\n\r\n                    var group1_isVarReference = childGroup1.isUnsolvedGroupOfOneOfType(...allowedTypes);\r\n                    // Expressions may hide the inner groups, unwrap\r\n                    if (childGroup1.isUnsolvedGroupOfOneOfType(GroupType.Expression)) \r\n                    {\r\n                        const innerGroup = childGroup1.unwrapType(GroupType.Expression);\r\n                        group1_isVarReference = innerGroup.typeEqualsToOneOf(...allowedTypes);\r\n                    }\r\n                    const group2_isThread = childGroup2?.isReservedKeywordOfName(\"thread\") ?? false;\r\n                    const group3_isFuncCall = childGroup3?.isUnsolvedGroupOfOneOfType(GroupType.FunctionCall) ?? false;\r\n                    \r\n                    // var thread func()\r\n                    if (group1_isVarReference && group2_isThread && group3_isFuncCall) {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.FunctionCallWithObjectAndThread, 0, 0, childGroup1, childGroup2!, childGroup3!);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Reference); \r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2!, GroupType.ReservedKeyword);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup3!, GroupType.FunctionCall);\r\n                        i--; continue; // go to same index again\r\n                    }\r\n\r\n                    const group2_isCall = childGroup2?.isUnsolvedGroupOfOneOfType(GroupType.FunctionCall, GroupType.KeywordCall) ?? false;\r\n\r\n                    // var func();   or    var waittill();\r\n                    if (group1_isVarReference && group2_isCall) {\r\n                        const finalType = childGroup2!.type === GroupType.FunctionCall \r\n                            ? GroupType.FunctionCallWithObject\r\n                            : GroupType.KeywordCallWithObject;\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, childGroup1, childGroup2!);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Reference);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2!, undefined); // keep what it was\r\n                        i--; continue; // go to same index again\r\n                    }\r\n\r\n                    const group1_isThread = childGroup1.isReservedKeywordOfName(\"thread\");\r\n\r\n                    // thread func();\r\n                    if (group1_isThread && group2_isCall) {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.FunctionCallWithThread, 0, 0, childGroup1, childGroup2!);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.ReservedKeyword);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2!, GroupType.FunctionCall);\r\n                        i--; continue; // go to same index again\r\n                    }\r\n\r\n\r\n                    const group1_isObject = (typeEqualsToOneOf(childGroup1.type, \r\n                        GroupType.Identifier, GroupType.Reference, GroupType.Expression, ...GscFileParser.functionCallTypes) ||\r\n                        childGroup1.type === GroupType.Constant && childGroup1.getSingleTokenType() === TokenType.String);\r\n\r\n\r\n\r\n                    // level.aaa    level.aaa.bbb    (level).aaa     getarray().size   \"weapon_\".size   \r\n                    if (childGroup2 !== undefined && childGroup3 !== undefined && \r\n                        group1_isObject &&\r\n                        typeOfUnknownToken2 === TokenType.Structure &&\r\n                        childGroup3.type === GroupType.Identifier) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Reference, 0, 0, childGroup1, childGroup2, childGroup3);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Reference);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Token);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup3, GroupType.StructureField);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n    \r\n                    // game[]     level.aaa[]   (level.aaa)[]     getarray()[x]   \"weapon_\"[0]\r\n                    if (childGroup2 !== undefined && \r\n                        group1_isObject &&\r\n                        childGroup2.type === GroupType.Array && \r\n                        (childGroup2.items.length !== 1 || childGroup2.items[0].type !== GroupType.Array))  // ignore func dereference [[]]\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Reference, 0, 0, childGroup1, childGroup2);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Reference);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Array);\r\n                        // Everything inside [] consider as value, will be solved later\r\n                        if (childGroup2.items.length === 1) {\r\n                            changeGroupToSolvedAndChangeType(childGroup2, childGroup2.items[0], GroupType.Value);\r\n                        } else {\r\n                            const newGroup2 = groupItems(childGroup2, 0, GroupType.Value, 0, 0, ...childGroup2.items);\r\n                            newGroup2.solved = true;\r\n                        }\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n\r\n\r\n                }\r\n            });\r\n        }\r\n \r\n\r\n\r\n        function group_value_operations(rootGroup: GscGroup) {\r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.items.length === 0) { return; }\r\n                for (var i = 0; i < parentGroup.items.length; i++) {   \r\n                    \r\n                    // variable or keyword or object reference (func call)\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    const childGroup2 = parentGroup.items.at(i + 1);\r\n                    if (childGroup2?.solved) { continue; } \r\n                    const childGroup3 = parentGroup.items.at(i + 2);\r\n                    const childGroup4 = parentGroup.items.at(i + 3);\r\n\r\n                    const typeOfUnknownToken1 = childGroup1.getTypeOfUnknownToken();\r\n\r\n                    // !var1   !level.aaa   !(...)      ~var1\r\n                    if (typeOfUnknownToken1 === TokenType.OperatorLeft &&\r\n                        childGroup2?.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier))\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Value, 0, 0, childGroup1, childGroup2);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Token);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Value);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n\r\n                    const typeOfUnknownToken3 = childGroup3?.getTypeOfUnknownToken();\r\n                    const typeOfUnknownToken2 = childGroup2?.getTypeOfUnknownToken();\r\n\r\n                    // aaa && bbb     + - * / % < > == \r\n                    if (childGroup1.typeEqualsToOneOf(...GscFileParser.valueTypesWithIdentifier) &&\r\n                        typeOfUnknownToken2 === TokenType.Operator) \r\n                    {\r\n                        // If next tokens after operator needs to be joined first\r\n                        // aaa && !var1   aaa && !level.aaa   aaa && !(...)\r\n                        if (typeOfUnknownToken3 === TokenType.OperatorLeft &&\r\n                            childGroup4?.isUnsolvedGroupOfOneOfType(...GscFileParser.valueTypesWithIdentifier))\r\n                        {\r\n                            const newGroup = groupItems(parentGroup, i + 2, GroupType.Value, 0, 0, childGroup3!, childGroup4);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup3!, GroupType.Token);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup4, GroupType.Value);\r\n                            i--; continue; // go again to the same index\r\n                        }\r\n\r\n                        // If next tokens after operator needs to be joined first\r\n                        // %anim_file_name\r\n                        if (childGroup3?.getSingleToken()?.name === \"%\" && \r\n                            childGroup4?.typeEqualsToOneOf(GroupType.Identifier)) \r\n                        {\r\n                            const newGroup = groupItems(parentGroup, i+2, GroupType.Constant, 0, 0, childGroup3, childGroup4);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup3, GroupType.Token);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup4, GroupType.XAnim);\r\n                            i--; continue; // go again to the same index\r\n                        }\r\n\r\n                        if (childGroup3?.typeEqualsToOneOf(...GscFileParser.valueTypesWithIdentifier)) {\r\n                            const newGroup = groupItems(parentGroup, i, GroupType.Value, 0, 0, childGroup1, childGroup2!, childGroup3);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Value);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup2!, GroupType.Token);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup3!, GroupType.Value);\r\n                            i--; continue; // go again to the same index\r\n                        }\r\n                    }\r\n\r\n                    // %anim_file_name\r\n                    if (childGroup1.getSingleToken()?.name === \"%\" && \r\n                        childGroup2?.typeEqualsToOneOf(GroupType.Identifier)) \r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.Constant, 0, 0, childGroup1, childGroup2);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Token);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.XAnim);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_byKeyword(keywordNames: string[], finalType: GroupType, finalGroup1Type: GroupType | undefined) {        \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childTokenName = childGroup1.getSingleToken()?.name;//.toLocaleLowerCase();\r\n\r\n                    // return\r\n                    if (childGroup1.type === GroupType.ReservedKeyword && keywordNames.includes(childTokenName ?? \"\"))\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, childGroup1);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_byKeywordNameAndGroup(keywordNames: string[], groupTypesRight: GroupType[], finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined) {            \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (childGroup1.solved) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (childGroup2.solved) { continue; }\r\n                    var childTokenName = childGroup1.getSingleToken()?.name;//.toLocaleLowerCase();\r\n    \r\n                    // if ()\r\n                    if (childGroup1.type === GroupType.ReservedKeyword && keywordNames.includes(childTokenName ?? \"\") &&\r\n                        childGroup2.typeEqualsToOneOf(...groupTypesRight))\r\n                    {\r\n                        const newGroup = groupItems(parentGroup, i, finalType, 0, 0, childGroup1, childGroup2);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                        i--; continue; // go again to the same index\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_byKeywordAndGroupAndToken(keywordNamesLeft: string[], groupTypes: GroupType[], tokenType: TokenType, finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined, finalGroup3Type: GroupType | undefined) {            \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 2; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (!childGroup1.isReservedKeywordOfName(...keywordNamesLeft)) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (!childGroup2.isUnsolvedGroupOfOneOfType(...groupTypes)) { continue; }\r\n                    var childGroup3 = parentGroup.items[i + 2];\r\n                    if (!childGroup3.isUnknownUnsolvedSingleTokenOfOneOfType(tokenType)) { continue; }\r\n    \r\n                    const newGroup = groupItems(parentGroup, i, finalType, 0, 0, childGroup1, childGroup2, childGroup3);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup3, finalGroup3Type);\r\n                    i--; continue; // go again to the same index           \r\n                }\r\n            });\r\n        }\r\n\r\n        \r\n        function group_byKeywordAndToken(keywordNamesLeft: string[], tokenType: TokenType, finalType: GroupType, finalGroup1Type: GroupType | undefined, finalGroup2Type: GroupType | undefined) {            \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === finalType) { return; }\r\n                for (var i = 0; i < parentGroup.items.length - 1; i++) {\r\n                    var childGroup1 = parentGroup.items[i];\r\n                    if (!childGroup1.isReservedKeywordOfName(...keywordNamesLeft)) { continue; }\r\n                    var childGroup2 = parentGroup.items[i + 1];\r\n                    if (!childGroup2.isUnknownUnsolvedSingleTokenOfOneOfType(tokenType)) { continue; }\r\n    \r\n                    const newGroup = groupItems(parentGroup, i, finalType, 0, 0, childGroup1, childGroup2);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup1, finalGroup1Type);\r\n                    changeGroupToSolvedAndChangeType(newGroup, childGroup2, finalGroup2Type);\r\n                    i--; continue; // go again to the same index           \r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function group_declarations() {\r\n            const map = new Map<GroupType, GroupType>([\r\n                [GroupType.IfDeclaration, GroupType.IfScope],\r\n                [GroupType.ForDeclaration, GroupType.ForScope],\r\n                [GroupType.WhileDeclaration, GroupType.WhileScope],\r\n                [GroupType.SwitchDeclaration, GroupType.SwitchScope]\r\n            ]);      \r\n            walkGroup(rootGroup, (parentGroup) => { \r\n                if (parentGroup.type === GroupType.TerminatedStatement) { return; }\r\n                for (var i = parentGroup.items.length - 2; i >= 0; i--) {\r\n                    const childGroup1 = parentGroup.items[i];\r\n                    if (!childGroup1.isUnsolvedGroupOfOneOfType(...map.keys())) { continue; }\r\n                    const childGroup2 = parentGroup.items[i + 1];\r\n                    if (!childGroup2.isUnsolvedGroupOfOneOfType(GroupType.Scope, GroupType.TerminatedStatement, )) { continue; }\r\n                    const childGroup3 = parentGroup.items.at(i + 2);\r\n                    const childGroup4 = parentGroup.items.at(i + 3);\r\n\r\n                    if (childGroup1.type === GroupType.IfDeclaration && childGroup3 !== undefined && childGroup4 !== undefined && childGroup3.isReservedKeywordOfName(\"else\")) {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.TerminatedStatement, 0, 0, childGroup1, childGroup2, childGroup3, childGroup4);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.IfDeclaration);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.IfScope);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup3, GroupType.ReservedKeyword);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup4, GroupType.IfScope);\r\n                    }\r\n                    else {\r\n                        const newGroup = groupItems(parentGroup, i, GroupType.TerminatedStatement, 0, 0, childGroup1, childGroup2);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup1, undefined);\r\n                        changeGroupToSolvedAndChangeType(newGroup, childGroup2, map.get(childGroup1.type));    \r\n                    }\r\n\r\n                    i++; continue; // go again to the same index\r\n                }\r\n            });\r\n        }\r\n\r\n        function group_the_rest(group: GscGroup, parentGroup: GscGroup | undefined = undefined, lastFunctionScope: GscGroup | undefined = undefined) {   \r\n\r\n            if (group.type === GroupType.FunctionScope) {\r\n                lastFunctionScope = group;\r\n            }\r\n\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < group.items.length; i++) {\r\n                const innerGroup = group.items[i];\r\n                group_the_rest(innerGroup, group, lastFunctionScope);\r\n            }\r\n\r\n            switch (group.type as GroupType) {\r\n\r\n                case GroupType.Unknown:\r\n                    if (group.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.Semicolon)) {\r\n                        group.type = GroupType.Terminator;\r\n                        group.solved = false;\r\n                    }\r\n                    break;\r\n\r\n\r\n                case GroupType.DeveloperBlock:\r\n                    // Developer block inside function change to DeveloperBlockInner\r\n                    if (lastFunctionScope !== undefined) {\r\n                        group.type = GroupType.DeveloperBlockInner;\r\n                    }\r\n                    break;\r\n\r\n                case GroupType.ForExpression:\r\n                    // for (;;) is minimum\r\n                    if (group.items.length < 2) {\r\n                        group.solved = false;\r\n                        return;\r\n                    }\r\n                    // First join second argument Value and TerminatedStatement\r\n                    var paramPos = 0;\r\n                    for (var i = 0; i < group.items.length; i++) {\r\n                        const childGroup1 = group.items[i];\r\n                        childGroup1.solved = false; // reset solve status because TerminatedStatement is already solved\r\n\r\n                        // for (;;)                 Terminator          Terminator\r\n                        // for (;; i++)             Terminator          Terminator  TerminatedStatement\r\n                        // for (i = 1;;)            TerminatedStatement Terminator\r\n                        // for (; i < 5;)           TerminatedStatement Value       Terminator\r\n                        // for (; i < 5; i++)       TerminatedStatement Value       Terminator          TerminatedStatement   \r\n                        // for (i = 1; i < 5; i++)  TerminatedStatement Value       Terminator          TerminatedStatement\r\n\r\n                        // for (;)                  Terminator                      // excluded by (group.items.length < 2)\r\n                        // for (i = 1;)             TerminatedStatement             // excluded by (group.items.length < 2)\r\n                        // for (; i < 5)            TerminatedStatement Value\r\n                        // for (i = 1; i < 5)       TerminatedStatement Value\r\n\r\n\r\n                        if (paramPos === 0 && childGroup1.type === GroupType.TerminatedStatement) {\r\n                            changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.ForStatement);\r\n                            childGroup1.solved = true;\r\n                            paramPos++;\r\n\r\n                        } else if (paramPos === 0 && childGroup1.type === GroupType.Terminator) {\r\n                            const newGroup = groupItems(group, i, GroupType.ForStatement, 0, 0, childGroup1);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Terminator);\r\n                            newGroup.solved = true;\r\n                            paramPos++;\r\n\r\n                        // Change Value + TerminatedStatement (1+1)+(;) into single ForStatement\r\n                        } else if (paramPos === 1 && typeEqualsToOneOf(childGroup1.type, ...GscFileParser.valueTypesWithIdentifier)) {\r\n                            const childGroup2 = group.items.at(i + 1);\r\n                            if (childGroup2?.type === GroupType.Terminator) \r\n                            {\r\n                                const newGroup = groupItems(group, i, GroupType.ForStatement, 0, 0, childGroup1, childGroup2);\r\n                                childGroup1.solved = true;\r\n                                changeGroupToSolvedAndChangeType(newGroup, childGroup2, GroupType.Terminator);\r\n                                newGroup.solved = true;\r\n                            }\r\n                            paramPos++;\r\n\r\n                        } else if (paramPos === 1 && childGroup1.type === GroupType.Terminator) {\r\n                            const newGroup = groupItems(group, i, GroupType.ForStatement, 0, 0, childGroup1);\r\n                            changeGroupToSolvedAndChangeType(newGroup, childGroup1, GroupType.Terminator);\r\n                            newGroup.solved = true;\r\n                            paramPos++;\r\n\r\n                        } else if (paramPos === 2 && typeEqualsToOneOf(childGroup1.type, GroupType.Statement)) {\r\n                            changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.ForStatement);\r\n\r\n                        } else {\r\n                            paramPos++;\r\n                        }\r\n                    }\r\n                    if (paramPos >= 3) {\r\n                        group.solved = false;\r\n                        return;\r\n                    }\r\n                    break;\r\n\r\n            \r\n                case GroupType.SwitchScope:  \r\n                    // First join non-CaseLabel groups, so we end up only with CaseLabel and CaseScope groups\r\n                    var lastLabel = -1;\r\n                    for (var i = 0; i <= group.items.length; i++) {\r\n                        const childGroup1 = i === group.items.length ? undefined : group.items[i];                   \r\n                        if (lastLabel !== -1 && i > lastLabel + 1 && (childGroup1 === undefined || childGroup1.type === GroupType.CaseLabel)) {\r\n                            const groups = group.items.slice(lastLabel + 1, i);\r\n                            const newGroup = groupItems(group, lastLabel + 1, GroupType.CaseScope, 0, 0, ...groups);\r\n                            i -= groups.length;\r\n                            lastLabel = -1;\r\n                        }                      \r\n                        if (childGroup1 !== undefined && childGroup1.type === GroupType.CaseLabel) {\r\n                            lastLabel = i;\r\n                        }\r\n                    }\r\n\r\n                    // Validate scope always start with CaseLabel which is followed by another CaseLabel or CaseScope\r\n                    for (var i = 0; i < group.items.length; i++) {\r\n                        const childGroup1 = group.items[i];\r\n                        const childGroup2 = group.items.at(i + 1);    \r\n        \r\n                        // Label followed by label or scope is valid\r\n                        if (childGroup1.type === GroupType.CaseLabel && childGroup2?.type === GroupType.CaseLabel){\r\n                            childGroup1.solved = true;\r\n                            continue;\r\n\r\n                        // Label followed by another label is ok\r\n                        } else if (childGroup1.type === GroupType.CaseLabel && childGroup2?.type === GroupType.CaseScope) {\r\n                            childGroup1.solved = true;\r\n                            childGroup2.solved = true;\r\n                            i++;\r\n                            continue;\r\n\r\n                        // Label that is last, don't have any scope and is missing break; is also valid\r\n                        } else if (childGroup1.type === GroupType.CaseLabel && childGroup2 === undefined) {\r\n                            childGroup1.solved = true;\r\n                            continue;\r\n                        \r\n                        } else {\r\n                            childGroup1.solved = false;\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n            \r\n                case GroupType.FunctionParametersExpression:\r\n                    for (var i = 0; i < group.items.length; i++) {\r\n                        const childGroup1 = group.items[i];\r\n\r\n                        // Parameter\r\n                        if ((i % 2) === 0) {\r\n                            \r\n                            // Function definition\r\n                            if (lastFunctionScope === undefined && childGroup1.type === GroupType.Identifier) {                          \r\n                                childGroup1.type = GroupType.FunctionParameterName;\r\n                                childGroup1.solved = true;\r\n                                \r\n                            // Function call\r\n                            } else if (typeEqualsToOneOf(childGroup1.type, ...GscFileParser.valueTypesWithIdentifier)) {\r\n                                if (childGroup1.type === GroupType.Identifier) {\r\n                                    changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.Reference);\r\n                                } else {\r\n                                    childGroup1.solved = true;\r\n                                }\r\n                            }\r\n\r\n                        // Separator\r\n                        } else if (i + 1 < group.items.length) {\r\n                            if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator) && (i % 2) !== 0) {\r\n                                changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.Token);\r\n                            }\r\n                        }\r\n        \r\n                    } \r\n                    break;\r\n\r\n\r\n                case GroupType.KeywordParametersExpression:\r\n                    for (var i = 0; i < group.items.length; i++) {\r\n                        const childGroup1 = group.items[i];\r\n\r\n                        // Parameter\r\n                        if ((i % 2) === 0) {                           \r\n                            if (typeEqualsToOneOf(childGroup1.type, ...GscFileParser.valueTypesWithIdentifier)) {\r\n                                if (childGroup1.type === GroupType.Identifier) {\r\n                                    changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.Reference);\r\n                                } else {\r\n                                    childGroup1.solved = true;\r\n                                }\r\n                            }\r\n                        // Separator\r\n                        } else if (i + 1 < group.items.length) {\r\n                            if (childGroup1.isUnknownUnsolvedSingleTokenOfOneOfType(TokenType.ParameterSeparator) && (i % 2) !== 0) {\r\n                                changeGroupToSolvedAndChangeType(group, childGroup1, GroupType.Token);\r\n                            }\r\n                        }\r\n        \r\n                    } \r\n                    break;\r\n            \r\n\r\n                case GroupType.Expression:\r\n\r\n                    // (var1)\r\n                    if (group.items.length === 1 && group.items[0].type === GroupType.Identifier) {\r\n                        changeGroupToSolvedAndChangeType(group, group.items[0], GroupType.Reference);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function solve_unsolved(\r\n            group: GscGroup,\r\n            parentGroup: GscGroup | undefined = undefined,\r\n            lastFunctionScope: GscGroup | undefined = undefined, \r\n            lastDeveloperScope: GscGroup | undefined = undefined\r\n        )\r\n        {\r\n            for (var i = 0; i < group.items.length; i++) {\r\n                const innerGroup = group.items[i];\r\n                solve_unsolved(\r\n                    innerGroup, \r\n                    group, \r\n                    group.type === GroupType.FunctionScope ? group : lastFunctionScope, \r\n                    group.typeEqualsToOneOf(GroupType.DeveloperBlock, GroupType.DeveloperBlockInner) ? group : lastDeveloperScope\r\n                );        \r\n            }\r\n\r\n            \r\n            switch (group.type as GroupType) {\r\n\r\n                case GroupType.Root:\r\n                    //parentGroup.solved = true;\r\n                    break;\r\n\r\n                case GroupType.TerminatedPreprocessorStatement:\r\n                case GroupType.FunctionDefinition:\r\n                    if (parentGroup !== undefined && lastFunctionScope === undefined &&\r\n                        parentGroup.typeEqualsToOneOf(GroupType.Root, GroupType.DeveloperBlock)) {\r\n                        group.solved = true; \r\n                    }\r\n                    break;\r\n\r\n                case GroupType.DeveloperBlock:\r\n                    // In root\r\n                    group.solved = lastFunctionScope === undefined && lastDeveloperScope === undefined;\r\n                    break;\r\n\r\n                case GroupType.DeveloperBlockInner:\r\n                    // In function\r\n                    group.solved = lastFunctionScope !== undefined && lastDeveloperScope === undefined;\r\n                    break;\r\n\r\n                case GroupType.Scope:\r\n                case GroupType.TerminatedStatement:\r\n                case GroupType.Terminator:\r\n                    if (parentGroup !== undefined && (\r\n                        (parentGroup.typeEqualsToOneOf(...GscFileParser.scopeTypes) && parentGroup.type !== GroupType.SwitchScope) ||\r\n                        (parentGroup.type === GroupType.DeveloperBlockInner))) \r\n                    {\r\n                        if (group.type === GroupType.Terminator && group.solved === false) {\r\n                            group.type = GroupType.ExtraTerminator;\r\n                        }\r\n                        group.solved = true; \r\n                    }\r\n                    break;\r\n\r\n                case GroupType.Expression:\r\n\r\n                    // (( ))  Expression -> Expression!\r\n                    // ((0))  Expression -> Expression -> Constant\r\n                    if (group.items.length === 0) {\r\n                        group.solved = false;\r\n                    } else {\r\n                        if (group.items[0].typeEqualsToOneOf(...GscFileParser.valueTypes) && group.items[0].type !== GroupType.Expression) {\r\n                            group.items[0].solved = true;\r\n                        }\r\n                        if (lastFunctionScope !== undefined) {\r\n                            group.solved = true;\r\n                        }\r\n                    }\r\n                    \r\n\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n        // Create root tree item\r\n        var rootGroup = new GscGroup({\r\n            parent: undefined,\r\n            type: GroupType.Root,\r\n            tokenIndexStart: tokens.length > 0 ? 0 : -1,\r\n            tokenIndexEnd: tokens.length - 1\r\n        }, tokens);\r\n\r\n        // All tokens convert to tree item\r\n        var unsolvedTokens = tokens.map((f, i) => {\r\n            var group = new GscGroup({\r\n                parent: rootGroup,\r\n                type: GroupType.Unknown,\r\n                tokenIndexStart: i,\r\n                tokenIndexEnd: i\r\n            }, tokens);\r\n            return group;\r\n        });\r\n        rootGroup.items.push(...unsolvedTokens);\r\n\r\n\r\n        // https://en.cppreference.com/w/c/language/operator_precedence\r\n        \r\n\r\n        walkGroup(rootGroup, (group) => { \r\n            groupByBracketPairs(group, TokenType.DeveloperStart, TokenType.DeveloperEnd, GroupType.DeveloperBlock);\r\n        });\r\n        walkGroup(rootGroup, (group) => { \r\n            groupByBracketPairs(group, TokenType.ScopeStart, TokenType.ScopeEnd, GroupType.Scope);\r\n        });\r\n        walkGroup(rootGroup, (group) => { \r\n            groupByBracketPairs(group, TokenType.ExpressionStart, TokenType.ExpressionEnd, GroupType.Expression);\r\n        });\r\n        walkGroup(rootGroup, (group) => { \r\n            groupByBracketPairs(group, TokenType.ArrayStart, TokenType.ArrayEnd, GroupType.Array);\r\n        });\r\n\r\n\r\n        //console.log(this.debug(tokens, rootGroup, true));\r\n\r\n        \r\n        // Change numbers, strings, true, false etc.. into known types like Identifiers, Constant, ReservedKeywords\r\n        walkGroup(rootGroup, (group) => { change_singleUnknownTokens(group); });\r\n\r\n        // Join +1 -1  -.1  into value\r\n        walkGroup(rootGroup, (group) => { group_numberSign(group); });\r\n\r\n        // Join path - maps\\mp\\aaa\r\n        walkGroup(rootGroup, (group) => { group_path(group); });\r\n\r\n\r\n\r\n\r\n        // Preprocessors\r\n        group_byKeywordNameAndGroup([\"#include\"], [GroupType.Path],\r\n            GroupType.PreprocessorStatement, GroupType.ReservedKeyword, GroupType.Path);\r\n        group_byKeywordNameAndGroup([\"#using_animtree\"], [GroupType.Expression],\r\n            GroupType.PreprocessorStatement, GroupType.ReservedKeyword, GroupType.PreprocessorAnimtreeParametersExpression);\r\n        group_byKeyword([\"#animtree\"], GroupType.Constant, GroupType.ReservedKeyword);\r\n\r\n        \r\n\r\n        // Join function pointer dereference, which consists of 2 inner array and expression\r\n        // [[funcPointer]]()\r\n        group_functionPointerDereference();\r\n\r\n\r\n\r\n        // Join function call = function name + expression\r\n        // CountPlayers()\r\n        group_byGroupAndGroup([GroupType.Identifier], [GroupType.Expression], \r\n            GroupType.FunctionCall, GroupType.FunctionName, GroupType.FunctionParametersExpression);\r\n\r\n        // Join function call = path + function call\r\n        // maps\\mp\\gametypes\\_teams::CountPlayers()\r\n        group_byGroupAndTokenAndGroup([GroupType.Path], TokenType.FunctionPointer, [GroupType.FunctionCall], \r\n            GroupType.FunctionCall, GroupType.Path, GroupType.Token, GroupType.FunctionCall);\r\n\r\n\r\n\r\n        // Join keyword call = keyword + expression\r\n        // waittill (\"abc\", ...)\r\n        const keywordsWithExpressionAndVar = [\"waittill\", \"waittillmatch\", \"notify\", \"endon\"];\r\n        group_byKeywordNameAndGroup(keywordsWithExpressionAndVar, [GroupType.Expression], \r\n            GroupType.KeywordCall, GroupType.ReservedKeyword, GroupType.KeywordParametersExpression);\r\n\r\n\r\n\r\n        // if ()\r\n        group_byKeywordNameAndGroup([\"if\"], [GroupType.Expression], \r\n            GroupType.IfDeclaration, GroupType.ReservedKeyword, GroupType.Expression);\r\n        // for ()\r\n        group_byKeywordNameAndGroup([\"for\"], [GroupType.Expression], \r\n            GroupType.ForDeclaration, GroupType.ReservedKeyword, GroupType.ForExpression);\r\n        // while ()\r\n        group_byKeywordNameAndGroup([\"while\"], [GroupType.Expression], \r\n            GroupType.WhileDeclaration, GroupType.ReservedKeyword, GroupType.Expression);\r\n        // switch ()\r\n        group_byKeywordNameAndGroup([\"switch\"], [GroupType.Expression], \r\n            GroupType.SwitchDeclaration, GroupType.ReservedKeyword, GroupType.Expression);\r\n\r\n\r\n        // case \"aaa\":\r\n        group_byKeywordAndGroupAndToken([\"case\"], [GroupType.Constant], TokenType.Case, \r\n            GroupType.CaseLabel, GroupType.ReservedKeyword, GroupType.Constant, GroupType.Token);\r\n        // default:\r\n        group_byKeywordAndToken([\"default\"], TokenType.Case,\r\n            GroupType.CaseLabel, GroupType.ReservedKeyword, GroupType.Token);\r\n\r\n\r\n\r\n        // ::CountPlayers\r\n        group_byTokenAndGroup(TokenType.FunctionPointer, [GroupType.Identifier], \r\n            GroupType.FunctionPointer, GroupType.Token, GroupType.FunctionName );\r\n\r\n        // maps\\mp\\gametypes\\_teams::CountPlayers\r\n        group_byGroupAndGroup([GroupType.Path], [GroupType.FunctionPointer],\r\n            GroupType.FunctionPointerExternal, GroupType.Path, GroupType.FunctionPointer);\r\n        \r\n\r\n\r\n        // Join variables - level.aaa  game[\"aaa\"] \r\n        // thread {FunctionCall}            ->   thread CountPlayers()\r\n        // var1 {FunctionCall}              ->   var1 CountPlayers()\r\n        // var1 {FunctionCallWithThread}    ->   var1 thread CountPlayers()\r\n        group_variables_and_function_call(rootGroup);\r\n \r\n        // Join operations\r\n        // !var1   !level.aaa   !(...)   ~var1   aaa && !var1   aaa && !level.aaa   aaa && !(...)  aaa && bbb  %anim_file_name\r\n        group_value_operations(rootGroup);\r\n\r\n\r\n\r\n        // Change expression with 3 parameters to vector -> (0, 0, 0)\r\n        walkGroup(rootGroup, (group) => { change_expressionToVector(group); }); \r\n\r\n\r\n\r\n        // Assignment\r\n\r\n        // aaa = (...)\r\n        group_byGroupAndTokenAndGroup([GroupType.Identifier, GroupType.Reference], TokenType.Assignment, GscFileParser.valueTypesWithIdentifier, \r\n            GroupType.Statement, GroupType.Reference, GroupType.Token, GroupType.Value);\r\n        \r\n        // aaa += (...)\r\n        group_byGroupAndTokenAndGroup([GroupType.Identifier, GroupType.Reference], TokenType.Assignment2, GscFileParser.valueTypesWithIdentifier, \r\n            GroupType.Statement, GroupType.Reference, GroupType.Token, GroupType.Value);\r\n\r\n        // level.aaa++\r\n        group_byGroupAndToken([GroupType.Identifier, GroupType.Reference], TokenType.Assignment3, \r\n            GroupType.Statement, GroupType.Reference, GroupType.Token);\r\n\r\n\r\n\r\n\r\n        // return {Value}\r\n        group_byKeywordNameAndGroup([\"return\"], GscFileParser.valueTypesWithIdentifier, \r\n            GroupType.Statement, GroupType.ReservedKeyword, GroupType.Value);\r\n                         \r\n        // wait 0.1\r\n        group_byKeywordNameAndGroup([\"wait\"], GscFileParser.valueTypesWithIdentifier, \r\n            GroupType.Statement, GroupType.ReservedKeyword, GroupType.Value);\r\n\r\n        // Single keywords\r\n        // return     \r\n        // waittillframeend\r\n        // break\r\n        // waittillframeend\r\n        group_byKeyword([\"return\", \"break\", \"continue\", \"waittillframeend\", \"breakpoint\"], GroupType.Statement, GroupType.ReservedKeyword);\r\n                \r\n\r\n\r\n        // statement;\r\n        const terminationNeededFor = [GroupType.Statement, ...GscFileParser.functionCallTypes,\r\n            GroupType.KeywordCall, GroupType.KeywordCallWithObject];\r\n        group_byGroupAndToken(terminationNeededFor, TokenType.Semicolon, \r\n            GroupType.TerminatedStatement, GroupType.Statement, GroupType.Terminator);\r\n\r\n        // preprocessor;\r\n        group_byGroupAndToken([GroupType.PreprocessorStatement], TokenType.Semicolon, \r\n            GroupType.TerminatedPreprocessorStatement, GroupType.PreprocessorStatement, GroupType.Terminator);\r\n\r\n\r\n        // Declaration join\r\n        // if() {} else\r\n        // for (...) {}       \r\n        // for (...) var1=1;\r\n        group_declarations();\r\n\r\n        \r\n\r\n        // Function definition\r\n        // {FunctionCall} {Scope}    ->  funcName() { ... }\r\n        group_byGroupAndGroup([GroupType.FunctionCall], [GroupType.Scope], \r\n            GroupType.FunctionDefinition, GroupType.FunctionDeclaration, GroupType.FunctionScope);\r\n\r\n\r\n        group_the_rest(rootGroup);\r\n\r\n\r\n\r\n        solve_unsolved(rootGroup);\r\n\r\n\r\n\r\n        //console.log(this.debugGroupAsObject(tokens, rootGroup));\r\n        //console.warn(\"- finished -\");\r\n\r\n\r\n        return rootGroup;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Analyze the data structure tree and save it. Analyzed stuff:\r\n     *  - function definitions\r\n     *  - variable definitions\r\n     * @param rootGroup The root tree of data structure tree\r\n     * @returns Data containing info about functions, global and local variables, etc...\r\n     */\r\n    public static analyze(rootGroup: GscGroup, content: string): GscData {\r\n\r\n        var data = new GscData(rootGroup, content);\r\n\r\n        walkGroupItems(rootGroup, rootGroup.items);\r\n\r\n        function walkGroupItems(\r\n            parentGroup: GscGroup, \r\n            items: GscGroup[],\r\n            lastFunction: GscFunction | undefined = undefined) \r\n        {\r\n            for (var i = 0; i < items.length; i++) {\r\n                var innerGroup = items[i];\r\n\r\n                var func: GscFunction | undefined = undefined;\r\n\r\n                switch (innerGroup.type as GroupType) {\r\n\r\n                    // Save #include path\r\n                    case GroupType.Path:\r\n                        if (parentGroup.type === GroupType.PreprocessorStatement &&\r\n                            parentGroup.getFirstToken().name === \"#include\") \r\n                        {\r\n                            data.includes.push(innerGroup.getTokensAsString());\r\n                        }\r\n                        break;\r\n\r\n                    // Save functions\r\n                    case GroupType.FunctionDefinition:\r\n                        if (innerGroup.items.length === 2 && // declaration and scope\r\n                            innerGroup.items[0].type === GroupType.FunctionDeclaration &&\r\n                            innerGroup.items[0].items.length === 2 && // function name and parameters\r\n                            innerGroup.items[0].items[0].type === GroupType.FunctionName &&\r\n                            innerGroup.items[0].items[1].type === GroupType.FunctionParametersExpression &&\r\n                            innerGroup.items[1].type === GroupType.FunctionScope\r\n                        ) {\r\n                            const paramTokens: GscToken[] = [];\r\n                            for (let i = 0; i < innerGroup.items[0].items[1].items.length; i += 2) {\r\n                                const element = innerGroup.items[0].items[1].items[i];\r\n                                if (element.type === GroupType.FunctionParameterName) {\r\n                                    paramTokens.push(element.getSingleToken()!);\r\n                                }\r\n                            }\r\n                            func = {\r\n                                name: innerGroup.items[0].items[0].getSingleToken()!.name,\r\n                                parameters: paramTokens,\r\n                                localVariableDefinitions: [],\r\n                                range: innerGroup.getRange(),\r\n                                scopeRange: innerGroup.items[1].getRange()\r\n                            };\r\n\r\n\r\n                            data.functions.push(func);\r\n                        }                                 \r\n                        break;\r\n\r\n                    // Save variable definitions\r\n                    case GroupType.Statement:\r\n\r\n                        // varName = ...;    varNameStruct.aaa = ...;\r\n                        if (lastFunction !== undefined && innerGroup.items.length >= 2 &&\r\n                            innerGroup.items[0].type === GroupType.Reference &&\r\n                            innerGroup.items[0].items.length >= 1 &&\r\n                            innerGroup.items[1].type === GroupType.Token &&\r\n                            innerGroup.items[1].getFirstToken().type === TokenType.Assignment)  // =\r\n                        {\r\n                            const variableReference = innerGroup.items[0];\r\n                            const firstToken = variableReference.getFirstToken();\r\n\r\n                            if (firstToken.name === \"level\") {\r\n                                addDefinition(data.levelVariablesDefinitions, variableReference);\r\n                            } else if (firstToken.name === \"game\") {\r\n                                addDefinition(data.gameVariablesDefinitions, variableReference);\r\n                            } else {\r\n                                // Arrays does not have to be explicitly defined like 'aaa = [];', \r\n                                // Expression like 'aaa[0] = 1;' means that aaa is defined as array\r\n                                const otherReferences: GscGroup[] = [];\r\n                                var currentGroup = variableReference;\r\n                                while (currentGroup.items.at(1)?.type === GroupType.Array) {\r\n                                    otherReferences.unshift(currentGroup.items[0]);\r\n                                    currentGroup = currentGroup.items[0];\r\n                                }\r\n                                otherReferences.forEach(r => \r\n                                    addDefinition(lastFunction.localVariableDefinitions, r, GscVariableDefinitionType.Array)\r\n                                );                       \r\n                                addDefinition(lastFunction.localVariableDefinitions, variableReference);\r\n                            }\r\n\r\n                            function addDefinition(\r\n                                array: GscVariableDefinition[],\r\n                                variableReference: GscGroup,\r\n                                type: GscVariableDefinitionType = GscVariableDefinitionType.Unknown) \r\n                            {\r\n                                var variableDefinition: GscVariableDefinition = {\r\n                                    variableReference: variableReference,\r\n                                    type: type\r\n                                };\r\n\r\n                                array.push(variableDefinition);\r\n\r\n                                // If type is not resolved yet, determine it from assigned value\r\n                                if (type === GscVariableDefinitionType.Unknown) {\r\n                                    const valueGroup = innerGroup.items.at(2);\r\n        \r\n                                    switch (valueGroup?.type) {\r\n                                        case GroupType.Constant:\r\n                                            const token = valueGroup.getFirstToken();\r\n                                            switch (token.type) {\r\n                                                case TokenType.Array:\r\n                                                    variableDefinition.type = GscVariableDefinitionType.Array; break;\r\n                                                case TokenType.String:\r\n                                                    variableDefinition.type = GscVariableDefinitionType.String; break;\r\n                                                case TokenType.LocalizedString:\r\n                                                    variableDefinition.type = GscVariableDefinitionType.LocalizedString; break;\r\n                                                case TokenType.CvarString:\r\n                                                    variableDefinition.type = GscVariableDefinitionType.CvarString; break;  \r\n                                                case TokenType.Number:\r\n                                                    const isFloat = token.name.includes(\".\");\r\n                                                    variableDefinition.type = isFloat ? GscVariableDefinitionType.Float : GscVariableDefinitionType.Integer; break;\r\n\r\n                                                case TokenType.Keyword:\r\n                                                    switch (token.name) {\r\n                                                        case \"undefined\":\r\n                                                            variableDefinition.type = GscVariableDefinitionType.Undefined;\r\n                                                            break;\r\n                                                        case \"true\":\r\n                                                        case \"false\":\r\n                                                            variableDefinition.type = GscVariableDefinitionType.Bool;\r\n                                                            break;\r\n                                                    }\r\n                                                    break;                                         \r\n                                                // #animtree \r\n                                                case TokenType.Preprocessor:\r\n                                                    if (token.name === \"#animtree\") {\r\n                                                        variableDefinition.type = GscVariableDefinitionType.XAnim; \r\n                                                    }\r\n                                                    break;\r\n                                                // %anim_file_name\r\n                                                case TokenType.Operator:\r\n                                                    if (valueGroup.items.length === 2 && valueGroup.items[1].type === GroupType.XAnim) {\r\n                                                        variableDefinition.type = GscVariableDefinitionType.XAnim; \r\n                                                    }\r\n                                                    break;\r\n                                            }\r\n                                            break;\r\n        \r\n                                        case GroupType.FunctionPointer:\r\n                                        case GroupType.FunctionPointerExternal:\r\n                                            variableDefinition.type = GscVariableDefinitionType.Function;\r\n                                            break;\r\n    \r\n                                        case GroupType.Vector:\r\n                                            variableDefinition.type = GscVariableDefinitionType.Vector;\r\n                                            break;\r\n        \r\n                                        case GroupType.Value:\r\n                                            variableDefinition.type = GscVariableDefinitionType.UnknownValue;\r\n                                            break;\r\n        \r\n                                        case GroupType.Reference:\r\n                                            variableDefinition.type = GscVariableDefinitionType.UnknownValueFromVariable;\r\n                                            break;\r\n            \r\n                                        case GroupType.FunctionCall:\r\n                                            const funcName = valueGroup.items.at(0)?.getFirstToken();\r\n                                            if (funcName !== undefined) {\r\n                                                switch (funcName.name.toLowerCase()) {\r\n                                                    case \"spawnstruct\":\r\n                                                        variableDefinition.type = GscVariableDefinitionType.Structure;\r\n                                                        break;\r\n                                                    case \"spawn\":\r\n                                                        variableDefinition.type = GscVariableDefinitionType.Entity;\r\n                                                        break;\r\n                                                    case \"getdvar\":\r\n                                                        variableDefinition.type = GscVariableDefinitionType.String;\r\n                                                        break;\r\n                                                    default:\r\n                                                        variableDefinition.type = GscVariableDefinitionType.UnknownValueFromFunction;\r\n                                                        break;\r\n                                                }\r\n                                                \r\n                                            }\r\n                                            break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                        \r\n                        break;\r\n                }\r\n\r\n                walkGroupItems(innerGroup, innerGroup.items, func ?? lastFunction);\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n\r\n\r\n    public static debugGroupAsObject(tokens: GscToken[], currentGroup: GscGroup): debugObject {\r\n        \r\n        var type = \"\" + GroupType[currentGroup.type];     \r\n        if (currentGroup.tokenIndexEnd - currentGroup.tokenIndexStart <= 2) {\r\n            type += \"   (\" + tokens.slice(currentGroup.tokenIndexStart, currentGroup.tokenIndexEnd+1).map(f => TokenType[f.type]).join(\" \") + \")\";\r\n        }\r\n\r\n        var tkns = \"(\" + currentGroup.tokenIndexStart + \" - \" + currentGroup.tokenIndexEnd + \")  ->  \" + \r\n        tokens.slice(currentGroup.tokenIndexStart, currentGroup.tokenIndexEnd+1).map(f => f.name).join(\" \") + \"\";\r\n\r\n\r\n        var data: debugObject = {\r\n            a03_unsolved: (currentGroup.solved) ? undefined : \"!!! UNSOLVED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\",\r\n            a04_deadCode: (!currentGroup.deadCode) ? undefined : \"!!! DEADCODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\",\r\n            a01_type: type,\r\n            a02_tokens: tkns,\r\n            a06_itemsArray: []\r\n        };                        \r\n        \r\n        for (let item of currentGroup.items) {\r\n            const itemDebug = this.debugGroupAsObject(tokens, item);\r\n            data.a06_itemsArray.push(itemDebug);\r\n        }\r\n        \r\n        return data;\r\n    }\r\n\r\n\r\n    \r\n   \r\n    public static debugAsString(tokens: GscToken[], rootGroup: GscGroup, printChilds: boolean, startGroup: GscGroup | undefined = undefined): string {\r\n        var s: string[] = [];\r\n        function write(text: string) {\r\n            s.push(text);\r\n        }\r\n        function writeLine(text: string) {\r\n            write(text + \"\\n\");\r\n        }\r\n        \r\n        //writeLine(\"--------------------------------------------------------------\");\r\n        //writeLine(\"tokens: \" + tokens.length + \" [\" +  tokens.map(f => f.name).join(\" \") + \"]\");\r\n        //writeLine(\"--------------------------------------------------------------\");\r\n\r\n        write(this.debugGroupAsString(tokens, undefined, rootGroup, 0, printChilds, startGroup));\r\n\r\n        writeLine(\"--------------------------------------------------------------\");\r\n\r\n        return s.join(\"\");\r\n    }\r\n\r\n\r\n    public static debugGroupAsString(tokens: GscToken[], parentGroup: GscGroup | undefined, currentGroup: GscGroup, level: number, printChilds: boolean, startGroup: GscGroup | undefined = undefined): string {\r\n        var s: string[] = [];\r\n        var startGroupFound: boolean = false;\r\n\r\n        function write(text: string) {\r\n            s.push(text);\r\n        }\r\n        function writeLine(text: string) {\r\n            write(text + \"\\n\");\r\n        }\r\n        \r\n        //var spaces1 = \".    \".repeat((level+1)/2);\r\n        //var spaces2 = \".    \".repeat((level+1)/2) + \".  \";\r\n\r\n        var spaces1 = \".  \".repeat((level+1)/2);\r\n        var spaces2 = \".  \".repeat((level+1)/2) + \". \";\r\n\r\n        if (startGroup !== undefined && startGroupFound === false) {\r\n            writeLine(spaces1 + GroupType[currentGroup.type] + \" (\"+currentGroup.tokenIndexStart + \" - \" + currentGroup.tokenIndexEnd + \"):\");\r\n        }\r\n\r\n        if (startGroup !== undefined && currentGroup !== startGroup) {\r\n            for (let item of currentGroup.items) {\r\n                write(this.debugGroupAsString(tokens, currentGroup, item, level + 2, printChilds, startGroup));\r\n            }\r\n            return s.join(\"\");\r\n        } else if (currentGroup === startGroup) {\r\n            startGroupFound = true;\r\n        }\r\n\r\n        //var spaces2 = new Array((level+1) * 2 + 1).join(' ');\r\n        writeLine(spaces1 + \"{\");\r\n       \r\n        // writeLine(spaces2 + \"solved: \" + currentGroup.solved);\r\n        if (!currentGroup.solved) {\r\n            writeLine(spaces2 + \"!!! UNSOLVED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n        }\r\n\r\n        // writeLine(spaces2 + \"deadCode: \" + currentGroup.deadCode);\r\n        if (currentGroup.deadCode) {\r\n            writeLine(spaces2 + \"!!! DEADCODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n        }\r\n\r\n        if (currentGroup.parent !== parentGroup) {\r\n            writeLine(spaces2 + \"!!! PARENT MISMATCH !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n        }\r\n\r\n        write(spaces2 + \"type: \" + GroupType[currentGroup.type]);\r\n        if (currentGroup.tokenIndexEnd - currentGroup.tokenIndexStart <= 3) {\r\n            write(\"   (\" + \r\n                tokens.slice(currentGroup.tokenIndexStart, currentGroup.tokenIndexEnd+1).map(f => TokenType[f.type]).join(\" \") + \")\");\r\n        }\r\n        writeLine(\"\");\r\n\r\n        writeLine(spaces2 + \"tokens: \" + \r\n                            \"(\"+currentGroup.tokenIndexStart + \" - \" + currentGroup.tokenIndexEnd + \")  ->  \" + \r\n                            tokens.slice(currentGroup.tokenIndexStart, currentGroup.tokenIndexEnd+1).map(f => f.name).join(\" \") + \"\");\r\n        \r\n\r\n        if (currentGroup.tokenIndexStart >= 0 && currentGroup.tokenIndexEnd >= 0 ) {\r\n            writeLine(spaces2 + \"range: (\" + \r\n            \"L:\" + tokens[currentGroup.tokenIndexStart].range.start.line + \" \" +\r\n            \"C:\" + tokens[currentGroup.tokenIndexStart].range.start.character + \"\" +\r\n            \" - \" +\r\n            \"L:\" + tokens[currentGroup.tokenIndexEnd].range.end.line + \" \" +\r\n            \"C:\" + tokens[currentGroup.tokenIndexEnd].range.end.character + \")\");\r\n        }\r\n\r\n \r\n        \r\n\r\n                            \r\n        \r\n        if (currentGroup.items.length > 0) {\r\n            writeLine(spaces2 + \"items: (\" + currentGroup.items.length + \")\");\r\n            if (printChilds) {\r\n                writeLine(spaces2 + \"[\");\r\n                for (let item of currentGroup.items) {\r\n                    write(this.debugGroupAsString(tokens, currentGroup, item, level + 2, printChilds, startGroup));\r\n                }\r\n                writeLine(spaces2 + \"]\");\r\n            }\r\n        }\r\n        writeLine(spaces1 + \"},\");\r\n\r\n        return s.join(\"\");\r\n    }\r\n\r\n\r\n\r\n    public static generateTestChecks(tokens: GscToken[], rootGroup: GscGroup): string {\r\n\r\n        var s: string[] = [];\r\n\r\n        walkGroup(rootGroup, \"checkGroup2(rootGroup, rootGroup\");\r\n\r\n        function walkGroup(currentGroup: GscGroup, prefix: string) {\r\n            s.push(prefix);\r\n            s.push(\", \");\r\n            s.push(\"GroupType.\");\r\n            s.push(GroupType[currentGroup.type]);\r\n            s.push(\", \");\r\n            s.push(currentGroup.tokenIndexStart.toString());\r\n            s.push(\", \");\r\n            s.push(currentGroup.tokenIndexEnd.toString());\r\n            s.push(\", \");\r\n            s.push(currentGroup.solved ? \"true\" : \"false\");\r\n            s.push(\", \");\r\n            s.push(currentGroup.items.length.toString());/*\r\n            s.push(\", \");\r\n            s.push(currentGroup.deadCode ? \"true\" : \"false\");*/\r\n            s.push(\");\\n\");\r\n            \r\n            for (var i = 0; i < currentGroup.items.length; i++) {\r\n                walkGroup(currentGroup.items[i], prefix + \".items[\" + i + \"]\");\r\n            }\r\n        }\r\n        return s.join(\"\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport interface GscToken {\r\n    index: number;\r\n    name: string;\r\n    type: TokenType;\r\n    offset: number;\r\n    range: vscode.Range;\r\n    commentBefore?: string;\r\n}\r\n\r\nexport enum TokenType {\r\n    Unknown,\r\n    DeveloperStart,\r\n    DeveloperEnd,\r\n    Preprocessor,\r\n    /** Char '{' */\r\n    ScopeStart,\r\n    /** Char '}' */\r\n    ScopeEnd,\r\n    /** Char '(' */\r\n    ExpressionStart,\r\n    /** Char ')' */\r\n    ExpressionEnd,\r\n    /** Char '[' */\r\n    ArrayStart,\r\n    /** Char ']' */\r\n    ArrayEnd,\r\n\r\n    /** Char '.' */\r\n    Structure,\r\n    /** Char '\\\\' */\r\n    PathSeparator,\r\n    /** Chars '::' */\r\n    FunctionPointer,\r\n    /** Char ',' */\r\n    ParameterSeparator,\r\n    /** Char ':' */\r\n    Case,\r\n\r\n    /** Char '=' */\r\n    Assignment,\r\n    /** Char '+=', '-=', '*=', '/=', '%=', '|=', '&=', '^=' */\r\n    Assignment2,\r\n    /** Right-sided operators - chars '++', '--' */\r\n    Assignment3,\r\n\r\n    /** 2-sided operators - chars ('+', '-','*', '/', '%'),   ('|', '&', '^', '<<', '>>')   ('==', '!=', '<', '>', '<=', '>=', '&&', '||')   */\r\n    Operator,\r\n    /** Left-sided operator - char '!', '~' */\r\n    OperatorLeft,\r\n\r\n    /** Char ';' */\r\n    Semicolon,\r\n\r\n    String,\r\n    /** Like &\"STRING_ABC\" */\r\n    LocalizedString,\r\n    /** Like #\"sv_running\" - only for COD:BO1 */\r\n    CvarString,\r\n\r\n    Number,\r\n    /** Char '[]' */\r\n    Array,\r\n    Keyword,\r\n\r\n    /* Char # */\r\n    Hashtag\r\n}\r\n\r\nenum Level {\r\n    Default,\r\n    SingleLineComment,\r\n    MultiLineComment,\r\n    PreprocessorName,\r\n    String,\r\n    LocalizedString,\r\n    CvarString,\r\n    Number,\r\n    Float,\r\n    Keyword\r\n}\r\n\r\n\r\n\r\n\r\nexport class GscGroup {\r\n    //public readonly debug: string;\r\n    public parent: GscGroup | undefined;\r\n    public readonly items: GscGroup[] = [];\r\n    public type: GroupType;\r\n    public tokenIndexStart: number;\r\n    public tokenIndexEnd: number;\r\n    public solved: boolean = false;\r\n    public deadCode: boolean = false;\r\n\r\n    public readonly tokensAll: GscToken[];\r\n\r\n    constructor({parent, type, tokenIndexStart, tokenIndexEnd}: {parent: GscGroup | undefined, type: GroupType, tokenIndexStart: number, tokenIndexEnd: number},\r\n                tokens: GscToken[]) {\r\n        this.parent = parent;\r\n        this.type = type;\r\n        this.tokenIndexStart = tokenIndexStart;\r\n        this.tokenIndexEnd = tokenIndexEnd;\r\n        this.tokensAll = tokens;\r\n        //this.debug = this.toString();\r\n    }\r\n\r\n    public getSingleToken(): GscToken | undefined {\r\n        if (this.tokenIndexStart === this.tokenIndexEnd && this.items.length === 0) {\r\n            return this.tokensAll[this.tokenIndexStart];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    public getUnknownToken(): GscToken | undefined {\r\n        if (this.tokenIndexStart === this.tokenIndexEnd && this.items.length === 0 && this.type === GroupType.Unknown) {\r\n            return this.tokensAll[this.tokenIndexStart];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    public getFirstToken(): GscToken {\r\n        return this.tokensAll[this.tokenIndexStart];\r\n    }\r\n\r\n    public getTypeOfUnknownToken(): TokenType | undefined {\r\n        return this.getUnknownToken()?.type;\r\n    }\r\n\r\n    public getSingleTokenType(): TokenType | undefined {\r\n        return this.getSingleToken()?.type;\r\n    }\r\n\r\n    public isUnknownUnsolvedSingleTokenOfOneOfType(...type: TokenType[]): boolean {\r\n        if (this.tokenIndexStart === this.tokenIndexEnd && this.items.length === 0 && this.type === GroupType.Unknown && this.solved === false) {\r\n            return type.includes(this.tokensAll[this.tokenIndexStart].type);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public isUnsolvedSingleTokenOfOneOfType(...type: TokenType[]): boolean {\r\n        if (this.tokenIndexStart === this.tokenIndexEnd && this.items.length === 0 && this.solved === false) {\r\n            return type.includes(this.tokensAll[this.tokenIndexStart].type);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public isUnsolvedGroupOfOneOfType(...type: GroupType[]): boolean {\r\n        if (this.solved === false) {\r\n            return type.includes(this.type);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public isReservedKeywordOfName(...names: string[]): boolean {\r\n        if (this.type === GroupType.ReservedKeyword) {\r\n            const name = this.getSingleToken()?.name;\r\n            if (name === undefined) { return false; }\r\n            return names.includes(name);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public typeEqualsToOneOf(...groups: GroupType[]) {\r\n        if (this.type === undefined) { return false; }\r\n        return groups.includes(this.type);\r\n    }\r\n\r\n    public getRange(): vscode.Range {\r\n        return new vscode.Range(this.tokensAll[this.tokenIndexStart].range.start, this.tokensAll[this.tokenIndexEnd].range.end);\r\n    }\r\n\r\n\r\n    public getIndex(): number | undefined {\r\n        if (this.parent === undefined) {\r\n            return undefined;\r\n        }\r\n        var index = this.parent.items.indexOf(this);\r\n        if (index === -1) {\r\n            return undefined;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    public findLastParentInSequenceOfType(type: GroupType): GscGroup | undefined {\r\n        var group = this as GscGroup;\r\n        while (group.parent?.type === type) {\r\n            group = group.parent;\r\n        }\r\n        if (group.type === type) {\r\n            return group;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n\r\n    public findParentOfType(...type: GroupType[]): GscGroup | undefined {\r\n        var group: GscGroup | undefined = this as GscGroup;\r\n        while (group?.parent !== undefined && !type.includes(group?.parent.type)) {\r\n            group = group.parent;\r\n        }\r\n        if (group?.parent !== undefined && type.includes(group?.parent.type)) {\r\n            return group?.parent;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n\r\n    public unwrapType(type: GroupType): GscGroup {\r\n        var group = this as GscGroup;\r\n        while (group.type === type && group.items.length === 1) {\r\n            group = group.items[0];\r\n        }\r\n        return group;\r\n    }\r\n\r\n\r\n    public findGroupOnLeftAtPosition(position: vscode.Position, lastGroup: GscGroup | undefined = undefined, level: number = 0): GscGroup | undefined {\r\n\r\n        // Create an array of ranges and related group\r\n        const items = this.items.map(t => { \r\n            return {\r\n                range: t.getRange(),\r\n                group: t,\r\n                isTrueGroup: true\r\n            };\r\n        } );\r\n\r\n        // If last child node does not end with with the same token as the parent, add it into array\r\n        // Scopes like {} [] () does not have their tokens defined\r\n        const lastChildGroup = this.items.at(-1);\r\n        if (lastChildGroup !== undefined) {\r\n            for (var i = lastChildGroup.tokenIndexEnd + 1; i <= this.tokenIndexEnd; i++) {\r\n                items.push({\r\n                    range: this.tokensAll[i].range, \r\n                    group: this,\r\n                    isTrueGroup: false\r\n                });\r\n            }\r\n        }\r\n\r\n        for (var data of items) {\r\n            const range = data.range;\r\n\r\n            if (range.end.isBeforeOrEqual(position) && \r\n               (lastGroup === undefined || (range.start.isAfterOrEqual(lastGroup.getRange().start)))) {\r\n                lastGroup = data.group;\r\n            }\r\n\r\n            //if (range.contains(position)) {\r\n            if (((position.line === range.start.line && position.character > range.start.character) || position.line > range.start.line) && \r\n                ((position.line === range.end.line && position.character <= range.end.character) || position.line < range.end.line)\r\n                && data.isTrueGroup) \r\n            {\r\n                lastGroup = data.group;\r\n                lastGroup = data.group.findGroupOnLeftAtPosition(position, lastGroup, level + 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (lastGroup !== undefined && level === 0) {\r\n            lastGroup = lastGroup.findGroupOnLeftAtPosition(position, lastGroup, level + 1);\r\n        }\r\n\r\n        return lastGroup; \r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Select variable tokens like 'level.aaa.bbb' from document\r\n     * Needs to find boundaries of variable, for example: (| indicates cursor pos)\r\n     * \r\n     *      ...; abcd|         => abcd\r\n     *      abcd[abcd[0]|]     => abcd[0]\r\n     * \r\n     * @param position \r\n     * @returns \r\n     */\r\n    public getVariableStringBeforePosition(position: vscode.Position): string {\r\n        const groupAtCursor = this as GscGroup;\r\n\r\n        const tokens = groupAtCursor.tokensAll;\r\n\r\n        // Select variable tokens like 'level.aaa.bbb' from document\r\n        // Needs to find boundaries of variable, for example: (| indicates cursor pos)\r\n        //   ...; abcd|         => abcd\r\n        //   abcd[abcd[0]|]     => abcd[0]\r\n        var variableBeforeCursor = \"\";\r\n\r\n        // Find parent of scope or array\r\n        var scopeOfCursorGroup = groupAtCursor;\r\n        if (!groupAtCursor.typeEqualsToOneOf(...GscFileParser.scopeTypes)) {\r\n            scopeOfCursorGroup = groupAtCursor.findParentOfType(...GscFileParser.scopeTypes, GroupType.Array) ?? groupAtCursor;\r\n        }\r\n\r\n        // Loop tokens\r\n        for (var i = groupAtCursor.tokenIndexEnd; i >= 0; i--) {\r\n            const token = tokens[i];\r\n\r\n            if (token.range.end.isAfter(position)) {\r\n                continue;\r\n            }\r\n\r\n            const variableTokens = [TokenType.Keyword, TokenType.Structure, TokenType.ArrayStart, TokenType.ArrayEnd, TokenType.Array, TokenType.Number, \r\n                TokenType.String, TokenType.LocalizedString, TokenType.CvarString];\r\n            if (!variableTokens.includes(token.type) || i === scopeOfCursorGroup.tokenIndexStart) {\r\n                const startIndex = i + 1;\r\n                \r\n                // Now go to right untill cursor pos is reached\r\n                for (i = startIndex; i <= groupAtCursor.tokenIndexEnd; i++) {\r\n                    const token = tokens[i];\r\n                    var tokenName = \"\";\r\n\r\n                    if (token.range.contains(position)) {\r\n                        const endIndex = token.name.length - (token.range.end.character - position.character);\r\n                        tokenName = token.name.substring(0, endIndex);\r\n                    } else if (token.range.start.isBefore(position)) {\r\n                        tokenName = token.name;\r\n                    }\r\n                    // If token does not start with word character, exit, because its not variable start\r\n                    if (variableBeforeCursor === \"\" && !/^[a-zA-Z_]/.test(tokenName[0])) {\r\n                        break;\r\n                    }\r\n                    variableBeforeCursor += tokenName;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return variableBeforeCursor;\r\n    }\r\n\r\n\r\n    /**\r\n     * Create array of variable parts where structure fields and array accessors are considered as part.\r\n     * For example:\r\n     * \r\n     *      struct1.field1      => [\"struct1\", \".field\"]\r\n     *      array1[0].field1    => [\"array1\", \"[0]\", \".field1\"]\r\n     *      array1[1][0]        => [\"array1\", \"[1]\", \"[0]\"]\r\n     * \r\n     * @returns Array of parts\r\n     */\r\n    public getVariableParts(): {text: string, implicitType: GscVariableDefinitionType, kind: vscode.CompletionItemKind}[] {\r\n\r\n        const variableParts: {text: string, implicitType: GscVariableDefinitionType, kind: vscode.CompletionItemKind}[] = [];\r\n\r\n        loopVariableReference(this);\r\n\r\n\r\n        function loopVariableReference(group: GscGroup): boolean {\r\n            for (var i = 0; i < group.items.length; i++) {\r\n                const innerGroup = group.items[i];        \r\n                const prevPart = variableParts.at(-1);\r\n    \r\n                switch (innerGroup.type) {\r\n                \r\n                    case GroupType.VariableName:\r\n                        variableParts.push({\r\n                            text: innerGroup.getFirstToken().name,\r\n                            implicitType: GscVariableDefinitionType.Unknown,\r\n                            kind: vscode.CompletionItemKind.Variable\r\n                        });\r\n                        break;\r\n    \r\n                    case GroupType.Array:\r\n    \r\n                        // Previous part is of array type\r\n                        if (prevPart !== undefined) {\r\n                            prevPart.implicitType = GscVariableDefinitionType.Array;\r\n                        }\r\n    \r\n                        // Make sure arrays with non-constant values (eg game[1+1]) are ignored\r\n                        if (innerGroup.items.at(0)?.type !== GroupType.Constant) {\r\n                            variableParts.push({\r\n                                text: \"[]\",\r\n                                implicitType: GscVariableDefinitionType.Unknown,\r\n                                kind: vscode.CompletionItemKind.Variable\r\n                            });\r\n                            continue;\r\n                        } else {\r\n                            variableParts.push({\r\n                                text: \"[\" + innerGroup.items[0].getFirstToken().name + \"]\",\r\n                                implicitType: GscVariableDefinitionType.Unknown,\r\n                                kind: vscode.CompletionItemKind.Variable\r\n                            });\r\n                        }\r\n                    break;\r\n    \r\n                    case GroupType.Token: // .\r\n    \r\n                        // Previous part is of structure type\r\n                        if (prevPart !== undefined) {\r\n                            prevPart.implicitType = GscVariableDefinitionType.Structure;\r\n                        }\r\n    \r\n                        const field = group.items.at(i + 1);\r\n                        if (field?.type === GroupType.StructureField) {\r\n                            variableParts.push({\r\n                                text: innerGroup.getFirstToken().name + field.getFirstToken().name,\r\n                                implicitType: GscVariableDefinitionType.Unknown,\r\n                                kind: vscode.CompletionItemKind.Field\r\n                            });\r\n                            i++;\r\n                            continue;\r\n                        } else {\r\n                            variableParts.push({\r\n                                text: innerGroup.getFirstToken().name,\r\n                                implicitType: GscVariableDefinitionType.Unknown,\r\n                                kind: vscode.CompletionItemKind.Field\r\n                            });\r\n                        }\r\n                        break;\r\n    \r\n                    case GroupType.Reference:\r\n                        const mayContinue = loopVariableReference(innerGroup);\r\n                        if (mayContinue === false) {\r\n                            return false;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n    \r\n            // Continue\r\n            return true;\r\n        }\r\n\r\n        return variableParts;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Get path\r\n     * @param position \r\n     * @returns \r\n     */\r\n    public getPathStringBeforePosition(position: vscode.Position): string {\r\n        const groupAtCursor = this as GscGroup;\r\n\r\n        if (groupAtCursor.type !== GroupType.Path) {\r\n            return \"\";\r\n        }\r\n\r\n        const tokens = groupAtCursor.tokensAll;\r\n        var stringBeforeCursor = \"\";\r\n\r\n        // Loop tokens\r\n        for (var i = groupAtCursor.tokenIndexStart; i <= groupAtCursor.tokenIndexEnd; i++) {\r\n            const token = tokens[i];\r\n            if (token.range.contains(position)) {\r\n                const endIndex = token.name.length - (token.range.end.character - position.character);\r\n                stringBeforeCursor += token.name.substring(0, endIndex);\r\n            } else if (token.range.start.isBefore(position)) {\r\n                stringBeforeCursor += token.name;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return stringBeforeCursor;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets function name and path. The group must be of type {@linkcode GroupType.FunctionName}.\r\n     * @example\r\n     *  funcName()                          => {name: \"funcName\", path: \"\"}\r\n     *  maps\\mp\\gametypes\\file::funcName()  => {name: \"funcName\", path: \"maps\\mp\\gametypes\\file\"}\r\n     * @returns \r\n     */\r\n    public getFunctionNameAndPath(): {name: string, path: string} | undefined {\r\n        const locations: vscode.Location[] = [];\r\n        const group = this as GscGroup;\r\n        if (group.type !== GroupType.FunctionName) {\r\n            return undefined;\r\n        }\r\n\r\n        const funcName = group.getFirstToken().name;\r\n        var path = \"\";\r\n\r\n        // Its external function call\r\n        if (((group.parent?.type === GroupType.FunctionCall && group.parent?.parent?.type === GroupType.FunctionCall) ||\r\n              group.parent?.type === GroupType.FunctionPointer && group.parent?.parent?.type === GroupType.FunctionPointerExternal) &&\r\n            group.parent.parent.items[0].type === GroupType.Path) \r\n        {\r\n            path = group.parent.parent.items[0].getTokensAsString();\r\n        }\r\n        \r\n        return {name: funcName, path: path};\r\n    }\r\n\r\n\r\n\r\n\r\n    public getTokensBeforePosition(position: vscode.Position) {\r\n        return this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1).filter(f => position.isAfterOrEqual(f.range.end));\r\n    }\r\n\r\n    public getTokens() {\r\n        return this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1);\r\n    }\r\n\r\n    public getTokensAsString() {\r\n        return this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1).map(f => f.name).join(\"\");\r\n    }\r\n\r\n    public printTokens() {\r\n        return this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1).map(f => f.name).join(\" \");\r\n    }\r\n\r\n    public toString = () : string => {\r\n        return `{type: ${GroupType[this.type]}, tokens: ${this.tokenIndexStart} - ${this.tokenIndexEnd}, ${this.tokensAll.slice(this.tokenIndexStart, this.tokenIndexEnd+1).map((t) => t.name).join(\" \")}}`;\r\n    };\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport class GscData {\r\n    root: GscGroup;\r\n    functions: GscFunction[] = [];\r\n    levelVariablesDefinitions: GscVariableDefinition[] = [];\r\n    gameVariablesDefinitions: GscVariableDefinition[] = [];\r\n    includes: string[] = [];\r\n    content: string;\r\n\r\n    constructor(structure: GscGroup, content: string) {\r\n        this.root = structure;\r\n        this.content = content;\r\n    }\r\n}\r\n\r\n\r\n\r\ntype GscFunction = {\r\n    name: string;\r\n    parameters: GscToken[];\r\n    /** Local variable declarations like \"a = 1;\". Its always statement with item[0] as Reference */\r\n    localVariableDefinitions: GscVariableDefinition[];\r\n    range: vscode.Range;\r\n    scopeRange: vscode.Range;\r\n};\r\n\r\nexport type GscVariableDefinition = {\r\n    variableReference: GscGroup,\r\n    type: GscVariableDefinitionType\r\n};\r\n\r\n\r\n\r\n\r\nexport enum KeywordType {\r\n    Keyword,\r\n    Variable,\r\n    Constant,\r\n    Function,\r\n    Parameter,\r\n    Path\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport enum GscVariableDefinitionType {\r\n    Unknown,\r\n    Undefined,\r\n    Object,\r\n    String,\r\n    LocalizedString,\r\n    CvarString,\r\n    Vector,\r\n    Integer,\r\n    Float,\r\n    Structure,\r\n    Array,\r\n    Function,\r\n    Entity,\r\n    Bool,\r\n    XAnim,\r\n    UnknownValue,\r\n    UnknownValueFromVariable,\r\n    UnknownValueFromFunction\r\n}\r\n\r\n\r\n\r\n\r\ntype debugObject = {\r\n    a01_type: string,\r\n    a02_tokens: string,\r\n    a03_unsolved: string | undefined,\r\n    a04_deadCode: string | undefined,\r\n    a06_itemsArray: debugObject[]\r\n};\r\n\r\n\r\n","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscData } from './GscFileParser';\r\n\r\nexport class GscHoverProvider implements vscode.HoverProvider {\r\n    \r\n    static async activate(context: vscode.ExtensionContext) {       \r\n        context.subscriptions.push(vscode.languages.registerHoverProvider('gsc', new GscHoverProvider()));\r\n    }\r\n\r\n    public async provideHover(\r\n        document: vscode.TextDocument,\r\n        position: vscode.Position,\r\n        token: vscode.CancellationToken\r\n    ): Promise<vscode.Hover | undefined> \r\n    {\r\n        // Get parsed file\r\n        const gscData = await GscFile.getFile(document.uri);\r\n\r\n        const hover = await this.getHover(gscData, position, document.uri);\r\n\r\n        return hover;\r\n    }\r\n\r\n    public async getHover(gscData: GscData, position: vscode.Position, uri: vscode.Uri): Promise<vscode.Hover> {\r\n        let hoverText = new vscode.MarkdownString();\r\n\r\n        // Get group before cursor\r\n        var groupAtCursor = gscData.root.findGroupOnLeftAtPosition(position);\r\n\r\n        if (groupAtCursor?.type === GroupType.FunctionName) {\r\n            const funcNameAndPath = groupAtCursor.getFunctionNameAndPath();\r\n            if (funcNameAndPath !== undefined) {\r\n\r\n                // Get file URI and position where the file is defined\r\n                const definitions = await GscFile.getFunctionNameDefinitions(funcNameAndPath.name, funcNameAndPath.path, uri);\r\n\r\n                definitions.forEach(async d => {\r\n\r\n                    const gscData = await GscFile.getFile(d.uri);\r\n\r\n                    const functionData = gscData.functions.find(f => f.name === funcNameAndPath.name);\r\n\r\n                    if (functionData === undefined) { return; }\r\n\r\n                    const parametersText = functionData.parameters.map(p => p.name).join(\", \");\r\n\r\n                    hoverText.appendText(vscode.workspace.asRelativePath(d.uri));\r\n                    hoverText.appendMarkdown(\"\\n\\n\"); // Two newlines for a new paragraph, for more space you could use \"\\n\\n---\\n\\n\" for a horizontal rule\r\n                    hoverText.appendMarkdown(`**${funcNameAndPath.name}**(${parametersText})`);\r\n                });\r\n            }\r\n        }\r\n\r\n        \r\n\r\n\r\n        return new vscode.Hover(hoverText);\r\n    }\r\n}","import * as vscode from 'vscode';\r\nimport { GscFile } from './GscFile';\r\nimport { GroupType, GscGroup} from './GscFileParser';\r\n\r\n\r\nexport class GscSemanticTokensProvider implements vscode.DocumentSemanticTokensProvider {\r\n\t\r\n    //https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#standard-token-types-and-modifiers\r\n    public static tokenTypes = [\r\n        'namespace',    // (blue-green) For identifiers that declare or reference a namespace, module, or package.\r\n        'class',        // (blue-green) For identifiers that declare or reference a class type.\r\n        'keyword',      // (purple) For tokens that represent a language keyword.\r\n        'function',     // (yellow) For identifiers that declare a function.\r\n        'parameter',    // (light-blue) For identifiers that declare or reference a function or method parameters.\r\n        'variable',     // (light-blue) For identifiers that declare or reference a local or global variable.\r\n        'property',     // (light-blue) For identifiers that declare or reference a member property, member field, or member variable.\r\n        'enumMember',   // (dark blue) For identifiers that declare or reference an enumeration property, constant, or member.\r\n        'event',        // (light-blue)\r\n        'method',       // (yellow)\r\n        'macro',        // (dark dark blue)\r\n        'label',        // (white)\r\n        'string'        // (orange) For tokens that represent a string literal.\r\n    ];  \r\n    public static tokenModifiers = [\r\n        'declaration',      // For declarations of symbols.\r\n        'static',           // For class members (static members).\r\n        'readonly',         // For readonly variables and member fields (constants).\r\n        'modification',\t    // For variable references where the variable is assigned to.\r\n        'defaultLibrary'    // For symbols that are part of the standard library.\r\n    ];\r\n    \r\n    public static legend = new vscode.SemanticTokensLegend(this.tokenTypes, this.tokenModifiers);\r\n    \r\n\r\n    static async activate(context: vscode.ExtensionContext) {\r\n        \r\n        context.subscriptions.push(vscode.languages.registerDocumentSemanticTokensProvider({ language: 'gsc' }, new GscSemanticTokensProvider(), GscSemanticTokensProvider.legend));\r\n    }\r\n\r\n\r\n\r\n    async provideDocumentSemanticTokens(\r\n\t  document: vscode.TextDocument\r\n\t): Promise<vscode.SemanticTokens | undefined> {\r\n\t  // analyze the document and return semantic tokens\r\n\r\n\t\tconst builder = new vscode.SemanticTokensBuilder(GscSemanticTokensProvider.legend);\r\n\r\n\t\t//vscode.window.showWarningMessage(\"SemanticTokensBuilder\");\r\n\r\n   \r\n        var gsc = await GscFile.parseAndCacheFile(document.uri);\r\n\r\n        \r\n        function walkGroupItems(parentGroup: GscGroup, items: GscGroup[], action: (parentGroup: GscGroup, group: GscGroup) => void) {\r\n            // This object have child items, process them first\r\n            for (var i = 0; i < items.length; i++) {\r\n                var innerGroup = items[i];\r\n                walkGroupItems(innerGroup, innerGroup.items, action);\r\n                action(parentGroup, innerGroup);\r\n            }\r\n        }\r\n\r\n\r\n        walkGroupItems(gsc.root, gsc.root.items, (parentGroup, group) => {\r\n\r\n            /*          \r\n                'class',        // (blue-green) For identifiers that declare or reference a class type.\r\n                'keyword',      // (purple) For tokens that represent a language keyword.\r\n                'function',     // (yellow) For identifiers that declare a function.\r\n                'parameter',    // (light-blue) For identifiers that declare or reference a function or method parameters.\r\n                'variable',     // (light-blue, dark-blue with readonly) For identifiers that declare or reference a local or global variable.\r\n                'property',     // (light-blue, dark-blue with readonly) For identifiers that declare or reference a member property, member field, or member variable.\r\n                'enumMember',   // (dark blue) For identifiers that declare or reference an enumeration property, constant, or member.\r\n                'event',        // (light-blue)\r\n                'method',       // (yellow)\r\n                'macro',        // (dark dark blue)\r\n                'label',        // (white)\r\n                'string'        // (orange) For tokens that represent a string literal.\r\n            */     \r\n\r\n            if (group.type === GroupType.Path) {\r\n                builder.push(\r\n                    group.getRange(),\r\n                    'namespace',\r\n                    ['declaration']\r\n                );\r\n            }\r\n            else if (group.type === GroupType.FunctionName) {\r\n                builder.push(\r\n                    group.getRange(),\r\n                    'function',\r\n                    ['declaration']\r\n                );\r\n            }\r\n            else if (group.type === GroupType.VariableName) {\r\n                var token = group.getSingleToken();\r\n                if (token !== undefined && (token.name === \"level\" || token.name === \"game\" || token.name === \"self\")) {\r\n                    builder.push(\r\n                        group.getRange(),\r\n                        'variable',\r\n                        ['readonly']\r\n                    );\r\n                } else {\r\n                    builder.push(\r\n                        group.getRange(),\r\n                        'variable',\r\n                        ['declaration']\r\n                    );\r\n                }\r\n            }\r\n\r\n            else if (group.type === GroupType.StructureField) {\r\n                builder.push(\r\n                    group.getRange(),\r\n                    'variable',\r\n                    ['declaration']\r\n                );            \r\n            }\r\n            else if (group.type === GroupType.ReservedKeyword) {\r\n                builder.push(\r\n                    group.getRange(),\r\n                    'keyword',\r\n                    ['declaration']\r\n                );\r\n            }\r\n        });\r\n\r\n        //vscode.window.showInformationMessage(\"SemanticTokensBuilder done\");\r\n        \t\r\n\t\treturn builder.build();\r\n\t}\r\n};","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport { Gsc } from './Gsc';\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n\n\tconsole.log(\" \");\n\tconsole.log(\"- GSC extension ----------------------------------------------------------------------------\");\n\tconsole.log(\" \");\n\n\tGsc.activate(context);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}"],"names":["activate","context","GscFile","GscDiagnosticsCollection","GscSemanticTokensProvider","GscCompletionItemProvider","GscDefinitionProvider","GscHoverProvider","subscriptions","push","vscode","languages","registerCompletionItemProvider","provideCompletionItems","document","position","token","gscData","parseAndCacheFile","uri","getCompletionItems","onlyVariables","completionItems","startTime","performance","now","groupAtCursor","root","findGroupOnLeftAtPosition","undefined","parent","functionGroup","functions","find","f","range","scopeRange","line","start","character","end","type","GroupType","Path","this","createVariableItems","localVariableDefinitions","createPathItems","duration","console","log","variableItems","variableBeforeCursor","getVariableStringBeforePosition","inVariableName","typeEqualsToOneOf","VariableName","Identifier","inStructureVariable","StructureField","getFirstToken","name","inArrayBrackets","Array","getRange","at","nonWordChars","match","lastNonWordIndexInCursorVar","lastIndexOf","length","getCompletionItemFromVariableDefinition","g","variableParts","variableReference","getVariableParts","varName","GscVariableDefinitionType","Unknown","kind","CompletionItemKind","Variable","labelName","i","part","isLast","text","implicitType","startsWith","substring","endsWith","Value","getTokensAsString","existingItem","p","types","add","detail","Set","Structure","forEach","getCachedFiles","levelVariablesDefinitions","gameVariablesDefinitions","CompletionItem","label","description","getItemDescriptionFromTypes","Constant","Keyword","pathBeforeCursor","getPathStringBeforePosition","fileSubPath","lastPathIndex","replace","files","workspace","findFiles","keywords","file","relativePath","asRelativePath","path","subpathIndex","indexOf","subpathKeyword","slashIndex","folderName","some","k","Folder","exec","toLowerCase","fileName","File","unknownValueTypes","UnknownValue","UnknownValueFromFunction","UnknownValueFromVariable","typesString","filter","t","includes","map","str","join","registerDefinitionProvider","provideDefinition","getFile","getFunctionDefinitionLocations","documentUri","locations","FunctionName","funcData","getFunctionNameAndPath","getFunctionNameDefinitions","static","diagnosticCollection","createDiagnosticCollection","onDidParseDocument","updateDiagnostics","onDidDeleteDocument","deleteDiagnostics","diagnostics","gsc2","walkGroupItems","parentGroup","items","action","innerGroup","group","Statement","FunctionCall","FunctionCallWithThread","FunctionCallWithObject","FunctionCallWithObjectAndThread","KeywordCall","KeywordCallWithObject","Diagnostic","DiagnosticSeverity","Error","solved","TerminatedStatement","Expression","ForExpression","firstToken","getSingleToken","toString","ExtraTerminator","Information","set","delete","createDiagnosticsForAll","clear","gsc","Uri","parse","Map","EventEmitter","parseAllFiles","onDidCreateFiles","onCreateFiles","onDidDeleteFiles","onDeleteFiles","onDidRenameFiles","onRenameFiles","commands","registerCommand","async","window","activeTextEditor","debugParsedFile","GscFileParser","debugAsString","tokensAll","_onDidParseDocument","event","_onDidDeleteDocument","e","removeCachedFile","oldUri","newUri","parseAndCacheAllFiles","Date","getTime","elapsed","parsedFiles","size","fileUri","parseFile","fire","get","openedTextDocument","textDocuments","doc","content","getText","fileContent","fs","readFile","Buffer","from","funcName","filePath","data","Location","Position","parameters","v","padEnd","TokenType","Level","KeywordType","FunctionScope","IfScope","ForScope","WhileScope","SwitchScope","CaseScope","Scope","Reference","Vector","functionCallTypes","FunctionPointer","FunctionPointerExternal","valueTypes","tokens","tokenize","rootGroup","analyze","level","Default","levelChangeStart","char","skip","sLastComment","len","c","c_prev","c_next","SingleLineComment","MultiLineComment","PreprocessorName","test","addToken","Preprocessor","String","LocalizedString","CvarString","Number","Float","DeveloperStart","Assignment2","Operator","DeveloperEnd","Hashtag","ParameterSeparator","ScopeStart","ScopeEnd","ExpressionStart","ExpressionEnd","ArrayStart","ArrayEnd","PathSeparator","Case","Assignment3","OperatorLeft","Assignment","Semicolon","startOffset","endOffset","index","offset","Range","commentBefore","walkGroup","currentGroup","callForEmptyGroups","groupItems","startIndex","wrapType","trimGroupStartBy","trimGroupEndBy","groups","newGroup","GscGroup","tokenIndexStart","tokenIndexEnd","trimIndexStart","trimIndexEnd","slice","splice","replaceGroupsWithSingleGroup","endIndex","groupByBracketPairs","tokenTypeStart","tokenTypeEnd","groupType","startIndexes","tokenType","getSingleTokenType","indexStart","pop","changeGroupToSolvedAndChangeType","newType","XAnim","FunctionParametersExpression","KeywordParametersExpression","FunctionDeclaration","ForStatement","Terminator","group_byGroupAndToken","groupTypesLeft","finalType","finalGroup1Type","finalGroup2Type","childGroup1","childGroup2","typeOfUnknownToken2","getTypeOfUnknownToken","group_byGroupAndTokenAndGroup","groupTypesRight","finalGroup3Type","childGroup3","group_byGroupAndGroup","backward","group_byKeyword","keywordNames","childTokenName","ReservedKeyword","group_byKeywordNameAndGroup","keywordNamesLeft","groupTypes","Root","unsolvedTokens","DeveloperBlock","childGroup","unknownToken","getUnknownToken","knownKeywords","change_singleUnknownTokens","isUnsolvedGroupOfOneOfType","isUnsolvedSingleTokenOfOneOfType","isUnknownUnsolvedSingleTokenOfOneOfType","Token","group_numberSign","iPathStart","isWord","group_path","PreprocessorStatement","PreprocessorAnimtreeParametersExpression","innerGroup1","openBrackets","closeBrackets","FunctionDereference","IfDeclaration","ForDeclaration","WhileDeclaration","SwitchDeclaration","CaseLabel","isReservedKeywordOfName","group_byKeywordAndToken","group_byTokenAndGroup","allowedTypes","group1_isVarReference","unwrapType","group2_isThread","group3_isFuncCall","group2_isCall","group1_isObject","group_variables_and_function_call","childGroup4","valueTypesWithIdentifier","typeOfUnknownToken3","group_value_operations","childGroup5","change_expressionToVector","TerminatedPreprocessorStatement","keys","group_declarations","FunctionDefinition","group_the_rest","lastFunctionScope","DeveloperBlockInner","paramPos","lastLabel","FunctionParameterName","solve_unsolved","lastDeveloperScope","scopeTypes","GscData","lastFunction","func","paramTokens","element","addDefinition","otherReferences","unshift","r","array","variableDefinition","valueGroup","isFloat","Integer","Undefined","Bool","Function","Entity","debugGroupAsObject","tkns","a03_unsolved","a04_deadCode","deadCode","a01_type","a02_tokens","a06_itemsArray","item","itemDebug","printChilds","startGroup","s","write","debugGroupAsString","startGroupFound","writeLine","spaces1","repeat","spaces2","generateTestChecks","prefix","constructor","names","getIndex","findLastParentInSequenceOfType","findParentOfType","lastGroup","isTrueGroup","lastChildGroup","isBeforeOrEqual","isAfterOrEqual","scopeOfCursorGroup","isAfter","tokenName","contains","isBefore","loopVariableReference","prevPart","field","Field","stringBeforeCursor","getTokensBeforePosition","getTokens","printTokens","structure","registerHoverProvider","provideHover","getHover","hoverText","MarkdownString","funcNameAndPath","d","functionData","parametersText","appendText","appendMarkdown","Hover","SemanticTokensLegend","tokenTypes","tokenModifiers","registerDocumentSemanticTokensProvider","language","legend","provideDocumentSemanticTokens","builder","SemanticTokensBuilder","build","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","Gsc"],"sourceRoot":""}